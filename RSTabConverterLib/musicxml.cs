//------------------------------------------------------------------------------
// <auto-generated>
//     Dieser Code wurde von einem Tool generiert.
//     Laufzeitversion:4.0.30319.18444
//
//     Änderungen an dieser Datei können falsches Verhalten verursachen und gehen verloren, wenn
//     der Code erneut generiert wird.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Xml;
using System.Xml.Linq;
using System.Xml.Schema;
using Xml.Schema.Linq;
using www.w3.org.XML.Item1998.@namespace;



/// <summary>
/// <para>
/// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, part+)
/// </para>
/// </summary>
public partial class scorepartwise : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<credit> creditField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<partLocalType> partField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static string versionDefaultValue = "1.0";
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator scorepartwise(XElement xe) { return XTypedServices.ToXTypedElement<scorepartwise>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static scorepartwise() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("work", "")), new NamedContentModelEntity(XName.Get("movement-number", "")), new NamedContentModelEntity(XName.Get("movement-title", "")), new NamedContentModelEntity(XName.Get("identification", "")), new NamedContentModelEntity(XName.Get("defaults", "")), new NamedContentModelEntity(XName.Get("credit", "")), new NamedContentModelEntity(XName.Get("part-list", "")), new NamedContentModelEntity(XName.Get("part", "")));
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, part+)
    /// </para>
    /// </summary>
    public scorepartwise() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, part+)
    /// </para>
    /// </summary>
    public work work {
        get {
            XElement x = this.GetElement(XName.Get("work", ""));
            return ((work)(x));
        }
        set {
            this.SetElement(XName.Get("work", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The movement-number element specifies the number of a movement.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, part+)
    /// </para>
    /// </summary>
    public string movementnumber {
        get {
            XElement x = this.GetElement(XName.Get("movement-number", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("movement-number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// The movement-title element specifies the title of a movement, not including its number.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, part+)
    /// </para>
    /// </summary>
    public string movementtitle {
        get {
            XElement x = this.GetElement(XName.Get("movement-title", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("movement-title", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, part+)
    /// </para>
    /// </summary>
    public identification identification {
        get {
            XElement x = this.GetElement(XName.Get("identification", ""));
            return ((identification)(x));
        }
        set {
            this.SetElement(XName.Get("identification", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, part+)
    /// </para>
    /// </summary>
    public defaults defaults {
        get {
            XElement x = this.GetElement(XName.Get("defaults", ""));
            return ((defaults)(x));
        }
        set {
            this.SetElement(XName.Get("defaults", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, part+)
    /// </para>
    /// </summary>
    public IList<credit> credit {
        get {
            if ((this.creditField == null)) {
                this.creditField = new XTypedList<credit>(this, LinqToXsdTypeManager.Instance, XName.Get("credit", ""));
            }
            return this.creditField;
        }
        set {
            if ((value == null)) {
                this.creditField = null;
            }
            else {
                if ((this.creditField == null)) {
                    this.creditField = XTypedList<credit>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("credit", ""));
                }
                else {
                    XTypedServices.SetList<credit>(this.creditField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, part+)
    /// </para>
    /// </summary>
    public partlist partlist {
        get {
            XElement x = this.GetElement(XName.Get("part-list", ""));
            return ((partlist)(x));
        }
        set {
            this.SetElement(XName.Get("part-list", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, repeating
    /// </para>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, part+)
    /// </para>
    /// </summary>
    public IList<scorepartwise.partLocalType> part {
        get {
            if ((this.partField == null)) {
                this.partField = new XTypedList<partLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("part", ""));
            }
            return this.partField;
        }
        set {
            if ((value == null)) {
                this.partField = null;
            }
            else {
                if ((this.partField == null)) {
                    this.partField = XTypedList<partLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("part", ""));
                }
                else {
                    XTypedServices.SetList<partLocalType>(this.partField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string version {
        get {
            XAttribute x = this.Attribute(XName.Get("version", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype, versionDefaultValue);
        }
        set {
            this.SetAttribute(XName.Get("version", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("score-partwise", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Element;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public void Save(string xmlFile) {
        XTypedServices.Save(xmlFile, Untyped);
    }
    
    public void Save(System.IO.TextWriter tw) {
        XTypedServices.Save(tw, Untyped);
    }
    
    public void Save(System.Xml.XmlWriter xmlWriter) {
        XTypedServices.Save(xmlWriter, Untyped);
    }
    
    public static scorepartwise Load(string xmlFile) {
        return XTypedServices.Load<scorepartwise>(xmlFile);
    }
    
    public static scorepartwise Load(System.IO.TextReader xmlFile) {
        return XTypedServices.Load<scorepartwise>(xmlFile);
    }
    
    public static scorepartwise Parse(string xml) {
        return XTypedServices.Parse<scorepartwise>(xml);
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<scorepartwise>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("work", ""), typeof(work));
        localElementDictionary.Add(XName.Get("movement-number", ""), typeof(string));
        localElementDictionary.Add(XName.Get("movement-title", ""), typeof(string));
        localElementDictionary.Add(XName.Get("identification", ""), typeof(identification));
        localElementDictionary.Add(XName.Get("defaults", ""), typeof(defaults));
        localElementDictionary.Add(XName.Get("credit", ""), typeof(credit));
        localElementDictionary.Add(XName.Get("part-list", ""), typeof(partlist));
        localElementDictionary.Add(XName.Get("part", ""), typeof(partLocalType));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (measure+)
    /// </para>
    /// </summary>
    public partial class partLocalType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<measureLocalType> measureField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
         public static explicit operator partLocalType(XElement xe) { return XTypedServices.ToXTypedElement<partLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static partLocalType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("measure", "")));
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (measure+)
        /// </para>
        /// </summary>
        public partLocalType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (measure+)
        /// </para>
        /// </summary>
        public IList<scorepartwise.partLocalType.measureLocalType> measure {
            get {
                if ((this.measureField == null)) {
                    this.measureField = new XTypedList<measureLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("measure", ""));
                }
                return this.measureField;
            }
            set {
                if ((value == null)) {
                    this.measureField = null;
                }
                else {
                    if ((this.measureField == null)) {
                        this.measureField = XTypedList<measureLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("measure", ""));
                    }
                    else {
                        XTypedServices.SetList<measureLocalType>(this.measureField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string id {
            get {
                XAttribute x = this.Attribute(XName.Get("id", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("id", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("part", "");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<partLocalType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("measure", ""), typeof(measureLocalType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
        /// </para>
        /// </summary>
        public partial class measureLocalType : XTypedElement, IXMetaData {
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<note> noteField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<backup> backupField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<forward> forwardField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<direction> directionField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<attributes> attributesField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<harmony> harmonyField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<figuredbass> figuredbassField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<print> printField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<sound> soundField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<barline> barlineField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<grouping> groupingField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<link> linkField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<bookmark> bookmarkField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
            
         public static explicit operator measureLocalType(XElement xe) { return XTypedServices.ToXTypedElement<measureLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            static measureLocalType() {
                BuildElementDictionary();
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public measureLocalType() {
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<note> note {
                get {
                    if ((this.noteField == null)) {
                        this.noteField = new XTypedList<note>(this, LinqToXsdTypeManager.Instance, XName.Get("note", ""));
                    }
                    return this.noteField;
                }
                set {
                    if ((value == null)) {
                        this.noteField = null;
                    }
                    else {
                        if ((this.noteField == null)) {
                            this.noteField = XTypedList<note>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("note", ""));
                        }
                        else {
                            XTypedServices.SetList<note>(this.noteField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<backup> backup {
                get {
                    if ((this.backupField == null)) {
                        this.backupField = new XTypedList<backup>(this, LinqToXsdTypeManager.Instance, XName.Get("backup", ""));
                    }
                    return this.backupField;
                }
                set {
                    if ((value == null)) {
                        this.backupField = null;
                    }
                    else {
                        if ((this.backupField == null)) {
                            this.backupField = XTypedList<backup>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("backup", ""));
                        }
                        else {
                            XTypedServices.SetList<backup>(this.backupField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<forward> forward {
                get {
                    if ((this.forwardField == null)) {
                        this.forwardField = new XTypedList<forward>(this, LinqToXsdTypeManager.Instance, XName.Get("forward", ""));
                    }
                    return this.forwardField;
                }
                set {
                    if ((value == null)) {
                        this.forwardField = null;
                    }
                    else {
                        if ((this.forwardField == null)) {
                            this.forwardField = XTypedList<forward>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("forward", ""));
                        }
                        else {
                            XTypedServices.SetList<forward>(this.forwardField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<direction> direction {
                get {
                    if ((this.directionField == null)) {
                        this.directionField = new XTypedList<direction>(this, LinqToXsdTypeManager.Instance, XName.Get("direction", ""));
                    }
                    return this.directionField;
                }
                set {
                    if ((value == null)) {
                        this.directionField = null;
                    }
                    else {
                        if ((this.directionField == null)) {
                            this.directionField = XTypedList<direction>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("direction", ""));
                        }
                        else {
                            XTypedServices.SetList<direction>(this.directionField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<attributes> attributes {
                get {
                    if ((this.attributesField == null)) {
                        this.attributesField = new XTypedList<attributes>(this, LinqToXsdTypeManager.Instance, XName.Get("attributes", ""));
                    }
                    return this.attributesField;
                }
                set {
                    if ((value == null)) {
                        this.attributesField = null;
                    }
                    else {
                        if ((this.attributesField == null)) {
                            this.attributesField = XTypedList<attributes>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("attributes", ""));
                        }
                        else {
                            XTypedServices.SetList<attributes>(this.attributesField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<harmony> harmony {
                get {
                    if ((this.harmonyField == null)) {
                        this.harmonyField = new XTypedList<harmony>(this, LinqToXsdTypeManager.Instance, XName.Get("harmony", ""));
                    }
                    return this.harmonyField;
                }
                set {
                    if ((value == null)) {
                        this.harmonyField = null;
                    }
                    else {
                        if ((this.harmonyField == null)) {
                            this.harmonyField = XTypedList<harmony>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("harmony", ""));
                        }
                        else {
                            XTypedServices.SetList<harmony>(this.harmonyField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<figuredbass> figuredbass {
                get {
                    if ((this.figuredbassField == null)) {
                        this.figuredbassField = new XTypedList<figuredbass>(this, LinqToXsdTypeManager.Instance, XName.Get("figured-bass", ""));
                    }
                    return this.figuredbassField;
                }
                set {
                    if ((value == null)) {
                        this.figuredbassField = null;
                    }
                    else {
                        if ((this.figuredbassField == null)) {
                            this.figuredbassField = XTypedList<figuredbass>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("figured-bass", ""));
                        }
                        else {
                            XTypedServices.SetList<figuredbass>(this.figuredbassField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<print> print {
                get {
                    if ((this.printField == null)) {
                        this.printField = new XTypedList<print>(this, LinqToXsdTypeManager.Instance, XName.Get("print", ""));
                    }
                    return this.printField;
                }
                set {
                    if ((value == null)) {
                        this.printField = null;
                    }
                    else {
                        if ((this.printField == null)) {
                            this.printField = XTypedList<print>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("print", ""));
                        }
                        else {
                            XTypedServices.SetList<print>(this.printField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<sound> sound {
                get {
                    if ((this.soundField == null)) {
                        this.soundField = new XTypedList<sound>(this, LinqToXsdTypeManager.Instance, XName.Get("sound", ""));
                    }
                    return this.soundField;
                }
                set {
                    if ((value == null)) {
                        this.soundField = null;
                    }
                    else {
                        if ((this.soundField == null)) {
                            this.soundField = XTypedList<sound>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("sound", ""));
                        }
                        else {
                            XTypedServices.SetList<sound>(this.soundField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<barline> barline {
                get {
                    if ((this.barlineField == null)) {
                        this.barlineField = new XTypedList<barline>(this, LinqToXsdTypeManager.Instance, XName.Get("barline", ""));
                    }
                    return this.barlineField;
                }
                set {
                    if ((value == null)) {
                        this.barlineField = null;
                    }
                    else {
                        if ((this.barlineField == null)) {
                            this.barlineField = XTypedList<barline>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("barline", ""));
                        }
                        else {
                            XTypedServices.SetList<barline>(this.barlineField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<grouping> grouping {
                get {
                    if ((this.groupingField == null)) {
                        this.groupingField = new XTypedList<grouping>(this, LinqToXsdTypeManager.Instance, XName.Get("grouping", ""));
                    }
                    return this.groupingField;
                }
                set {
                    if ((value == null)) {
                        this.groupingField = null;
                    }
                    else {
                        if ((this.groupingField == null)) {
                            this.groupingField = XTypedList<grouping>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("grouping", ""));
                        }
                        else {
                            XTypedServices.SetList<grouping>(this.groupingField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<link> link {
                get {
                    if ((this.linkField == null)) {
                        this.linkField = new XTypedList<link>(this, LinqToXsdTypeManager.Instance, XName.Get("link", ""));
                    }
                    return this.linkField;
                }
                set {
                    if ((value == null)) {
                        this.linkField = null;
                    }
                    else {
                        if ((this.linkField == null)) {
                            this.linkField = XTypedList<link>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("link", ""));
                        }
                        else {
                            XTypedServices.SetList<link>(this.linkField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<bookmark> bookmark {
                get {
                    if ((this.bookmarkField == null)) {
                        this.bookmarkField = new XTypedList<bookmark>(this, LinqToXsdTypeManager.Instance, XName.Get("bookmark", ""));
                    }
                    return this.bookmarkField;
                }
                set {
                    if ((value == null)) {
                        this.bookmarkField = null;
                    }
                    else {
                        if ((this.bookmarkField == null)) {
                            this.bookmarkField = XTypedList<bookmark>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("bookmark", ""));
                        }
                        else {
                            XTypedServices.SetList<bookmark>(this.bookmarkField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string number {
                get {
                    XAttribute x = this.Attribute(XName.Get("number", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public string @implicit {
                get {
                    XAttribute x = this.Attribute(XName.Get("implicit", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("implicit", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public string noncontrolling {
                get {
                    XAttribute x = this.Attribute(XName.Get("non-controlling", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("non-controlling", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: optional
            /// </para>
            /// </summary>
            public System.Nullable<decimal> width {
                get {
                    XAttribute x = this.Attribute(XName.Get("width", ""));
                    if ((x == null)) {
                        return null;
                    }
                    return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("width", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                get {
                    return localElementDictionary;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("measure", "");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<measureLocalType>(this);
            }
            
            private static void BuildElementDictionary() {
                localElementDictionary.Add(XName.Get("note", ""), typeof(note));
                localElementDictionary.Add(XName.Get("backup", ""), typeof(backup));
                localElementDictionary.Add(XName.Get("forward", ""), typeof(forward));
                localElementDictionary.Add(XName.Get("direction", ""), typeof(direction));
                localElementDictionary.Add(XName.Get("attributes", ""), typeof(attributes));
                localElementDictionary.Add(XName.Get("harmony", ""), typeof(harmony));
                localElementDictionary.Add(XName.Get("figured-bass", ""), typeof(figuredbass));
                localElementDictionary.Add(XName.Get("print", ""), typeof(print));
                localElementDictionary.Add(XName.Get("sound", ""), typeof(sound));
                localElementDictionary.Add(XName.Get("barline", ""), typeof(barline));
                localElementDictionary.Add(XName.Get("grouping", ""), typeof(grouping));
                localElementDictionary.Add(XName.Get("link", ""), typeof(link));
                localElementDictionary.Add(XName.Get("bookmark", ""), typeof(bookmark));
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return ContentModelEntity.Default;
            }
        }
    }
}

/// <summary>
/// <para>
/// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, measure+)
/// </para>
/// </summary>
public partial class scoretimewise : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<credit> creditField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<measureLocalType> measureField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static string versionDefaultValue = "1.0";
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator scoretimewise(XElement xe) { return XTypedServices.ToXTypedElement<scoretimewise>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static scoretimewise() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("work", "")), new NamedContentModelEntity(XName.Get("movement-number", "")), new NamedContentModelEntity(XName.Get("movement-title", "")), new NamedContentModelEntity(XName.Get("identification", "")), new NamedContentModelEntity(XName.Get("defaults", "")), new NamedContentModelEntity(XName.Get("credit", "")), new NamedContentModelEntity(XName.Get("part-list", "")), new NamedContentModelEntity(XName.Get("measure", "")));
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, measure+)
    /// </para>
    /// </summary>
    public scoretimewise() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, measure+)
    /// </para>
    /// </summary>
    public work work {
        get {
            XElement x = this.GetElement(XName.Get("work", ""));
            return ((work)(x));
        }
        set {
            this.SetElement(XName.Get("work", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The movement-number element specifies the number of a movement.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, measure+)
    /// </para>
    /// </summary>
    public string movementnumber {
        get {
            XElement x = this.GetElement(XName.Get("movement-number", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("movement-number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// The movement-title element specifies the title of a movement, not including its number.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, measure+)
    /// </para>
    /// </summary>
    public string movementtitle {
        get {
            XElement x = this.GetElement(XName.Get("movement-title", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("movement-title", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, measure+)
    /// </para>
    /// </summary>
    public identification identification {
        get {
            XElement x = this.GetElement(XName.Get("identification", ""));
            return ((identification)(x));
        }
        set {
            this.SetElement(XName.Get("identification", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, measure+)
    /// </para>
    /// </summary>
    public defaults defaults {
        get {
            XElement x = this.GetElement(XName.Get("defaults", ""));
            return ((defaults)(x));
        }
        set {
            this.SetElement(XName.Get("defaults", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, measure+)
    /// </para>
    /// </summary>
    public IList<credit> credit {
        get {
            if ((this.creditField == null)) {
                this.creditField = new XTypedList<credit>(this, LinqToXsdTypeManager.Instance, XName.Get("credit", ""));
            }
            return this.creditField;
        }
        set {
            if ((value == null)) {
                this.creditField = null;
            }
            else {
                if ((this.creditField == null)) {
                    this.creditField = XTypedList<credit>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("credit", ""));
                }
                else {
                    XTypedServices.SetList<credit>(this.creditField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, measure+)
    /// </para>
    /// </summary>
    public partlist partlist {
        get {
            XElement x = this.GetElement(XName.Get("part-list", ""));
            return ((partlist)(x));
        }
        set {
            this.SetElement(XName.Get("part-list", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, repeating
    /// </para>
    /// <para>
    /// Regular expression: (work?, movementnumber?, movementtitle?, identification?, defaults?, credit*, partlist, measure+)
    /// </para>
    /// </summary>
    public IList<scoretimewise.measureLocalType> measure {
        get {
            if ((this.measureField == null)) {
                this.measureField = new XTypedList<measureLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("measure", ""));
            }
            return this.measureField;
        }
        set {
            if ((value == null)) {
                this.measureField = null;
            }
            else {
                if ((this.measureField == null)) {
                    this.measureField = XTypedList<measureLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("measure", ""));
                }
                else {
                    XTypedServices.SetList<measureLocalType>(this.measureField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string version {
        get {
            XAttribute x = this.Attribute(XName.Get("version", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype, versionDefaultValue);
        }
        set {
            this.SetAttribute(XName.Get("version", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("score-timewise", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Element;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public void Save(string xmlFile) {
        XTypedServices.Save(xmlFile, Untyped);
    }
    
    public void Save(System.IO.TextWriter tw) {
        XTypedServices.Save(tw, Untyped);
    }
    
    public void Save(System.Xml.XmlWriter xmlWriter) {
        XTypedServices.Save(xmlWriter, Untyped);
    }
    
    public static scoretimewise Load(string xmlFile) {
        return XTypedServices.Load<scoretimewise>(xmlFile);
    }
    
    public static scoretimewise Load(System.IO.TextReader xmlFile) {
        return XTypedServices.Load<scoretimewise>(xmlFile);
    }
    
    public static scoretimewise Parse(string xml) {
        return XTypedServices.Parse<scoretimewise>(xml);
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<scoretimewise>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("work", ""), typeof(work));
        localElementDictionary.Add(XName.Get("movement-number", ""), typeof(string));
        localElementDictionary.Add(XName.Get("movement-title", ""), typeof(string));
        localElementDictionary.Add(XName.Get("identification", ""), typeof(identification));
        localElementDictionary.Add(XName.Get("defaults", ""), typeof(defaults));
        localElementDictionary.Add(XName.Get("credit", ""), typeof(credit));
        localElementDictionary.Add(XName.Get("part-list", ""), typeof(partlist));
        localElementDictionary.Add(XName.Get("measure", ""), typeof(measureLocalType));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
    
    /// <summary>
    /// <para>
    /// Regular expression: (part+)
    /// </para>
    /// </summary>
    public partial class measureLocalType : XTypedElement, IXMetaData {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private XTypedList<partLocalType> partField;
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        private static ContentModelEntity contentModel;
        
         public static explicit operator measureLocalType(XElement xe) { return XTypedServices.ToXTypedElement<measureLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        static measureLocalType() {
            BuildElementDictionary();
            contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("part", "")));
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: (part+)
        /// </para>
        /// </summary>
        public measureLocalType() {
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required, repeating
        /// </para>
        /// <para>
        /// Regular expression: (part+)
        /// </para>
        /// </summary>
        public IList<scoretimewise.measureLocalType.partLocalType> part {
            get {
                if ((this.partField == null)) {
                    this.partField = new XTypedList<partLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("part", ""));
                }
                return this.partField;
            }
            set {
                if ((value == null)) {
                    this.partField = null;
                }
                else {
                    if ((this.partField == null)) {
                        this.partField = XTypedList<partLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("part", ""));
                    }
                    else {
                        XTypedServices.SetList<partLocalType>(this.partField, value);
                    }
                }
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: required
        /// </para>
        /// </summary>
        public string number {
            get {
                XAttribute x = this.Attribute(XName.Get("number", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string @implicit {
            get {
                XAttribute x = this.Attribute(XName.Get("implicit", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("implicit", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string noncontrolling {
            get {
                XAttribute x = this.Attribute(XName.Get("non-controlling", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("non-controlling", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public System.Nullable<decimal> width {
            get {
                XAttribute x = this.Attribute(XName.Get("width", ""));
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("width", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
            get {
                return localElementDictionary;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("measure", "");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<measureLocalType>(this);
        }
        
        private static void BuildElementDictionary() {
            localElementDictionary.Add(XName.Get("part", ""), typeof(partLocalType));
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return contentModel;
        }
        
        /// <summary>
        /// <para>
        /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
        /// </para>
        /// </summary>
        public partial class partLocalType : XTypedElement, IXMetaData {
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<note> noteField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<backup> backupField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<forward> forwardField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<direction> directionField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<attributes> attributesField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<harmony> harmonyField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<figuredbass> figuredbassField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<print> printField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<sound> soundField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<barline> barlineField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<grouping> groupingField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<link> linkField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            private XTypedList<bookmark> bookmarkField;
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
            
         public static explicit operator partLocalType(XElement xe) { return XTypedServices.ToXTypedElement<partLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
            
            static partLocalType() {
                BuildElementDictionary();
            }
            
            /// <summary>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public partLocalType() {
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<note> note {
                get {
                    if ((this.noteField == null)) {
                        this.noteField = new XTypedList<note>(this, LinqToXsdTypeManager.Instance, XName.Get("note", ""));
                    }
                    return this.noteField;
                }
                set {
                    if ((value == null)) {
                        this.noteField = null;
                    }
                    else {
                        if ((this.noteField == null)) {
                            this.noteField = XTypedList<note>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("note", ""));
                        }
                        else {
                            XTypedServices.SetList<note>(this.noteField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<backup> backup {
                get {
                    if ((this.backupField == null)) {
                        this.backupField = new XTypedList<backup>(this, LinqToXsdTypeManager.Instance, XName.Get("backup", ""));
                    }
                    return this.backupField;
                }
                set {
                    if ((value == null)) {
                        this.backupField = null;
                    }
                    else {
                        if ((this.backupField == null)) {
                            this.backupField = XTypedList<backup>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("backup", ""));
                        }
                        else {
                            XTypedServices.SetList<backup>(this.backupField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<forward> forward {
                get {
                    if ((this.forwardField == null)) {
                        this.forwardField = new XTypedList<forward>(this, LinqToXsdTypeManager.Instance, XName.Get("forward", ""));
                    }
                    return this.forwardField;
                }
                set {
                    if ((value == null)) {
                        this.forwardField = null;
                    }
                    else {
                        if ((this.forwardField == null)) {
                            this.forwardField = XTypedList<forward>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("forward", ""));
                        }
                        else {
                            XTypedServices.SetList<forward>(this.forwardField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<direction> direction {
                get {
                    if ((this.directionField == null)) {
                        this.directionField = new XTypedList<direction>(this, LinqToXsdTypeManager.Instance, XName.Get("direction", ""));
                    }
                    return this.directionField;
                }
                set {
                    if ((value == null)) {
                        this.directionField = null;
                    }
                    else {
                        if ((this.directionField == null)) {
                            this.directionField = XTypedList<direction>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("direction", ""));
                        }
                        else {
                            XTypedServices.SetList<direction>(this.directionField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<attributes> attributes {
                get {
                    if ((this.attributesField == null)) {
                        this.attributesField = new XTypedList<attributes>(this, LinqToXsdTypeManager.Instance, XName.Get("attributes", ""));
                    }
                    return this.attributesField;
                }
                set {
                    if ((value == null)) {
                        this.attributesField = null;
                    }
                    else {
                        if ((this.attributesField == null)) {
                            this.attributesField = XTypedList<attributes>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("attributes", ""));
                        }
                        else {
                            XTypedServices.SetList<attributes>(this.attributesField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<harmony> harmony {
                get {
                    if ((this.harmonyField == null)) {
                        this.harmonyField = new XTypedList<harmony>(this, LinqToXsdTypeManager.Instance, XName.Get("harmony", ""));
                    }
                    return this.harmonyField;
                }
                set {
                    if ((value == null)) {
                        this.harmonyField = null;
                    }
                    else {
                        if ((this.harmonyField == null)) {
                            this.harmonyField = XTypedList<harmony>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("harmony", ""));
                        }
                        else {
                            XTypedServices.SetList<harmony>(this.harmonyField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<figuredbass> figuredbass {
                get {
                    if ((this.figuredbassField == null)) {
                        this.figuredbassField = new XTypedList<figuredbass>(this, LinqToXsdTypeManager.Instance, XName.Get("figured-bass", ""));
                    }
                    return this.figuredbassField;
                }
                set {
                    if ((value == null)) {
                        this.figuredbassField = null;
                    }
                    else {
                        if ((this.figuredbassField == null)) {
                            this.figuredbassField = XTypedList<figuredbass>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("figured-bass", ""));
                        }
                        else {
                            XTypedServices.SetList<figuredbass>(this.figuredbassField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<print> print {
                get {
                    if ((this.printField == null)) {
                        this.printField = new XTypedList<print>(this, LinqToXsdTypeManager.Instance, XName.Get("print", ""));
                    }
                    return this.printField;
                }
                set {
                    if ((value == null)) {
                        this.printField = null;
                    }
                    else {
                        if ((this.printField == null)) {
                            this.printField = XTypedList<print>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("print", ""));
                        }
                        else {
                            XTypedServices.SetList<print>(this.printField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<sound> sound {
                get {
                    if ((this.soundField == null)) {
                        this.soundField = new XTypedList<sound>(this, LinqToXsdTypeManager.Instance, XName.Get("sound", ""));
                    }
                    return this.soundField;
                }
                set {
                    if ((value == null)) {
                        this.soundField = null;
                    }
                    else {
                        if ((this.soundField == null)) {
                            this.soundField = XTypedList<sound>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("sound", ""));
                        }
                        else {
                            XTypedServices.SetList<sound>(this.soundField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<barline> barline {
                get {
                    if ((this.barlineField == null)) {
                        this.barlineField = new XTypedList<barline>(this, LinqToXsdTypeManager.Instance, XName.Get("barline", ""));
                    }
                    return this.barlineField;
                }
                set {
                    if ((value == null)) {
                        this.barlineField = null;
                    }
                    else {
                        if ((this.barlineField == null)) {
                            this.barlineField = XTypedList<barline>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("barline", ""));
                        }
                        else {
                            XTypedServices.SetList<barline>(this.barlineField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<grouping> grouping {
                get {
                    if ((this.groupingField == null)) {
                        this.groupingField = new XTypedList<grouping>(this, LinqToXsdTypeManager.Instance, XName.Get("grouping", ""));
                    }
                    return this.groupingField;
                }
                set {
                    if ((value == null)) {
                        this.groupingField = null;
                    }
                    else {
                        if ((this.groupingField == null)) {
                            this.groupingField = XTypedList<grouping>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("grouping", ""));
                        }
                        else {
                            XTypedServices.SetList<grouping>(this.groupingField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<link> link {
                get {
                    if ((this.linkField == null)) {
                        this.linkField = new XTypedList<link>(this, LinqToXsdTypeManager.Instance, XName.Get("link", ""));
                    }
                    return this.linkField;
                }
                set {
                    if ((value == null)) {
                        this.linkField = null;
                    }
                    else {
                        if ((this.linkField == null)) {
                            this.linkField = XTypedList<link>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("link", ""));
                        }
                        else {
                            XTypedServices.SetList<link>(this.linkField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required, choice
            /// </para>
            /// <para>
            /// Setter: Appends
            /// </para>
            /// <para>
            /// Regular expression: ((note | backup | forward | direction | attributes | harmony | figuredbass | print | sound | barline | grouping | link | bookmark)*)
            /// </para>
            /// </summary>
            public IList<bookmark> bookmark {
                get {
                    if ((this.bookmarkField == null)) {
                        this.bookmarkField = new XTypedList<bookmark>(this, LinqToXsdTypeManager.Instance, XName.Get("bookmark", ""));
                    }
                    return this.bookmarkField;
                }
                set {
                    if ((value == null)) {
                        this.bookmarkField = null;
                    }
                    else {
                        if ((this.bookmarkField == null)) {
                            this.bookmarkField = XTypedList<bookmark>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("bookmark", ""));
                        }
                        else {
                            XTypedServices.SetList<bookmark>(this.bookmarkField, value);
                        }
                    }
                }
            }
            
            /// <summary>
            /// <para>
            /// Occurrence: required
            /// </para>
            /// </summary>
            public string id {
                get {
                    XAttribute x = this.Attribute(XName.Get("id", ""));
                    return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
                }
                set {
                    this.SetAttribute(XName.Get("id", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
                get {
                    return localElementDictionary;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            XName IXMetaData.SchemaName {
                get {
                    return XName.Get("part", "");
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            SchemaOrigin IXMetaData.TypeOrigin {
                get {
                    return SchemaOrigin.Fragment;
                }
            }
            
            [DebuggerBrowsable(DebuggerBrowsableState.Never)]
            ILinqToXsdTypeManager IXMetaData.TypeManager {
                get {
                    return LinqToXsdTypeManager.Instance;
                }
            }
            
            public override XTypedElement Clone() {
                return XTypedServices.CloneXTypedElement<partLocalType>(this);
            }
            
            private static void BuildElementDictionary() {
                localElementDictionary.Add(XName.Get("note", ""), typeof(note));
                localElementDictionary.Add(XName.Get("backup", ""), typeof(backup));
                localElementDictionary.Add(XName.Get("forward", ""), typeof(forward));
                localElementDictionary.Add(XName.Get("direction", ""), typeof(direction));
                localElementDictionary.Add(XName.Get("attributes", ""), typeof(attributes));
                localElementDictionary.Add(XName.Get("harmony", ""), typeof(harmony));
                localElementDictionary.Add(XName.Get("figured-bass", ""), typeof(figuredbass));
                localElementDictionary.Add(XName.Get("print", ""), typeof(print));
                localElementDictionary.Add(XName.Get("sound", ""), typeof(sound));
                localElementDictionary.Add(XName.Get("barline", ""), typeof(barline));
                localElementDictionary.Add(XName.Get("grouping", ""), typeof(grouping));
                localElementDictionary.Add(XName.Get("link", ""), typeof(link));
                localElementDictionary.Add(XName.Get("bookmark", ""), typeof(bookmark));
            }
            
            ContentModelEntity IXMetaData.GetContentModel() {
                return ContentModelEntity.Default;
            }
        }
    }
}

/// <summary>
/// <para>
/// The above-below type is used to indicate whether one element appears above or below another element.
/// </para>
/// </summary>
public sealed class abovebelow {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "above",
                    "below"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private abovebelow() {
    }
}

/// <summary>
/// <para>
/// The MusicXML format supports six levels of beaming, up to 1024th notes. Unlike the number-level type, the beam-level type identifies concurrent beams in a beam group. It does not distinguish overlapping beams such as grace notes within regular notes, or beams used in different voices.
/// </para>
/// </summary>
public sealed class beamlevel {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(320)), null, 0, 0, null, 8m, 0, null, 1m, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private beamlevel() {
    }
}

/// <summary>
/// <para>
/// The color type indicates the color of an element. Color may be represented as hexadecimal RGB triples, as in HTML, or as hexadecimal ARGB tuples, with the A indicating alpha of transparency. An alpha value of 00 is totally transparent; FF is totally opaque. If RGB is used, the A value is assumed to be FF. 
///
///For instance, the RGB value "#800080" represents purple. An ARGB value of "#40800080" would be a transparent purple.
///
///As in SVG 1.1, colors are defined in terms of the sRGB color space (IEC 61966).
/// </para>
/// </summary>
public sealed class color {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(8)), null, 0, 0, null, null, 0, null, null, 0, new string[] {
                    "#[\\dA-F]{6}([\\dA-F][\\dA-F])?"}, 0, XmlSchemaWhiteSpace.Collapse));
    
    private color() {
    }
}

/// <summary>
/// <para>
/// The comma-separated-text type is used to specify a comma-separated list of text elements, as is used by the font-family attribute.
/// </para>
/// </summary>
public sealed class commaseparatedtext {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(8)), null, 0, 0, null, null, 0, null, null, 0, new string[] {
                    "[^,]+(, ?[^,]+)*"}, 0, XmlSchemaWhiteSpace.Collapse));
    
    private commaseparatedtext() {
    }
}

/// <summary>
/// <para>
/// The css-font-size type includes the CSS font sizes used as an alternative to a numeric point size.
/// </para>
/// </summary>
public sealed class cssfontsize {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "xx-small",
                    "x-small",
                    "small",
                    "medium",
                    "large",
                    "x-large",
                    "xx-large"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private cssfontsize() {
    }
}

/// <summary>
/// <para>
/// The divisions type is used to express values in terms of the musical divisions defined by the divisions element. It is preferred that these be integer values both for MIDI interoperability and to avoid roundoff errors.
/// </para>
/// </summary>
public sealed class divisions {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal), null);
    
    private divisions() {
    }
}

/// <summary>
/// <para>
/// The enclosure-shape type describes the shape and presence / absence of an enclosure around text or symbols. A bracket enclosure is similar to a rectangle with the bottom line missing, as is common in jazz notation.
/// </para>
/// </summary>
public sealed class enclosureshape {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "rectangle",
                    "square",
                    "oval",
                    "circle",
                    "bracket",
                    "triangle",
                    "diamond",
                    "none"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private enclosureshape() {
    }
}

/// <summary>
/// <para>
/// The fermata-shape type represents the shape of the fermata sign. The empty value is equivalent to the normal value.
/// </para>
/// </summary>
public sealed class fermatashape {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "normal",
                    "angled",
                    "square",
                    ""}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private fermatashape() {
    }
}

/// <summary>
/// <para>
/// The font-size can be one of the CSS font sizes or a numeric point size.
/// </para>
/// </summary>
public sealed class fontsize {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.UnionSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType), null, new Xml.Schema.Linq.SimpleTypeValidator[] {
                new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal), null),
                cssfontsize.TypeDefinition});
    
    private fontsize() {
    }
}

/// <summary>
/// <para>
/// The font-style type represents a simplified version of the CSS font-style property.
/// </para>
/// </summary>
public sealed class fontstyle {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "normal",
                    "italic"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private fontstyle() {
    }
}

/// <summary>
/// <para>
/// The font-weight type represents a simplified version of the CSS font-weight property.
/// </para>
/// </summary>
public sealed class fontweight {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "normal",
                    "bold"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private fontweight() {
    }
}

/// <summary>
/// <para>
/// The left-center-right type is used to define horizontal alignment and text justification.
/// </para>
/// </summary>
public sealed class leftcenterright {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "left",
                    "center",
                    "right"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private leftcenterright() {
    }
}

/// <summary>
/// <para>
/// The left-right type is used to indicate whether one element appears to the left or the right of another element.
/// </para>
/// </summary>
public sealed class leftright {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "left",
                    "right"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private leftright() {
    }
}

/// <summary>
/// <para>
/// The line-shape type distinguishes between straight and curved lines.
/// </para>
/// </summary>
public sealed class lineshape {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "straight",
                    "curved"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private lineshape() {
    }
}

/// <summary>
/// <para>
/// The line-type type distinguishes between solid, dashed, dotted, and wavy lines.
/// </para>
/// </summary>
public sealed class linetype {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "solid",
                    "dashed",
                    "dotted",
                    "wavy"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private linetype() {
    }
}

/// <summary>
/// <para>
/// The midi-16 type is used to express MIDI 1.0 values that range from 1 to 16.
/// </para>
/// </summary>
public sealed class midi16 {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(320)), null, 0, 0, null, 16m, 0, null, 1m, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private midi16() {
    }
}

/// <summary>
/// <para>
/// The midi-16 type is used to express MIDI 1.0 values that range from 1 to 128.
/// </para>
/// </summary>
public sealed class midi128 {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(320)), null, 0, 0, null, 128m, 0, null, 1m, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private midi128() {
    }
}

/// <summary>
/// <para>
/// The midi-16 type is used to express MIDI 1.0 values that range from 1 to 16,384.
/// </para>
/// </summary>
public sealed class midi16384 {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(320)), null, 0, 0, null, 16384m, 0, null, 1m, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private midi16384() {
    }
}

/// <summary>
/// <para>
/// The mute type represents muting for different instruments, including brass, winds, and strings. The on and off values are used for undifferentiated mutes. The remaining values represent specific mutes.
/// </para>
/// </summary>
public sealed class mute {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "on",
                    "off",
                    "straight",
                    "cup",
                    "harmon-no-stem",
                    "harmon-stem",
                    "bucket",
                    "plunger",
                    "hat",
                    "solotone",
                    "practice",
                    "stop-mute",
                    "stop-hand",
                    "echo",
                    "palm"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private mute() {
    }
}

/// <summary>
/// <para>
/// The non-negative-decimal type specifies a non-negative decimal value.
/// </para>
/// </summary>
public sealed class nonnegativedecimal {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(256)), null, 0, 0, null, null, 0, null, 0m, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private nonnegativedecimal() {
    }
}

/// <summary>
/// <para>
/// Slurs, tuplets, and many other features can be concurrent and overlapping within a single musical part. The number-level type distinguishes up to six concurrent objects of the same type. A reading program should be prepared to handle cases where the number-levels stop in an arbitrary order. Different numbers are needed when the features overlap in MusicXML document order. When a number-level value is implied, the value is 1 by default.
/// </para>
/// </summary>
public sealed class numberlevel {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(320)), null, 0, 0, null, 6m, 0, null, 1m, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private numberlevel() {
    }
}

/// <summary>
/// <para>
/// The number-of-lines type is used to specify the number of lines in text decoration attributes.
/// </para>
/// </summary>
public sealed class numberoflines {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(320)), null, 0, 0, null, 3m, 0, null, 0m, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private numberoflines() {
    }
}

/// <summary>
/// <para>
/// The number-or-normal values can be either a decimal number or the string "normal". This is used by the line-height and letter-spacing attributes.
/// </para>
/// </summary>
public sealed class numberornormal {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.UnionSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType), null, new Xml.Schema.Linq.SimpleTypeValidator[] {
                new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal), null),
                new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                                "normal"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse))});
    
    private numberornormal() {
    }
}

/// <summary>
/// <para>
/// The over-under type is used to indicate whether the tips of curved lines such as slurs and ties are overhand (tips down) or underhand (tips up).
/// </para>
/// </summary>
public sealed class overunder {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "over",
                    "under"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private overunder() {
    }
}

/// <summary>
/// <para>
/// The percent type specifies a percentage from 0 to 100.
/// </para>
/// </summary>
public sealed class percent {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(320)), null, 0, 0, null, 100m, 0, null, 0m, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private percent() {
    }
}

/// <summary>
/// <para>
/// The positive-decimal type specifies a positive decimal value.
/// </para>
/// </summary>
public sealed class positivedecimal {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(512)), null, 0, 0, null, null, 0, 0m, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private positivedecimal() {
    }
}

/// <summary>
/// <para>
/// The positive-divisions type restricts divisions values to positive numbers.
/// </para>
/// </summary>
public sealed class positivedivisions {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(512)), null, 0, 0, null, null, 0, 0m, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private positivedivisions() {
    }
}

/// <summary>
/// <para>
/// The positive-integer-or-empty values can be either a positive integer or an empty string.
/// </para>
/// </summary>
public sealed class positiveintegerorempty {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.UnionSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType), null, new Xml.Schema.Linq.SimpleTypeValidator[] {
                new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger), null),
                new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                                ""}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve))});
    
    private positiveintegerorempty() {
    }
}

/// <summary>
/// <para>
/// The rotation-degrees type specifies rotation, pan, and elevation values in degrees. Values range from -180 to 180.
/// </para>
/// </summary>
public sealed class rotationdegrees {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(320)), null, 0, 0, null, 180m, 0, null, -180m, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private rotationdegrees() {
    }
}

/// <summary>
/// <para>
/// The semi-pitched type represents categories of indefinite pitch for percussion instruments.
/// </para>
/// </summary>
public sealed class semipitched {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "high",
                    "medium-high",
                    "medium",
                    "medium-low",
                    "low",
                    "very-low"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private semipitched() {
    }
}

/// <summary>
/// <para>
/// The start-note type describes the starting note of trills and mordents for playback, relative to the current note.
/// </para>
/// </summary>
public sealed class startnote {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "upper",
                    "main",
                    "below"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private startnote() {
    }
}

/// <summary>
/// <para>
/// The start-stop type is used for an attribute of musical elements that can either start or stop, such as tuplets.
///									
///The values of start and stop refer to how an element appears in musical score order, not in MusicXML document order. An element with a stop attribute may precede the corresponding element with a start attribute within a MusicXML document. This is particularly common in multi-staff music. For example, the stopping point for a tuplet may appear in staff 1 before the starting point for the tuplet appears in staff 2 later in the document.
/// </para>
/// </summary>
public sealed class startstop {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "start",
                    "stop"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private startstop() {
    }
}

/// <summary>
/// <para>
/// The start-stop-continue type is used for an attribute of musical elements that can either start or stop, but also need to refer to an intermediate point in the symbol, as for complex slurs or for formatting of symbols across system breaks.
///						
///The values of start, stop, and continue refer to how an element appears in musical score order, not in MusicXML document order. An element with a stop attribute may precede the corresponding element with a start attribute within a MusicXML document. This is particularly common in multi-staff music. For example, the stopping point for a slur may appear in staff 1 before the starting point for the slur appears in staff 2 later in the document.
/// </para>
/// </summary>
public sealed class startstopcontinue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "start",
                    "stop",
                    "continue"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private startstopcontinue() {
    }
}

/// <summary>
/// <para>
/// The start-stop-single type is used for an attribute of musical elements that can be used for either multi-note or single-note musical elements, as for tremolos.
/// </para>
/// </summary>
public sealed class startstopsingle {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "start",
                    "stop",
                    "single"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private startstopsingle() {
    }
}

/// <summary>
/// <para>
/// The string-number type indicates a string number. Strings are numbered from high to low, with 1 being the highest pitched string.
/// </para>
/// </summary>
public sealed class stringnumber {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger), null);
    
    private stringnumber() {
    }
}

/// <summary>
/// <para>
/// The symbol-size type is used to indicate full vs. cue-sized vs. oversized symbols. The large value for oversized symbols was added in version 1.1.
/// </para>
/// </summary>
public sealed class symbolsize {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "full",
                    "cue",
                    "large"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private symbolsize() {
    }
}

/// <summary>
/// <para>
/// The tenths type is a number representing tenths of interline staff space (positive or negative). Both integer and decimal values are allowed, such as 5 for a half space and 2.5 for a quarter space. Interline space is measured from the middle of a staff line.
///
///Distances in a MusicXML file are measured in tenths of staff space. Tenths are then scaled to millimeters within the scaling element, used in the defaults element at the start of a score. Individual staves can apply a scaling factor to adjust staff size. When a MusicXML element or attribute refers to tenths, it means the global tenths defined by the scaling element, not the local tenths as adjusted by the staff-size element.
/// </para>
/// </summary>
public sealed class tenths {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal), null);
    
    private tenths() {
    }
}

/// <summary>
/// <para>
/// The text-direction type is used to adjust and override the Unicode bidirectional text algorithm, similar to the W3C Internationalization Tag Set recommendation. Values are ltr (left-to-right embed), rtl (right-to-left embed), lro (left-to-right bidi-override), and rlo (right-to-left bidi-override). The default value is ltr. This type is typically used by applications that store text in left-to-right visual order rather than logical order. Such applications can use the lro value to better communicate with other applications that more fully support bidirectional text.
/// </para>
/// </summary>
public sealed class textdirection {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "ltr",
                    "rtl",
                    "lro",
                    "rlo"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private textdirection() {
    }
}

/// <summary>
/// <para>
/// The time-only type is used to indicate that a particular playback-related element only applies particular times through a repeated section. The value is a comma-separated list of positive integers arranged in ascending order, indicating which times through the repeated section that the element applies.
/// </para>
/// </summary>
public sealed class timeonly {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(8)), null, 0, 0, null, null, 0, null, null, 0, new string[] {
                    "[1-9][0-9]*(, ?[1-9][0-9]*)*"}, 0, XmlSchemaWhiteSpace.Collapse));
    
    private timeonly() {
    }
}

/// <summary>
/// <para>
/// The top-bottom type is used to indicate the top or bottom part of a vertical shape like non-arpeggiate.
/// </para>
/// </summary>
public sealed class topbottom {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "top",
                    "bottom"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private topbottom() {
    }
}

/// <summary>
/// <para>
/// The trill-beats type specifies the beats used in a trill-sound or bend-sound attribute group. It is a decimal value with a minimum value of 2.
/// </para>
/// </summary>
public sealed class trillbeats {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(256)), null, 0, 0, null, null, 0, null, 2m, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private trillbeats() {
    }
}

/// <summary>
/// <para>
/// The trill-step type describes the alternating note of trills and mordents for playback, relative to the current note.
/// </para>
/// </summary>
public sealed class trillstep {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "whole",
                    "half",
                    "unison"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private trillstep() {
    }
}

/// <summary>
/// <para>
/// The two-note-turn type describes the ending notes of trills and mordents for playback, relative to the current note.
/// </para>
/// </summary>
public sealed class twonoteturn {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "whole",
                    "half",
                    "none"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private twonoteturn() {
    }
}

/// <summary>
/// <para>
/// The up-down type is used for the direction of arrows and other pointed symbols like vertical accents, indicating which way the tip is pointing.
/// </para>
/// </summary>
public sealed class updown {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "up",
                    "down"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private updown() {
    }
}

/// <summary>
/// <para>
/// The upright-inverted type describes the appearance of a fermata element. The value is upright if not specified.
/// </para>
/// </summary>
public sealed class uprightinverted {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "upright",
                    "inverted"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private uprightinverted() {
    }
}

/// <summary>
/// <para>
/// The valign type is used to indicate vertical alignment to the top, middle, bottom, or baseline of the text. Defaults are implementation-dependent.
/// </para>
/// </summary>
public sealed class valign {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "top",
                    "middle",
                    "bottom",
                    "baseline"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private valign() {
    }
}

/// <summary>
/// <para>
/// The valign-image type is used to indicate vertical alignment for images and graphics, so it does not include a baseline value. Defaults are implementation-dependent.
/// </para>
/// </summary>
public sealed class valignimage {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "top",
                    "middle",
                    "bottom"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private valignimage() {
    }
}

/// <summary>
/// <para>
/// The yes-no type is used for boolean-like attributes. We cannot use W3C XML Schema booleans due to their restrictions on expression of boolean values.
/// </para>
/// </summary>
public sealed class yesno {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "yes",
                    "no"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private yesno() {
    }
}

/// <summary>
/// <para>
/// The yes-no-number type is used for attributes that can be either boolean or numeric values.
/// </para>
/// </summary>
public sealed class yesnonumber {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.UnionSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType), null, new Xml.Schema.Linq.SimpleTypeValidator[] {
                yesno.TypeDefinition,
                new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal), null)});
    
    private yesnonumber() {
    }
}

/// <summary>
/// <para>
/// Calendar dates are represented yyyy-mm-dd format, following ISO 8601. This is a W3C XML Schema date type, but without the optional timezone data.
/// </para>
/// </summary>
public sealed class yyyymmdd {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Date), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(8)), null, 0, 0, null, null, 0, null, null, 0, new string[] {
                    "[^:Z]*"}, 0, XmlSchemaWhiteSpace.Collapse));
    
    private yyyymmdd() {
    }
}

/// <summary>
/// <para>
/// The cancel-location type is used to indicate where a key signature cancellation appears relative to a new key signature: to the left, to the right, or before the barline and to the left. It is left by default. For mid-measure key elements, a cancel-location of before-barline should be treated like a cancel-location of left.
/// </para>
/// </summary>
public sealed class cancellocation {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "left",
                    "right",
                    "before-barline"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private cancellocation() {
    }
}

/// <summary>
/// <para>
/// The clef-sign element represents the different clef symbols. The jianpu sign indicates that the music that follows should be in jianpu numbered notation, just as the TAB sign indicates that the music that follows should be in tablature notation. Unlike TAB, a jianpu sign does not correspond to a visual clef notation.
/// </para>
/// </summary>
public sealed class clefsign {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "G",
                    "F",
                    "C",
                    "percussion",
                    "TAB",
                    "jianpu",
                    "none"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private clefsign() {
    }
}

/// <summary>
/// <para>
/// The fifths type represents the number of flats or sharps in a traditional key signature. Negative numbers are used for flats and positive numbers for sharps, reflecting the key's placement within the circle of fifths (hence the type name).
/// </para>
/// </summary>
public sealed class fifths {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer), null);
    
    private fifths() {
    }
}

/// <summary>
/// <para>
/// The mode type is used to specify major/minor and other mode distinctions. Valid mode values include major, minor, dorian, phrygian, lydian, mixolydian, aeolian, ionian, locrian, and none.
/// </para>
/// </summary>
public sealed class mode {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), null);
    
    private mode() {
    }
}

/// <summary>
/// <para>
/// The show-frets type indicates whether to show tablature frets as numbers (0, 1, 2) or letters (a, b, c). The default choice is numbers.
/// </para>
/// </summary>
public sealed class showfrets {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "numbers",
                    "letters"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private showfrets() {
    }
}

/// <summary>
/// <para>
/// The staff-line type indicates the line on a given staff. Staff lines are numbered from bottom to top, with 1 being the bottom line on a staff. Staff line values can be used to specify positions outside the staff, such as a C clef positioned in the middle of a grand staff.
/// </para>
/// </summary>
public sealed class staffline {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer), null);
    
    private staffline() {
    }
}

/// <summary>
/// <para>
/// The staff-number type indicates staff numbers within a multi-staff part. Staves are numbered from top to bottom, with 1 being the top staff on a part.
/// </para>
/// </summary>
public sealed class staffnumber {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger), null);
    
    private staffnumber() {
    }
}

/// <summary>
/// <para>
/// The staff-type value can be ossia, cue, editorial, regular, or alternate. An alternate staff indicates one that shares the same musical data as the prior staff, but displayed differently (e.g., treble and bass clef, standard notation and tab).
/// </para>
/// </summary>
public sealed class stafftype {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "ossia",
                    "cue",
                    "editorial",
                    "regular",
                    "alternate"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private stafftype() {
    }
}

/// <summary>
/// <para>
/// The time-relation type indicates the symbol used to represent the interchangeable aspect of dual time signatures.
/// </para>
/// </summary>
public sealed class timerelation {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "parentheses",
                    "bracket",
                    "equals",
                    "slash",
                    "space",
                    "hyphen"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private timerelation() {
    }
}

/// <summary>
/// <para>
/// The time-separator type indicates how to display the arrangement between the beats and beat-type values in a time signature. The default value is none. The horizontal, diagonal, and vertical values represent horizontal, diagonal lower-left to upper-right, and vertical lines respectively. For these values, the beats and beat-type values are arranged on either side of the separator line. The none value represents no separator with the beats and beat-type arranged vertically. The adjacent value represents no separator with the beats and beat-type arranged horizontally.
/// </para>
/// </summary>
public sealed class timeseparator {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "none",
                    "horizontal",
                    "diagonal",
                    "vertical",
                    "adjacent"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private timeseparator() {
    }
}

/// <summary>
/// <para>
/// The time-symbol type indicates how to display a time signature. The normal value is the usual fractional display, and is the implied symbol type if none is specified. Other options are the common and cut time symbols, as well as a single number with an implied denominator. The note symbol indicates that the beat-type should be represented with the corresponding downstem note rather than a number. The dotted-note symbol indicates that the beat-type should be represented with a dotted downstem note that corresponds to three times the beat-type value, and a numerator that is one third the beats value.
/// </para>
/// </summary>
public sealed class timesymbol {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "common",
                    "cut",
                    "single-number",
                    "note",
                    "dotted-note",
                    "normal"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private timesymbol() {
    }
}

/// <summary>
/// <para>
/// The backward-forward type is used to specify repeat directions. The start of the repeat has a forward direction while the end of the repeat has a backward direction.
/// </para>
/// </summary>
public sealed class backwardforward {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "backward",
                    "forward"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private backwardforward() {
    }
}

/// <summary>
/// <para>
/// The bar-style type represents barline style information. Choices are regular, dotted, dashed, heavy, light-light, light-heavy, heavy-light, heavy-heavy, tick (a short stroke through the top line), short (a partial barline between the 2nd and 4th lines), and none.
/// </para>
/// </summary>
public sealed class barstyle {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "regular",
                    "dotted",
                    "dashed",
                    "heavy",
                    "light-light",
                    "light-heavy",
                    "heavy-light",
                    "heavy-heavy",
                    "tick",
                    "short",
                    "none"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private barstyle() {
    }
}

/// <summary>
/// <para>
/// The ending-number type is used to specify either a comma-separated list of positive integers without leading zeros, or a string of zero or more spaces. It is used for the number attribute of the ending element. The zero or more spaces version is used when software knows that an ending is present, but cannot determine the type of the ending.
/// </para>
/// </summary>
public sealed class endingnumber {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(8)), null, 0, 0, null, null, 0, null, null, 0, new string[] {
                    "([ ]*)|([1-9][0-9]*(, ?[1-9][0-9]*)*)"}, 0, XmlSchemaWhiteSpace.Collapse));
    
    private endingnumber() {
    }
}

/// <summary>
/// <para>
/// The right-left-middle type is used to specify barline location.
/// </para>
/// </summary>
public sealed class rightleftmiddle {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "right",
                    "left",
                    "middle"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private rightleftmiddle() {
    }
}

/// <summary>
/// <para>
/// The start-stop-discontinue type is used to specify ending types. Typically, the start type is associated with the left barline of the first measure in an ending. The stop and discontinue types are associated with the right barline of the last measure in an ending. Stop is used when the ending mark concludes with a downward jog, as is typical for first endings. Discontinue is used when there is no downward jog, as is typical for second endings that do not conclude a piece.
/// </para>
/// </summary>
public sealed class startstopdiscontinue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "start",
                    "stop",
                    "discontinue"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private startstopdiscontinue() {
    }
}

/// <summary>
/// <para>
/// The winged attribute indicates whether the repeat has winged extensions that appear above and below the barline. The straight and curved values represent single wings, while the double-straight and double-curved values represent double wings. The none value indicates no wings and is the default.
/// </para>
/// </summary>
public sealed class winged {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "none",
                    "straight",
                    "curved",
                    "double-straight",
                    "double-curved"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private winged() {
    }
}

/// <summary>
/// <para>
/// The accordion-middle type may have values of 1, 2, or 3, corresponding to having 1 to 3 dots in the middle section of the accordion registration symbol.
/// </para>
/// </summary>
public sealed class accordionmiddle {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(320)), null, 0, 0, null, 3m, 0, null, 1m, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private accordionmiddle() {
    }
}

/// <summary>
/// <para>
/// The beater-value type represents pictograms for beaters, mallets, and sticks that do not have different materials represented in the pictogram. The finger and hammer values are in addition to Stone's list.
/// </para>
/// </summary>
public sealed class beatervalue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "bow",
                    "chime hammer",
                    "coin",
                    "finger",
                    "fingernail",
                    "fist",
                    "guiro scraper",
                    "hammer",
                    "hand",
                    "jazz stick",
                    "knitting needle",
                    "metal hammer",
                    "snare stick",
                    "spoon mallet",
                    "triangle beater",
                    "triangle beater plain",
                    "wire brush"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private beatervalue() {
    }
}

/// <summary>
/// <para>
/// The degree-symbol-value type indicates indicates that a symbol should be used in specifying the degree.
/// </para>
/// </summary>
public sealed class degreesymbolvalue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "major",
                    "minor",
                    "augmented",
                    "diminished",
                    "half-diminished"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private degreesymbolvalue() {
    }
}

/// <summary>
/// <para>
/// The degree-type-value type indicates whether the current degree element is an addition, alteration, or subtraction to the kind of the current chord in the harmony element.
/// </para>
/// </summary>
public sealed class degreetypevalue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "add",
                    "alter",
                    "subtract"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private degreetypevalue() {
    }
}

/// <summary>
/// <para>
/// The effect type represents pictograms for sound effect percussion instruments. The cannon value is in addition to Stone's list.
/// </para>
/// </summary>
public sealed class effect {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "anvil",
                    "auto horn",
                    "bird whistle",
                    "cannon",
                    "duck call",
                    "gun shot",
                    "klaxon horn",
                    "lions roar",
                    "police whistle",
                    "siren",
                    "slide whistle",
                    "thunder sheet",
                    "wind machine",
                    "wind whistle"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private effect() {
    }
}

/// <summary>
/// <para>
/// The glass type represents pictograms for glass percussion instruments.
/// </para>
/// </summary>
public sealed class glass {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "wind chimes"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private glass() {
    }
}

/// <summary>
/// <para>
/// The harmony-type type differentiates different types of harmonies when alternate harmonies are possible. Explicit harmonies have all note present in the music; implied have some notes missing but implied; alternate represents alternate analyses.
/// </para>
/// </summary>
public sealed class harmonytype {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "explicit",
                    "implied",
                    "alternate"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private harmonytype() {
    }
}

/// <summary>
/// <para>
/// A kind-value indicates the type of chord. Degree elements can then add, subtract, or alter from these starting points. Values include:
///	
///Triads:
///	major (major third, perfect fifth)
///	minor (minor third, perfect fifth)
///	augmented (major third, augmented fifth)
///	diminished (minor third, diminished fifth)
///Sevenths:
///	dominant (major triad, minor seventh)
///	major-seventh (major triad, major seventh)
///	minor-seventh (minor triad, minor seventh)
///	diminished-seventh (diminished triad, diminished seventh)
///	augmented-seventh (augmented triad, minor seventh)
///	half-diminished (diminished triad, minor seventh)
///	major-minor (minor triad, major seventh)
///Sixths:
///	major-sixth (major triad, added sixth)
///	minor-sixth (minor triad, added sixth)
///Ninths:
///	dominant-ninth (dominant-seventh, major ninth)
///	major-ninth (major-seventh, major ninth)
///	minor-ninth (minor-seventh, major ninth)
///11ths (usually as the basis for alteration):
///	dominant-11th (dominant-ninth, perfect 11th)
///	major-11th (major-ninth, perfect 11th)
///	minor-11th (minor-ninth, perfect 11th)
///13ths (usually as the basis for alteration):
///	dominant-13th (dominant-11th, major 13th)
///	major-13th (major-11th, major 13th)
///	minor-13th (minor-11th, major 13th)
///Suspended:
///	suspended-second (major second, perfect fifth)
///	suspended-fourth (perfect fourth, perfect fifth)
///Functional sixths:
///	Neapolitan
///	Italian
///	French
///	German
///Other:
///	pedal (pedal-point bass)
///	power (perfect fifth)
///	Tristan
///	
///The "other" kind is used when the harmony is entirely composed of add elements. The "none" kind is used to explicitly encode absence of chords or functional harmony.
/// </para>
/// </summary>
public sealed class kindvalue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "major",
                    "minor",
                    "augmented",
                    "diminished",
                    "dominant",
                    "major-seventh",
                    "minor-seventh",
                    "diminished-seventh",
                    "augmented-seventh",
                    "half-diminished",
                    "major-minor",
                    "major-sixth",
                    "minor-sixth",
                    "dominant-ninth",
                    "major-ninth",
                    "minor-ninth",
                    "dominant-11th",
                    "major-11th",
                    "minor-11th",
                    "dominant-13th",
                    "major-13th",
                    "minor-13th",
                    "suspended-second",
                    "suspended-fourth",
                    "Neapolitan",
                    "Italian",
                    "French",
                    "German",
                    "pedal",
                    "power",
                    "Tristan",
                    "other",
                    "none"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private kindvalue() {
    }
}

/// <summary>
/// <para>
/// The line-end type specifies if there is a jog up or down (or both), an arrow, or nothing at the start or end of a bracket.
/// </para>
/// </summary>
public sealed class lineend {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "up",
                    "down",
                    "both",
                    "arrow",
                    "none"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private lineend() {
    }
}

/// <summary>
/// <para>
/// The measure-numbering-value type describes how measure numbers are displayed on this part: no numbers, numbers every measure, or numbers every system.
/// </para>
/// </summary>
public sealed class measurenumberingvalue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "none",
                    "measure",
                    "system"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private measurenumberingvalue() {
    }
}

/// <summary>
/// <para>
/// The membrane type represents pictograms for membrane percussion instruments. The goblet drum value is in addition to Stone's list.
/// </para>
/// </summary>
public sealed class membrane {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "bass drum",
                    "bass drum on side",
                    "bongos",
                    "conga drum",
                    "goblet drum",
                    "military drum",
                    "snare drum",
                    "snare drum snares off",
                    "tambourine",
                    "tenor drum",
                    "timbales",
                    "tomtom"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private membrane() {
    }
}

/// <summary>
/// <para>
/// The metal type represents pictograms for metal percussion instruments. The hi-hat value refers to a pictogram like Stone's high-hat cymbals but without the long vertical line at the bottom.
/// </para>
/// </summary>
public sealed class metal {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "almglocken",
                    "bell",
                    "bell plate",
                    "brake drum",
                    "Chinese cymbal",
                    "cowbell",
                    "crash cymbals",
                    "crotale",
                    "cymbal tongs",
                    "domed gong",
                    "finger cymbals",
                    "flexatone",
                    "gong",
                    "hi-hat",
                    "high-hat cymbals",
                    "handbell",
                    "sistrum",
                    "sizzle cymbal",
                    "sleigh bells",
                    "suspended cymbal",
                    "tam tam",
                    "triangle",
                    "Vietnamese hat"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private metal() {
    }
}

/// <summary>
/// <para>
/// The on-off type is used for notation elements such as string mutes.
/// </para>
/// </summary>
public sealed class onoff {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "on",
                    "off"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private onoff() {
    }
}

/// <summary>
/// <para>
/// The pitched type represents pictograms for pitched percussion instruments. The chimes and tubular chimes values distinguish the single-line and double-line versions of the pictogram. The mallet value is in addition to Stone's list.
/// </para>
/// </summary>
public sealed class pitched {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "chimes",
                    "glockenspiel",
                    "mallet",
                    "marimba",
                    "tubular chimes",
                    "vibraphone",
                    "xylophone"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private pitched() {
    }
}

/// <summary>
/// <para>
/// The principal-voice-symbol type represents the type of symbol used to indicate the start of a principal or secondary voice. The "plain" value represents a plain square bracket. The value of "none" is used for analysis markup when the principal-voice element does not have a corresponding appearance in the score.
/// </para>
/// </summary>
public sealed class principalvoicesymbol {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "Hauptstimme",
                    "Nebenstimme",
                    "plain",
                    "none"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private principalvoicesymbol() {
    }
}

/// <summary>
/// <para>
/// The start-stop-change-continue type is used to distinguish types of pedal directions.
/// </para>
/// </summary>
public sealed class startstopchangecontinue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "start",
                    "stop",
                    "change",
                    "continue"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private startstopchangecontinue() {
    }
}

/// <summary>
/// <para>
/// The tip-direction type represents the direction in which the tip of a stick or beater points, using Unicode arrow terminology.
/// </para>
/// </summary>
public sealed class tipdirection {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "up",
                    "down",
                    "left",
                    "right",
                    "northwest",
                    "northeast",
                    "southeast",
                    "southwest"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private tipdirection() {
    }
}

/// <summary>
/// <para>
/// The stick-location type represents pictograms for the location of sticks, beaters, or mallets on cymbals, gongs, drums, and other instruments.
/// </para>
/// </summary>
public sealed class sticklocation {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "center",
                    "rim",
                    "cymbal bell",
                    "cymbal edge"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private sticklocation() {
    }
}

/// <summary>
/// <para>
/// The stick-material type represents the material being displayed in a stick pictogram.
/// </para>
/// </summary>
public sealed class stickmaterial {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "soft",
                    "medium",
                    "hard",
                    "shaded",
                    "x"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private stickmaterial() {
    }
}

/// <summary>
/// <para>
/// The stick-type type represents the shape of pictograms where the material
///	in the stick, mallet, or beater is represented in the pictogram.
/// </para>
/// </summary>
public sealed class sticktype {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "bass drum",
                    "double bass drum",
                    "timpani",
                    "xylophone",
                    "yarn"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private sticktype() {
    }
}

/// <summary>
/// <para>
/// The up-down-stop-continue type is used for octave-shift elements, indicating the direction of the shift from their true pitched values because of printing difficulty.
/// </para>
/// </summary>
public sealed class updownstopcontinue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "up",
                    "down",
                    "stop",
                    "continue"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private updownstopcontinue() {
    }
}

/// <summary>
/// <para>
/// The wedge type is crescendo for the start of a wedge that is closed at the left side, diminuendo for the start of a wedge that is closed on the right side, and stop for the end of a wedge. The continue type is used for formatting wedges over a system break, or for other situations where a single wedge is divided into multiple segments.
/// </para>
/// </summary>
public sealed class wedgetype {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "crescendo",
                    "diminuendo",
                    "stop",
                    "continue"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private wedgetype() {
    }
}

/// <summary>
/// <para>
/// The wood type represents pictograms for wood percussion instruments. The maraca and maracas values distinguish the one- and two-maraca versions of the pictogram. The vibraslap and castanets values are in addition to Stone's list.
/// </para>
/// </summary>
public sealed class wood {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "board clapper",
                    "cabasa",
                    "castanets",
                    "claves",
                    "guiro",
                    "log drum",
                    "maraca",
                    "maracas",
                    "ratchet",
                    "sandpaper blocks",
                    "slit drum",
                    "temple block",
                    "vibraslap",
                    "wood block"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private wood() {
    }
}

/// <summary>
/// <para>
/// The distance-type defines what type of distance is being defined in a distance element. Values include beam and hyphen. This is left as a string so that other application-specific types can be defined, but it is made a separate type so that it can be redefined more strictly.
/// </para>
/// </summary>
public sealed class distancetype {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), null);
    
    private distancetype() {
    }
}

/// <summary>
/// <para>
/// The line-width-type defines what type of line is being defined in a line-width element. Values include beam, bracket, dashes, enclosure, ending, extend, heavy barline, leger, light barline, octave shift, pedal, slur middle, slur tip, staff, stem, tie middle, tie tip, tuplet bracket, and wedge. This is left as a string so that other application-specific types can be defined, but it is made a separate type so that it can be redefined more strictly.
/// </para>
/// </summary>
public sealed class linewidthtype {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), null);
    
    private linewidthtype() {
    }
}

/// <summary>
/// <para>
/// The margin-type type specifies whether margins apply to even page, odd pages, or both.
/// </para>
/// </summary>
public sealed class margintype {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "odd",
                    "even",
                    "both"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private margintype() {
    }
}

/// <summary>
/// <para>
/// The millimeters type is a number representing millimeters. This is used in the scaling element to provide a default scaling from tenths to physical units.
/// </para>
/// </summary>
public sealed class millimeters {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal), null);
    
    private millimeters() {
    }
}

/// <summary>
/// <para>
/// The note-size-type type indicates the type of note being defined by a note-size element. The grace type is used for notes of cue size that that include a grace element. The cue type is used for all other notes with cue size, whether defined explicitly or implicitly via a cue element. The large type is used for notes of large size.
/// </para>
/// </summary>
public sealed class notesizetype {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "cue",
                    "grace",
                    "large"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private notesizetype() {
    }
}

/// <summary>
/// <para>
/// The accidental-value type represents notated accidentals supported by MusicXML. In the MusicXML 2.0 DTD this was a string with values that could be included. The XSD strengthens the data typing to an enumerated list. The quarter- and three-quarters- accidentals are Tartini-style quarter-tone accidentals. The -down and -up accidentals are quarter-tone accidentals that include arrows pointing down or up. The slash- accidentals are used in Turkish classical music. The numbered sharp and flat accidentals are superscripted versions of the accidental signs, used in Turkish folk music. The sori and koron accidentals are microtonal sharp and flat accidentals used in Iranian and Persian music.
/// </para>
/// </summary>
public sealed class accidentalvalue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "sharp",
                    "natural",
                    "flat",
                    "double-sharp",
                    "sharp-sharp",
                    "flat-flat",
                    "natural-sharp",
                    "natural-flat",
                    "quarter-flat",
                    "quarter-sharp",
                    "three-quarters-flat",
                    "three-quarters-sharp",
                    "sharp-down",
                    "sharp-up",
                    "natural-down",
                    "natural-up",
                    "flat-down",
                    "flat-up",
                    "triple-sharp",
                    "triple-flat",
                    "slash-quarter-sharp",
                    "slash-sharp",
                    "slash-flat",
                    "double-slash-flat",
                    "sharp-1",
                    "sharp-2",
                    "sharp-3",
                    "sharp-5",
                    "flat-1",
                    "flat-2",
                    "flat-3",
                    "flat-4",
                    "sori",
                    "koron"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private accidentalvalue() {
    }
}

/// <summary>
/// <para>
/// The arrow-direction type represents the direction in which an arrow points, using Unicode arrow terminology.
/// </para>
/// </summary>
public sealed class arrowdirection {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "left",
                    "up",
                    "right",
                    "down",
                    "northwest",
                    "northeast",
                    "southeast",
                    "southwest",
                    "left right",
                    "up down",
                    "northwest southeast",
                    "northeast southwest",
                    "other"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private arrowdirection() {
    }
}

/// <summary>
/// <para>
/// The arrow-style type represents the style of an arrow, using Unicode arrow terminology. Filled and hollow arrows indicate polygonal single arrows. Paired arrows are duplicate single arrows in the same direction. Combined arrows apply to double direction arrows like left right, indicating that an arrow in one direction should be combined with an arrow in the other direction.
/// </para>
/// </summary>
public sealed class arrowstyle {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "single",
                    "double",
                    "filled",
                    "hollow",
                    "paired",
                    "combined",
                    "other"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private arrowstyle() {
    }
}

/// <summary>
/// <para>
/// The beam-value type represents the type of beam associated with each of 8 beam levels (up to 1024th notes) available for each note.
/// </para>
/// </summary>
public sealed class beamvalue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "begin",
                    "continue",
                    "end",
                    "forward hook",
                    "backward hook"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private beamvalue() {
    }
}

/// <summary>
/// <para>
/// The breath-mark-value type represents the symbol used for a breath mark.
/// </para>
/// </summary>
public sealed class breathmarkvalue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "",
                    "comma",
                    "tick"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private breathmarkvalue() {
    }
}

/// <summary>
/// <para>
/// The circular-arrow type represents the direction in which a circular arrow points, using Unicode arrow terminology.
/// </para>
/// </summary>
public sealed class circulararrow {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "clockwise",
                    "anticlockwise"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private circulararrow() {
    }
}

/// <summary>
/// <para>
/// The fan type represents the type of beam fanning present on a note, used to represent accelerandos and ritardandos.
/// </para>
/// </summary>
public sealed class fan {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "accel",
                    "rit",
                    "none"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private fan() {
    }
}

/// <summary>
/// <para>
/// The handbell-value type represents the type of handbell technique being notated.
/// </para>
/// </summary>
public sealed class handbellvalue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "damp",
                    "echo",
                    "gyro",
                    "hand martellato",
                    "mallet lift",
                    "mallet table",
                    "martellato",
                    "martellato lift",
                    "muted martellato",
                    "pluck lift",
                    "swing"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private handbellvalue() {
    }
}

/// <summary>
/// <para>
/// The hole-closed-location type indicates which portion of the hole is filled in when the corresponding hole-closed-value is half.
/// </para>
/// </summary>
public sealed class holeclosedlocation {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "right",
                    "bottom",
                    "left",
                    "top"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private holeclosedlocation() {
    }
}

/// <summary>
/// <para>
/// The hole-closed-value type represents whether the hole is closed, open, or half-open.
/// </para>
/// </summary>
public sealed class holeclosedvalue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "yes",
                    "no",
                    "half"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private holeclosedvalue() {
    }
}

/// <summary>
/// <para>
/// The note-type type is used for the MusicXML type element and represents the graphic note type, from 1024th (shortest) to maxima (longest).
/// </para>
/// </summary>
public sealed class notetypevalue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "1024th",
                    "512th",
                    "256th",
                    "128th",
                    "64th",
                    "32nd",
                    "16th",
                    "eighth",
                    "quarter",
                    "half",
                    "whole",
                    "breve",
                    "long",
                    "maxima"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private notetypevalue() {
    }
}

/// <summary>
/// <para>
/// 
///The notehead type indicates shapes other than the open and closed ovals associated with note durations. The values do, re, mi, fa, fa up, so, la, and ti correspond to Aikin's 7-shape system.  The fa up shape is typically used with upstems; the fa shape is typically used with downstems or no stems.
///
///The arrow shapes differ from triangle and inverted triangle by being centered on the stem. Slashed and back slashed notes include both the normal notehead and a slash. The triangle shape has the tip of the triangle pointing up; the inverted triangle shape has the tip of the triangle pointing down. The left triangle shape is a right triangle with the hypotenuse facing up and to the left.
/// </para>
/// </summary>
public sealed class noteheadvalue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "slash",
                    "triangle",
                    "diamond",
                    "square",
                    "cross",
                    "x",
                    "circle-x",
                    "inverted triangle",
                    "arrow down",
                    "arrow up",
                    "slashed",
                    "back slashed",
                    "normal",
                    "cluster",
                    "circle dot",
                    "left triangle",
                    "rectangle",
                    "none",
                    "do",
                    "re",
                    "mi",
                    "fa",
                    "fa up",
                    "so",
                    "la",
                    "ti"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private noteheadvalue() {
    }
}

/// <summary>
/// <para>
/// Octaves are represented by the numbers 0 to 9, where 4 indicates the octave started by middle C.
/// </para>
/// </summary>
public sealed class octave {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(320)), null, 0, 0, null, 9m, 0, null, 0m, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private octave() {
    }
}

/// <summary>
/// <para>
/// The semitones type is a number representing semitones, used for chromatic alteration. A value of -1 corresponds to a flat and a value of 1 to a sharp. Decimal values like 0.5 (quarter tone sharp) are used for microtones.
/// </para>
/// </summary>
public sealed class semitones {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal), null);
    
    private semitones() {
    }
}

/// <summary>
/// <para>
/// The show-tuplet type indicates whether to show a part of a tuplet relating to the tuplet-actual element, both the tuplet-actual and tuplet-normal elements, or neither.
/// </para>
/// </summary>
public sealed class showtuplet {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "actual",
                    "both",
                    "none"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private showtuplet() {
    }
}

/// <summary>
/// <para>
/// The stem type represents the notated stem direction.
/// </para>
/// </summary>
public sealed class stemvalue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "down",
                    "up",
                    "double",
                    "none"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private stemvalue() {
    }
}

/// <summary>
/// <para>
/// The step type represents a step of the diatonic scale, represented using the English letters A through G.
/// </para>
/// </summary>
public sealed class step {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "A",
                    "B",
                    "C",
                    "D",
                    "E",
                    "F",
                    "G"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private step() {
    }
}

/// <summary>
/// <para>
/// Lyric hyphenation is indicated by the syllabic type. The single, begin, end, and middle values represent single-syllable words, word-beginning syllables, word-ending syllables, and mid-word syllables, respectively.
/// </para>
/// </summary>
public sealed class syllabic {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "single",
                    "begin",
                    "end",
                    "middle"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private syllabic() {
    }
}

/// <summary>
/// <para>
/// The number of tremolo marks is represented by a number from 0 to 8: the same as beam-level with 0 added.
/// </para>
/// </summary>
public sealed class tremolomarks {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(320)), null, 0, 0, null, 8m, 0, null, 0m, 0, null, 0, XmlSchemaWhiteSpace.Collapse));
    
    private tremolomarks() {
    }
}

/// <summary>
/// <para>
/// The group-barline-value type indicates if the group should have common barlines.
/// </para>
/// </summary>
public sealed class groupbarlinevalue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "yes",
                    "no",
                    "Mensurstrich"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private groupbarlinevalue() {
    }
}

/// <summary>
/// <para>
/// The group-symbol-value type indicates how the symbol for a group is indicated in the score. The default value is none.
/// </para>
/// </summary>
public sealed class groupsymbolvalue {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                    "none",
                    "brace",
                    "line",
                    "bracket",
                    "square"}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve));
    
    private groupsymbolvalue() {
    }
}

/// <summary>
/// <para>
/// The accidental-text type represents an element with an accidental value and text-formatting attributes.
/// </para>
/// </summary>
public partial class accidentaltext : XTypedElement, IXMetaData {
    
         public static explicit operator accidentaltext(XElement xe) { return XTypedServices.ToXTypedElement<accidentaltext>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The accidental-text type represents an element with an accidental value and text-formatting attributes.
    /// </para>
    /// </summary>
    public accidentaltext() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::accidentalvalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string justify {
        get {
            XAttribute x = this.Attribute(XName.Get("justify", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("justify", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> underline {
        get {
            XAttribute x = this.Attribute(XName.Get("underline", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("underline", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> overline {
        get {
            XAttribute x = this.Attribute(XName.Get("overline", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("overline", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> linethrough {
        get {
            XAttribute x = this.Attribute(XName.Get("line-through", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line-through", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> rotation {
        get {
            XAttribute x = this.Attribute(XName.Get("rotation", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("rotation", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object letterspacing {
        get {
            XAttribute x = this.Attribute(XName.Get("letter-spacing", ""));
            return XTypedServices.ParseUnionValue(x, global::numberornormal.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "letterspacing", this, XName.Get("letter-spacing", ""), global::numberornormal.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object lineheight {
        get {
            XAttribute x = this.Attribute(XName.Get("line-height", ""));
            return XTypedServices.ParseUnionValue(x, global::numberornormal.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "lineheight", this, XName.Get("line-height", ""), global::numberornormal.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object lang {
        get {
            XAttribute x = this.Attribute(XName.Get("lang", "http://www.w3.org/XML/1998/namespace"));
            return XTypedServices.ParseUnionValue(x, global::www.w3.org.XML.Item1998.@namespace.lang.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "lang", this, XName.Get("lang", "http://www.w3.org/XML/1998/namespace"), global::www.w3.org.XML.Item1998.@namespace.lang.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string space {
        get {
            XAttribute x = this.Attribute(XName.Get("space", "http://www.w3.org/XML/1998/namespace"));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NCName).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("space", "http://www.w3.org/XML/1998/namespace"), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NCName).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string dir {
        get {
            XAttribute x = this.Attribute(XName.Get("dir", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dir", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string enclosure {
        get {
            XAttribute x = this.Attribute(XName.Get("enclosure", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("enclosure", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("accidental-text", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<accidentaltext>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Dynamics can be associated either with a note or a general musical direction. To avoid inconsistencies between and amongst the letter abbreviations for dynamics (what is sf vs. sfz, standing alone or with a trailing dynamic that is not always piano), we use the actual letters as the names of these dynamic elements. The other-dynamics element allows other dynamic marks that are not covered here, but many of those should perhaps be included in a more general musical direction element. Dynamics elements may also be combined to create marks not covered by a single element, such as sfmp.
///	
///These letter dynamic symbols are separated from crescendo, decrescendo, and wedge indications. Dynamic representation is inconsistent in scores. Many things are assumed by the composer and left out, such as returns to original dynamics. Systematic representations are quite complex: for example, Humdrum has at least 3 representation formats related to dynamics. The MusicXML format captures what is in the score, but does not try to be optimal for analysis or synthesis of dynamics.
/// </para>
/// <para>
/// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
/// </para>
/// </summary>
public partial class dynamics : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> pField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> ppField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> pppField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> ppppField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> pppppField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> ppppppField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> fField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> ffField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> fffField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> ffffField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> fffffField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> ffffffField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> mpField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> mfField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> sfField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> sfpField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> sfppField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> fpField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> rfField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> rfzField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> sfzField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> sffzField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> fzField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<string> otherdynamicsField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator dynamics(XElement xe) { return XTypedServices.ToXTypedElement<dynamics>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static dynamics() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// Dynamics can be associated either with a note or a general musical direction. To avoid inconsistencies between and amongst the letter abbreviations for dynamics (what is sf vs. sfz, standing alone or with a trailing dynamic that is not always piano), we use the actual letters as the names of these dynamic elements. The other-dynamics element allows other dynamic marks that are not covered here, but many of those should perhaps be included in a more general musical direction element. Dynamics elements may also be combined to create marks not covered by a single element, such as sfmp.
    ///	
    ///These letter dynamic symbols are separated from crescendo, decrescendo, and wedge indications. Dynamic representation is inconsistent in scores. Many things are assumed by the composer and left out, such as returns to original dynamics. Systematic representations are quite complex: for example, Humdrum has at least 3 representation formats related to dynamics. The MusicXML format captures what is in the score, but does not try to be optimal for analysis or synthesis of dynamics.
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public dynamics() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> p {
        get {
            if ((this.pField == null)) {
                this.pField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("p", ""));
            }
            return this.pField;
        }
        set {
            if ((value == null)) {
                this.pField = null;
            }
            else {
                if ((this.pField == null)) {
                    this.pField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("p", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.pField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> pp {
        get {
            if ((this.ppField == null)) {
                this.ppField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("pp", ""));
            }
            return this.ppField;
        }
        set {
            if ((value == null)) {
                this.ppField = null;
            }
            else {
                if ((this.ppField == null)) {
                    this.ppField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("pp", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.ppField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> ppp {
        get {
            if ((this.pppField == null)) {
                this.pppField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("ppp", ""));
            }
            return this.pppField;
        }
        set {
            if ((value == null)) {
                this.pppField = null;
            }
            else {
                if ((this.pppField == null)) {
                    this.pppField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("ppp", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.pppField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> pppp {
        get {
            if ((this.ppppField == null)) {
                this.ppppField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("pppp", ""));
            }
            return this.ppppField;
        }
        set {
            if ((value == null)) {
                this.ppppField = null;
            }
            else {
                if ((this.ppppField == null)) {
                    this.ppppField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("pppp", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.ppppField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> ppppp {
        get {
            if ((this.pppppField == null)) {
                this.pppppField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("ppppp", ""));
            }
            return this.pppppField;
        }
        set {
            if ((value == null)) {
                this.pppppField = null;
            }
            else {
                if ((this.pppppField == null)) {
                    this.pppppField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("ppppp", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.pppppField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> pppppp {
        get {
            if ((this.ppppppField == null)) {
                this.ppppppField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("pppppp", ""));
            }
            return this.ppppppField;
        }
        set {
            if ((value == null)) {
                this.ppppppField = null;
            }
            else {
                if ((this.ppppppField == null)) {
                    this.ppppppField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("pppppp", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.ppppppField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> f {
        get {
            if ((this.fField == null)) {
                this.fField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("f", ""));
            }
            return this.fField;
        }
        set {
            if ((value == null)) {
                this.fField = null;
            }
            else {
                if ((this.fField == null)) {
                    this.fField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("f", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.fField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> ff {
        get {
            if ((this.ffField == null)) {
                this.ffField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("ff", ""));
            }
            return this.ffField;
        }
        set {
            if ((value == null)) {
                this.ffField = null;
            }
            else {
                if ((this.ffField == null)) {
                    this.ffField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("ff", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.ffField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> fff {
        get {
            if ((this.fffField == null)) {
                this.fffField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("fff", ""));
            }
            return this.fffField;
        }
        set {
            if ((value == null)) {
                this.fffField = null;
            }
            else {
                if ((this.fffField == null)) {
                    this.fffField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("fff", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.fffField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> ffff {
        get {
            if ((this.ffffField == null)) {
                this.ffffField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("ffff", ""));
            }
            return this.ffffField;
        }
        set {
            if ((value == null)) {
                this.ffffField = null;
            }
            else {
                if ((this.ffffField == null)) {
                    this.ffffField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("ffff", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.ffffField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> fffff {
        get {
            if ((this.fffffField == null)) {
                this.fffffField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("fffff", ""));
            }
            return this.fffffField;
        }
        set {
            if ((value == null)) {
                this.fffffField = null;
            }
            else {
                if ((this.fffffField == null)) {
                    this.fffffField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("fffff", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.fffffField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> ffffff {
        get {
            if ((this.ffffffField == null)) {
                this.ffffffField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("ffffff", ""));
            }
            return this.ffffffField;
        }
        set {
            if ((value == null)) {
                this.ffffffField = null;
            }
            else {
                if ((this.ffffffField == null)) {
                    this.ffffffField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("ffffff", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.ffffffField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> mp {
        get {
            if ((this.mpField == null)) {
                this.mpField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("mp", ""));
            }
            return this.mpField;
        }
        set {
            if ((value == null)) {
                this.mpField = null;
            }
            else {
                if ((this.mpField == null)) {
                    this.mpField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("mp", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.mpField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> mf {
        get {
            if ((this.mfField == null)) {
                this.mfField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("mf", ""));
            }
            return this.mfField;
        }
        set {
            if ((value == null)) {
                this.mfField = null;
            }
            else {
                if ((this.mfField == null)) {
                    this.mfField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("mf", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.mfField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> sf {
        get {
            if ((this.sfField == null)) {
                this.sfField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("sf", ""));
            }
            return this.sfField;
        }
        set {
            if ((value == null)) {
                this.sfField = null;
            }
            else {
                if ((this.sfField == null)) {
                    this.sfField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("sf", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.sfField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> sfp {
        get {
            if ((this.sfpField == null)) {
                this.sfpField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("sfp", ""));
            }
            return this.sfpField;
        }
        set {
            if ((value == null)) {
                this.sfpField = null;
            }
            else {
                if ((this.sfpField == null)) {
                    this.sfpField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("sfp", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.sfpField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> sfpp {
        get {
            if ((this.sfppField == null)) {
                this.sfppField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("sfpp", ""));
            }
            return this.sfppField;
        }
        set {
            if ((value == null)) {
                this.sfppField = null;
            }
            else {
                if ((this.sfppField == null)) {
                    this.sfppField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("sfpp", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.sfppField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> fp {
        get {
            if ((this.fpField == null)) {
                this.fpField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("fp", ""));
            }
            return this.fpField;
        }
        set {
            if ((value == null)) {
                this.fpField = null;
            }
            else {
                if ((this.fpField == null)) {
                    this.fpField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("fp", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.fpField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> rf {
        get {
            if ((this.rfField == null)) {
                this.rfField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("rf", ""));
            }
            return this.rfField;
        }
        set {
            if ((value == null)) {
                this.rfField = null;
            }
            else {
                if ((this.rfField == null)) {
                    this.rfField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("rf", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.rfField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> rfz {
        get {
            if ((this.rfzField == null)) {
                this.rfzField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("rfz", ""));
            }
            return this.rfzField;
        }
        set {
            if ((value == null)) {
                this.rfzField = null;
            }
            else {
                if ((this.rfzField == null)) {
                    this.rfzField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("rfz", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.rfzField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> sfz {
        get {
            if ((this.sfzField == null)) {
                this.sfzField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("sfz", ""));
            }
            return this.sfzField;
        }
        set {
            if ((value == null)) {
                this.sfzField = null;
            }
            else {
                if ((this.sfzField == null)) {
                    this.sfzField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("sfz", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.sfzField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> sffz {
        get {
            if ((this.sffzField == null)) {
                this.sffzField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("sffz", ""));
            }
            return this.sffzField;
        }
        set {
            if ((value == null)) {
                this.sffzField = null;
            }
            else {
                if ((this.sffzField == null)) {
                    this.sffzField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("sffz", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.sffzField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<empty> fz {
        get {
            if ((this.fzField == null)) {
                this.fzField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("fz", ""));
            }
            return this.fzField;
        }
        set {
            if ((value == null)) {
                this.fzField = null;
            }
            else {
                if ((this.fzField == null)) {
                    this.fzField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("fz", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.fzField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (p | pp | ppp | pppp | ppppp | pppppp | f | ff | fff | ffff | fffff | ffffff | mp | mf | sf | sfp | sfpp | fp | rf | rfz | sfz | sffz | fz | otherdynamics)*
    /// </para>
    /// </summary>
    public IList<string> otherdynamics {
        get {
            if ((this.otherdynamicsField == null)) {
                this.otherdynamicsField = new XSimpleList<string>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, XName.Get("other-dynamics", ""));
            }
            return this.otherdynamicsField;
        }
        set {
            if ((value == null)) {
                this.otherdynamicsField = null;
            }
            else {
                if ((this.otherdynamicsField == null)) {
                    this.otherdynamicsField = XSimpleList<string>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, value, XName.Get("other-dynamics", ""));
                }
                else {
                    XTypedServices.SetList<System.String>(this.otherdynamicsField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> underline {
        get {
            XAttribute x = this.Attribute(XName.Get("underline", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("underline", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> overline {
        get {
            XAttribute x = this.Attribute(XName.Get("overline", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("overline", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> linethrough {
        get {
            XAttribute x = this.Attribute(XName.Get("line-through", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line-through", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string enclosure {
        get {
            XAttribute x = this.Attribute(XName.Get("enclosure", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("enclosure", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("dynamics", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<dynamics>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("p", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("pp", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("ppp", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("pppp", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("ppppp", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("pppppp", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("f", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("ff", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("fff", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("ffff", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("fffff", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("ffffff", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("mp", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("mf", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("sf", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("sfp", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("sfpp", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("fp", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("rf", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("rfz", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("sfz", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("sffz", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("fz", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("other-dynamics", ""), typeof(string));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The empty type represents an empty element with no attributes.
/// </para>
/// </summary>
public partial class empty : XTypedElement, IXMetaData {
    
         public static explicit operator empty(XElement xe) { return XTypedServices.ToXTypedElement<empty>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The empty type represents an empty element with no attributes.
    /// </para>
    /// </summary>
    public empty() {
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("empty", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<empty>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The empty-placement type represents an empty element with print-style and placement attributes.
/// </para>
/// </summary>
public partial class emptyplacement : XTypedElement, IXMetaData {
    
         public static explicit operator emptyplacement(XElement xe) { return XTypedServices.ToXTypedElement<emptyplacement>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The empty-placement type represents an empty element with print-style and placement attributes.
    /// </para>
    /// </summary>
    public emptyplacement() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("empty-placement", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<emptyplacement>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The empty-print-style type represents an empty element with print-style attribute group.
/// </para>
/// </summary>
public partial class emptyprintstyle : XTypedElement, IXMetaData {
    
         public static explicit operator emptyprintstyle(XElement xe) { return XTypedServices.ToXTypedElement<emptyprintstyle>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The empty-print-style type represents an empty element with print-style attribute group.
    /// </para>
    /// </summary>
    public emptyprintstyle() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("empty-print-style", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<emptyprintstyle>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The empty-print-style-align type represents an empty element with print-style-align attribute group.
/// </para>
/// </summary>
public partial class emptyprintstylealign : XTypedElement, IXMetaData {
    
         public static explicit operator emptyprintstylealign(XElement xe) { return XTypedServices.ToXTypedElement<emptyprintstylealign>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The empty-print-style-align type represents an empty element with print-style-align attribute group.
    /// </para>
    /// </summary>
    public emptyprintstylealign() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("empty-print-style-align", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<emptyprintstylealign>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The empty-print-style-align-object type represents an empty element with print-object and print-style-align attribute groups.
/// </para>
/// </summary>
public partial class emptyprintobjectstylealign : XTypedElement, IXMetaData {
    
         public static explicit operator emptyprintobjectstylealign(XElement xe) { return XTypedServices.ToXTypedElement<emptyprintobjectstylealign>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The empty-print-style-align-object type represents an empty element with print-object and print-style-align attribute groups.
    /// </para>
    /// </summary>
    public emptyprintobjectstylealign() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("empty-print-object-style-align", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<emptyprintobjectstylealign>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The empty-trill-sound type represents an empty element with print-style, placement, and trill-sound attributes.
/// </para>
/// </summary>
public partial class emptytrillsound : XTypedElement, IXMetaData {
    
         public static explicit operator emptytrillsound(XElement xe) { return XTypedServices.ToXTypedElement<emptytrillsound>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The empty-trill-sound type represents an empty element with print-style, placement, and trill-sound attributes.
    /// </para>
    /// </summary>
    public emptytrillsound() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string startnote {
        get {
            XAttribute x = this.Attribute(XName.Get("start-note", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("start-note", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string trillstep {
        get {
            XAttribute x = this.Attribute(XName.Get("trill-step", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("trill-step", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string twonoteturn {
        get {
            XAttribute x = this.Attribute(XName.Get("two-note-turn", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("two-note-turn", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string accelerate {
        get {
            XAttribute x = this.Attribute(XName.Get("accelerate", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("accelerate", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> beats {
        get {
            XAttribute x = this.Attribute(XName.Get("beats", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("beats", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> secondbeat {
        get {
            XAttribute x = this.Attribute(XName.Get("second-beat", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("second-beat", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> lastbeat {
        get {
            XAttribute x = this.Attribute(XName.Get("last-beat", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("last-beat", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("empty-trill-sound", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<emptytrillsound>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The horizontal-turn type represents turn elements that are horizontal rather than vertical. These are empty elements with print-style, placement, trill-sound, and slash attributes. If the slash attribute is yes, then a vertical line is used to slash the turn; it is no by default.
/// </para>
/// </summary>
public partial class horizontalturn : XTypedElement, IXMetaData {
    
         public static explicit operator horizontalturn(XElement xe) { return XTypedServices.ToXTypedElement<horizontalturn>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The horizontal-turn type represents turn elements that are horizontal rather than vertical. These are empty elements with print-style, placement, trill-sound, and slash attributes. If the slash attribute is yes, then a vertical line is used to slash the turn; it is no by default.
    /// </para>
    /// </summary>
    public horizontalturn() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string startnote {
        get {
            XAttribute x = this.Attribute(XName.Get("start-note", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("start-note", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string trillstep {
        get {
            XAttribute x = this.Attribute(XName.Get("trill-step", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("trill-step", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string twonoteturn {
        get {
            XAttribute x = this.Attribute(XName.Get("two-note-turn", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("two-note-turn", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string accelerate {
        get {
            XAttribute x = this.Attribute(XName.Get("accelerate", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("accelerate", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> beats {
        get {
            XAttribute x = this.Attribute(XName.Get("beats", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("beats", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> secondbeat {
        get {
            XAttribute x = this.Attribute(XName.Get("second-beat", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("second-beat", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> lastbeat {
        get {
            XAttribute x = this.Attribute(XName.Get("last-beat", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("last-beat", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string slash {
        get {
            XAttribute x = this.Attribute(XName.Get("slash", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("slash", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("horizontal-turn", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<horizontalturn>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The fermata text content represents the shape of the fermata sign. An empty fermata element represents a normal fermata. The fermata type is upright if not specified.
/// </para>
/// </summary>
public partial class fermata : XTypedElement, IXMetaData {
    
         public static explicit operator fermata(XElement xe) { return XTypedServices.ToXTypedElement<fermata>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The fermata text content represents the shape of the fermata sign. An empty fermata element represents a normal fermata. The fermata type is upright if not specified.
    /// </para>
    /// </summary>
    public fermata() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::fermatashape.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("fermata", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<fermata>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Fingering is typically indicated 1,2,3,4,5. Multiple fingerings may be given, typically to substitute fingerings in the middle of a note. The substitution and alternate values are "no" if the attribute is not present. For guitar and other fretted instruments, the fingering element represents the fretting finger; the pluck element represents the plucking finger.
/// </para>
/// </summary>
public partial class fingering : XTypedElement, IXMetaData {
    
         public static explicit operator fingering(XElement xe) { return XTypedServices.ToXTypedElement<fingering>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// Fingering is typically indicated 1,2,3,4,5. Multiple fingerings may be given, typically to substitute fingerings in the middle of a note. The substitution and alternate values are "no" if the attribute is not present. For guitar and other fretted instruments, the fingering element represents the fretting finger; the pluck element represents the plucking finger.
    /// </para>
    /// </summary>
    public fingering() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string substitution {
        get {
            XAttribute x = this.Attribute(XName.Get("substitution", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("substitution", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string alternate {
        get {
            XAttribute x = this.Attribute(XName.Get("alternate", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("alternate", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("fingering", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<fingering>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The formatted-text type represents a text element with text-formatting attributes.
/// </para>
/// </summary>
public partial class formattedtext : XTypedElement, IXMetaData {
    
         public static explicit operator formattedtext(XElement xe) { return XTypedServices.ToXTypedElement<formattedtext>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The formatted-text type represents a text element with text-formatting attributes.
    /// </para>
    /// </summary>
    public formattedtext() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string justify {
        get {
            XAttribute x = this.Attribute(XName.Get("justify", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("justify", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> underline {
        get {
            XAttribute x = this.Attribute(XName.Get("underline", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("underline", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> overline {
        get {
            XAttribute x = this.Attribute(XName.Get("overline", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("overline", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> linethrough {
        get {
            XAttribute x = this.Attribute(XName.Get("line-through", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line-through", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> rotation {
        get {
            XAttribute x = this.Attribute(XName.Get("rotation", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("rotation", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object letterspacing {
        get {
            XAttribute x = this.Attribute(XName.Get("letter-spacing", ""));
            return XTypedServices.ParseUnionValue(x, global::numberornormal.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "letterspacing", this, XName.Get("letter-spacing", ""), global::numberornormal.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object lineheight {
        get {
            XAttribute x = this.Attribute(XName.Get("line-height", ""));
            return XTypedServices.ParseUnionValue(x, global::numberornormal.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "lineheight", this, XName.Get("line-height", ""), global::numberornormal.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object lang {
        get {
            XAttribute x = this.Attribute(XName.Get("lang", "http://www.w3.org/XML/1998/namespace"));
            return XTypedServices.ParseUnionValue(x, global::www.w3.org.XML.Item1998.@namespace.lang.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "lang", this, XName.Get("lang", "http://www.w3.org/XML/1998/namespace"), global::www.w3.org.XML.Item1998.@namespace.lang.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string space {
        get {
            XAttribute x = this.Attribute(XName.Get("space", "http://www.w3.org/XML/1998/namespace"));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NCName).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("space", "http://www.w3.org/XML/1998/namespace"), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NCName).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string dir {
        get {
            XAttribute x = this.Attribute(XName.Get("dir", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dir", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string enclosure {
        get {
            XAttribute x = this.Attribute(XName.Get("enclosure", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("enclosure", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("formatted-text", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<formattedtext>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The fret element is used with tablature notation and chord diagrams. Fret numbers start with 0 for an open string and 1 for the first fret.
/// </para>
/// </summary>
public partial class fret : XTypedElement, IXMetaData {
    
         public static explicit operator fret(XElement xe) { return XTypedServices.ToXTypedElement<fret>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The fret element is used with tablature notation and chord diagrams. Fret numbers start with 0 for an open string and 1 for the first fret.
    /// </para>
    /// </summary>
    public fret() {
    }
    
    public decimal TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("fret", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<fret>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The level type is used to specify editorial information for different MusicXML elements. If the reference attribute for the level element is yes, this indicates editorial information that is for display only and should not affect playback. For instance, a modern edition of older music may set reference="yes" on the attributes containing the music's original clef, key, and time signature. It is no by default.
/// </para>
/// </summary>
public partial class level : XTypedElement, IXMetaData {
    
         public static explicit operator level(XElement xe) { return XTypedServices.ToXTypedElement<level>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The level type is used to specify editorial information for different MusicXML elements. If the reference attribute for the level element is yes, this indicates editorial information that is for display only and should not affect playback. For instance, a modern edition of older music may set reference="yes" on the attributes containing the music's original clef, key, and time signature. It is no by default.
    /// </para>
    /// </summary>
    public level() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string reference {
        get {
            XAttribute x = this.Attribute(XName.Get("reference", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("reference", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string parentheses {
        get {
            XAttribute x = this.Attribute(XName.Get("parentheses", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("parentheses", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string bracket {
        get {
            XAttribute x = this.Attribute(XName.Get("bracket", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bracket", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string size {
        get {
            XAttribute x = this.Attribute(XName.Get("size", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("size", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("level", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<level>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The midi-device type corresponds to the DeviceName meta event in Standard MIDI Files. The optional port attribute is a number from 1 to 16 that can be used with the unofficial MIDI port (or cable) meta event. Unlike the DeviceName meta event, there can be multiple midi-device elements per MusicXML part starting in MusicXML 3.0. The optional id attribute refers to the score-instrument assigned to this device. If missing, the device assignment affects all score-instrument elements in the score-part.
/// </para>
/// </summary>
public partial class mididevice : XTypedElement, IXMetaData {
    
         public static explicit operator mididevice(XElement xe) { return XTypedServices.ToXTypedElement<mididevice>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The midi-device type corresponds to the DeviceName meta event in Standard MIDI Files. The optional port attribute is a number from 1 to 16 that can be used with the unofficial MIDI port (or cable) meta event. Unlike the DeviceName meta event, there can be multiple midi-device elements per MusicXML part starting in MusicXML 3.0. The optional id attribute refers to the score-instrument assigned to this device. If missing, the device assignment affects all score-instrument elements in the score-part.
    /// </para>
    /// </summary>
    public mididevice() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> port {
        get {
            XAttribute x = this.Attribute(XName.Get("port", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("port", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string id {
        get {
            XAttribute x = this.Attribute(XName.Get("id", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("id", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("midi-device", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<mididevice>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The midi-instrument type defines MIDI 1.0 instrument playback. The midi-instrument element can be a part of either the score-instrument element at the start of a part, or the sound element within a part. The id attribute refers to the score-instrument affected by the change.
/// </para>
/// <para>
/// Regular expression: (midichannel?, midiname?, midibank?, midiprogram?, midiunpitched?, volume?, pan?, elevation?)
/// </para>
/// </summary>
public partial class midiinstrument : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator midiinstrument(XElement xe) { return XTypedServices.ToXTypedElement<midiinstrument>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static midiinstrument() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("midi-channel", "")), new NamedContentModelEntity(XName.Get("midi-name", "")), new NamedContentModelEntity(XName.Get("midi-bank", "")), new NamedContentModelEntity(XName.Get("midi-program", "")), new NamedContentModelEntity(XName.Get("midi-unpitched", "")), new NamedContentModelEntity(XName.Get("volume", "")), new NamedContentModelEntity(XName.Get("pan", "")), new NamedContentModelEntity(XName.Get("elevation", "")));
    }
    
    /// <summary>
    /// <para>
    /// The midi-instrument type defines MIDI 1.0 instrument playback. The midi-instrument element can be a part of either the score-instrument element at the start of a part, or the sound element within a part. The id attribute refers to the score-instrument affected by the change.
    /// </para>
    /// <para>
    /// Regular expression: (midichannel?, midiname?, midibank?, midiprogram?, midiunpitched?, volume?, pan?, elevation?)
    /// </para>
    /// </summary>
    public midiinstrument() {
    }
    
    /// <summary>
    /// <para>
    /// The midi-channel element specifies a MIDI 1.0 channel numbers ranging from 1 to 16.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (midichannel?, midiname?, midibank?, midiprogram?, midiunpitched?, volume?, pan?, elevation?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> midichannel {
        get {
            XElement x = this.GetElement(XName.Get("midi-channel", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("midi-channel", ""), value, "midichannel", global::midi16.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The midi-name element corresponds to a ProgramName meta-event within a Standard MIDI File.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (midichannel?, midiname?, midibank?, midiprogram?, midiunpitched?, volume?, pan?, elevation?)
    /// </para>
    /// </summary>
    public string midiname {
        get {
            XElement x = this.GetElement(XName.Get("midi-name", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("midi-name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// The midi-bank element specified a MIDI 1.0 bank number ranging from 1 to 16,384.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (midichannel?, midiname?, midibank?, midiprogram?, midiunpitched?, volume?, pan?, elevation?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> midibank {
        get {
            XElement x = this.GetElement(XName.Get("midi-bank", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("midi-bank", ""), value, "midibank", global::midi16384.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The midi-program element specifies a MIDI 1.0 program number ranging from 1 to 128.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (midichannel?, midiname?, midibank?, midiprogram?, midiunpitched?, volume?, pan?, elevation?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> midiprogram {
        get {
            XElement x = this.GetElement(XName.Get("midi-program", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("midi-program", ""), value, "midiprogram", global::midi128.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// For unpitched instruments, the midi-unpitched element specifies a MIDI 1.0 note number ranging from 1 to 128. It is usually used with MIDI banks for percussion. Note that MIDI 1.0 note numbers are generally specified from 0 to 127 rather than the 1 to 128 numbering used in this element.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (midichannel?, midiname?, midibank?, midiprogram?, midiunpitched?, volume?, pan?, elevation?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> midiunpitched {
        get {
            XElement x = this.GetElement(XName.Get("midi-unpitched", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("midi-unpitched", ""), value, "midiunpitched", global::midi128.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The volume element value is a percentage of the maximum ranging from 0 to 100, with decimal values allowed. This corresponds to a scaling value for the MIDI 1.0 channel volume controller.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (midichannel?, midiname?, midibank?, midiprogram?, midiunpitched?, volume?, pan?, elevation?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> volume {
        get {
            XElement x = this.GetElement(XName.Get("volume", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("volume", ""), value, "volume", global::percent.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The pan and elevation elements allow placing of sound in a 3-D space relative to the listener. Both are expressed in degrees ranging from -180 to 180. For pan, 0 is straight ahead, -90 is hard left, 90 is hard right, and -180 and 180 are directly behind the listener.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (midichannel?, midiname?, midibank?, midiprogram?, midiunpitched?, volume?, pan?, elevation?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> pan {
        get {
            XElement x = this.GetElement(XName.Get("pan", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("pan", ""), value, "pan", global::rotationdegrees.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The elevation and pan elements allow placing of sound in a 3-D space relative to the listener. Both are expressed in degrees ranging from -180 to 180. For elevation, 0 is level with the listener, 90 is directly above, and -90 is directly below.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (midichannel?, midiname?, midibank?, midiprogram?, midiunpitched?, volume?, pan?, elevation?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> elevation {
        get {
            XElement x = this.GetElement(XName.Get("elevation", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("elevation", ""), value, "elevation", global::rotationdegrees.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string id {
        get {
            XAttribute x = this.Attribute(XName.Get("id", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("id", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("midi-instrument", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<midiinstrument>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("midi-channel", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("midi-name", ""), typeof(string));
        localElementDictionary.Add(XName.Get("midi-bank", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("midi-program", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("midi-unpitched", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("volume", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("pan", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("elevation", ""), typeof(decimal));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The name-display type is used for exact formatting of multi-font text in part and group names to the left of the system. The print-object attribute can be used to determine what, if anything, is printed at the start of each system. Enclosure for the display-text element is none by default. Language for the display-text element is Italian ("it") by default.
/// </para>
/// <para>
/// Regular expression: ((displaytext | accidentaltext)*)
/// </para>
/// </summary>
public partial class namedisplay : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<formattedtext> displaytextField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<accidentaltext> accidentaltextField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator namedisplay(XElement xe) { return XTypedServices.ToXTypedElement<namedisplay>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static namedisplay() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The name-display type is used for exact formatting of multi-font text in part and group names to the left of the system. The print-object attribute can be used to determine what, if anything, is printed at the start of each system. Enclosure for the display-text element is none by default. Language for the display-text element is Italian ("it") by default.
    /// </para>
    /// <para>
    /// Regular expression: ((displaytext | accidentaltext)*)
    /// </para>
    /// </summary>
    public namedisplay() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((displaytext | accidentaltext)*)
    /// </para>
    /// </summary>
    public IList<formattedtext> displaytext {
        get {
            if ((this.displaytextField == null)) {
                this.displaytextField = new XTypedList<formattedtext>(this, LinqToXsdTypeManager.Instance, XName.Get("display-text", ""));
            }
            return this.displaytextField;
        }
        set {
            if ((value == null)) {
                this.displaytextField = null;
            }
            else {
                if ((this.displaytextField == null)) {
                    this.displaytextField = XTypedList<formattedtext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("display-text", ""));
                }
                else {
                    XTypedServices.SetList<formattedtext>(this.displaytextField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((displaytext | accidentaltext)*)
    /// </para>
    /// </summary>
    public IList<accidentaltext> accidentaltext {
        get {
            if ((this.accidentaltextField == null)) {
                this.accidentaltextField = new XTypedList<accidentaltext>(this, LinqToXsdTypeManager.Instance, XName.Get("accidental-text", ""));
            }
            return this.accidentaltextField;
        }
        set {
            if ((value == null)) {
                this.accidentaltextField = null;
            }
            else {
                if ((this.accidentaltextField == null)) {
                    this.accidentaltextField = XTypedList<accidentaltext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("accidental-text", ""));
                }
                else {
                    XTypedServices.SetList<accidentaltext>(this.accidentaltextField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("name-display", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<namedisplay>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("display-text", ""), typeof(formattedtext));
        localElementDictionary.Add(XName.Get("accidental-text", ""), typeof(accidentaltext));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The other-play element represents other types of playback. The required type attribute indicates the type of playback to which the element content applies.
/// </para>
/// </summary>
public partial class otherplay : XTypedElement, IXMetaData {
    
         public static explicit operator otherplay(XElement xe) { return XTypedServices.ToXTypedElement<otherplay>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The other-play element represents other types of playback. The required type attribute indicates the type of playback to which the element content applies.
    /// </para>
    /// </summary>
    public otherplay() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("other-play", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<otherplay>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The play type, new in Version 3.0, specifies playback techniques to be used in conjunction with the instrument-sound element. When used as part of a sound element, it applies to all notes going forward in score order. In multi-instrument parts, the affected instrument should be specified using the id attribute. When used as part of a note element, it applies to the current note only.
/// </para>
/// <para>
/// Regular expression: ((ipa | mute | semipitched | otherplay)*)
/// </para>
/// </summary>
public partial class play : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<string> ipaField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<string> muteField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<string> semipitchedField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<otherplay> otherplayField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator play(XElement xe) { return XTypedServices.ToXTypedElement<play>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static play() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The play type, new in Version 3.0, specifies playback techniques to be used in conjunction with the instrument-sound element. When used as part of a sound element, it applies to all notes going forward in score order. In multi-instrument parts, the affected instrument should be specified using the id attribute. When used as part of a note element, it applies to the current note only.
    /// </para>
    /// <para>
    /// Regular expression: ((ipa | mute | semipitched | otherplay)*)
    /// </para>
    /// </summary>
    public play() {
    }
    
    /// <summary>
    /// <para>
    /// The ipa element represents International Phonetic Alphabet (IPA) sounds for vocal music. String content is limited to IPA 2005 symbols represented in Unicode 6.0.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((ipa | mute | semipitched | otherplay)*)
    /// </para>
    /// </summary>
    public IList<string> ipa {
        get {
            if ((this.ipaField == null)) {
                this.ipaField = new XSimpleList<string>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, XName.Get("ipa", ""));
            }
            return this.ipaField;
        }
        set {
            if ((value == null)) {
                this.ipaField = null;
            }
            else {
                if ((this.ipaField == null)) {
                    this.ipaField = XSimpleList<string>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, value, XName.Get("ipa", ""));
                }
                else {
                    XTypedServices.SetList<System.String>(this.ipaField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((ipa | mute | semipitched | otherplay)*)
    /// </para>
    /// </summary>
    public IList<string> mute {
        get {
            if ((this.muteField == null)) {
                this.muteField = new XSimpleList<string>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, XName.Get("mute", ""));
            }
            return this.muteField;
        }
        set {
            if ((value == null)) {
                this.muteField = null;
            }
            else {
                if ((this.muteField == null)) {
                    this.muteField = XSimpleList<string>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, value, XName.Get("mute", ""));
                }
                else {
                    XTypedServices.SetList<System.String>(this.muteField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((ipa | mute | semipitched | otherplay)*)
    /// </para>
    /// </summary>
    public IList<string> semipitched {
        get {
            if ((this.semipitchedField == null)) {
                this.semipitchedField = new XSimpleList<string>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, XName.Get("semi-pitched", ""));
            }
            return this.semipitchedField;
        }
        set {
            if ((value == null)) {
                this.semipitchedField = null;
            }
            else {
                if ((this.semipitchedField == null)) {
                    this.semipitchedField = XSimpleList<string>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, value, XName.Get("semi-pitched", ""));
                }
                else {
                    XTypedServices.SetList<System.String>(this.semipitchedField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((ipa | mute | semipitched | otherplay)*)
    /// </para>
    /// </summary>
    public IList<otherplay> otherplay {
        get {
            if ((this.otherplayField == null)) {
                this.otherplayField = new XTypedList<otherplay>(this, LinqToXsdTypeManager.Instance, XName.Get("other-play", ""));
            }
            return this.otherplayField;
        }
        set {
            if ((value == null)) {
                this.otherplayField = null;
            }
            else {
                if ((this.otherplayField == null)) {
                    this.otherplayField = XTypedList<otherplay>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("other-play", ""));
                }
                else {
                    XTypedServices.SetList<otherplay>(this.otherplayField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string id {
        get {
            XAttribute x = this.Attribute(XName.Get("id", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("id", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("play", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<play>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("ipa", ""), typeof(string));
        localElementDictionary.Add(XName.Get("mute", ""), typeof(string));
        localElementDictionary.Add(XName.Get("semi-pitched", ""), typeof(string));
        localElementDictionary.Add(XName.Get("other-play", ""), typeof(otherplay));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The string type is used with tablature notation, regular notation (where it is often circled), and chord diagrams. String numbers start with 1 for the highest string.
/// </para>
/// </summary>
public partial class @string : XTypedElement, IXMetaData {
    
         public static explicit operator @string(XElement xe) { return XTypedServices.ToXTypedElement<@string>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The string type is used with tablature notation, regular notation (where it is often circled), and chord diagrams. String numbers start with 1 for the highest string.
    /// </para>
    /// </summary>
    public @string() {
    }
    
    public decimal TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::stringnumber.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("string", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<@string>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The typed-text type represents a text element with a type attributes.
/// </para>
/// </summary>
public partial class typedtext : XTypedElement, IXMetaData {
    
         public static explicit operator typedtext(XElement xe) { return XTypedServices.ToXTypedElement<typedtext>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The typed-text type represents a text element with a type attributes.
    /// </para>
    /// </summary>
    public typedtext() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("typed-text", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<typedtext>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Wavy lines are one way to indicate trills. When used with a measure element, they should always have type="continue" set.
/// </para>
/// </summary>
public partial class wavyline : XTypedElement, IXMetaData {
    
         public static explicit operator wavyline(XElement xe) { return XTypedServices.ToXTypedElement<wavyline>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// Wavy lines are one way to indicate trills. When used with a measure element, they should always have type="continue" set.
    /// </para>
    /// </summary>
    public wavyline() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string startnote {
        get {
            XAttribute x = this.Attribute(XName.Get("start-note", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("start-note", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string trillstep {
        get {
            XAttribute x = this.Attribute(XName.Get("trill-step", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("trill-step", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string twonoteturn {
        get {
            XAttribute x = this.Attribute(XName.Get("two-note-turn", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("two-note-turn", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string accelerate {
        get {
            XAttribute x = this.Attribute(XName.Get("accelerate", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("accelerate", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> beats {
        get {
            XAttribute x = this.Attribute(XName.Get("beats", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("beats", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> secondbeat {
        get {
            XAttribute x = this.Attribute(XName.Get("second-beat", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("second-beat", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> lastbeat {
        get {
            XAttribute x = this.Attribute(XName.Get("last-beat", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("last-beat", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("wavy-line", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<wavyline>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The attributes element contains musical information that typically changes on measure boundaries. This includes key and time signatures, clefs, transpositions, and staving. When attributes are changed mid-measure, it affects the music in score order, not in MusicXML document order.
/// </para>
/// <para>
/// Regular expression: ((footnote)?, (level)?, divisions?, key*, time*, staves?, partsymbol?, instruments?, clef*, staffdetails*, transpose*, directive*, measurestyle*)
/// </para>
/// </summary>
public partial class attributes : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<key> keyField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<time> timeField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<clef> clefField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<staffdetails> staffdetailsField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<transpose> transposeField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<directiveLocalType> directiveField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<measurestyle> measurestyleField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator attributes(XElement xe) { return XTypedServices.ToXTypedElement<attributes>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static attributes() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The attributes element contains musical information that typically changes on measure boundaries. This includes key and time signatures, clefs, transpositions, and staving. When attributes are changed mid-measure, it affects the music in score order, not in MusicXML document order.
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, divisions?, key*, time*, staves?, partsymbol?, instruments?, clef*, staffdetails*, transpose*, directive*, measurestyle*)
    /// </para>
    /// </summary>
    public attributes() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, divisions?, key*, time*, staves?, partsymbol?, instruments?, clef*, staffdetails*, transpose*, directive*, measurestyle*)
    /// </para>
    /// </summary>
    public formattedtext footnote {
        get {
            XElement x = this.GetElement(XName.Get("footnote", ""));
            return ((formattedtext)(x));
        }
        set {
            this.SetElement(XName.Get("footnote", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, divisions?, key*, time*, staves?, partsymbol?, instruments?, clef*, staffdetails*, transpose*, directive*, measurestyle*)
    /// </para>
    /// </summary>
    public level level {
        get {
            XElement x = this.GetElement(XName.Get("level", ""));
            return ((level)(x));
        }
        set {
            this.SetElement(XName.Get("level", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Musical notation duration is commonly represented as fractions. The divisions element indicates how many divisions per quarter note are used to indicate a note's duration. For example, if duration = 1 and divisions = 2, this is an eighth note duration. Duration and divisions are used directly for generating sound output, so they must be chosen to take tuplets into account. Using a divisions element lets us use just one number to represent a duration for each note in the score, while retaining the full power of a fractional representation. If maximum compatibility with Standard MIDI 1.0 files is important, do not have the divisions value exceed 16383.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, divisions?, key*, time*, staves?, partsymbol?, instruments?, clef*, staffdetails*, transpose*, directive*, measurestyle*)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> divisions {
        get {
            XElement x = this.GetElement(XName.Get("divisions", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("divisions", ""), value, "divisions", global::positivedivisions.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The key element represents a key signature. Both traditional and non-traditional key signatures are supported. The optional number attribute refers to staff numbers. If absent, the key signature applies to all staves in the part.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, divisions?, key*, time*, staves?, partsymbol?, instruments?, clef*, staffdetails*, transpose*, directive*, measurestyle*)
    /// </para>
    /// </summary>
    public IList<key> key {
        get {
            if ((this.keyField == null)) {
                this.keyField = new XTypedList<key>(this, LinqToXsdTypeManager.Instance, XName.Get("key", ""));
            }
            return this.keyField;
        }
        set {
            if ((value == null)) {
                this.keyField = null;
            }
            else {
                if ((this.keyField == null)) {
                    this.keyField = XTypedList<key>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("key", ""));
                }
                else {
                    XTypedServices.SetList<key>(this.keyField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Time signatures are represented by the beats element for the numerator and the beat-type element for the denominator.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, divisions?, key*, time*, staves?, partsymbol?, instruments?, clef*, staffdetails*, transpose*, directive*, measurestyle*)
    /// </para>
    /// </summary>
    public IList<time> time {
        get {
            if ((this.timeField == null)) {
                this.timeField = new XTypedList<time>(this, LinqToXsdTypeManager.Instance, XName.Get("time", ""));
            }
            return this.timeField;
        }
        set {
            if ((value == null)) {
                this.timeField = null;
            }
            else {
                if ((this.timeField == null)) {
                    this.timeField = XTypedList<time>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("time", ""));
                }
                else {
                    XTypedServices.SetList<time>(this.timeField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The staves element is used if there is more than one staff represented in the given part (e.g., 2 staves for typical piano parts). If absent, a value of 1 is assumed. Staves are ordered from top to bottom in a part in numerical order, with staff 1 above staff 2.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, divisions?, key*, time*, staves?, partsymbol?, instruments?, clef*, staffdetails*, transpose*, directive*, measurestyle*)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> staves {
        get {
            XElement x = this.GetElement(XName.Get("staves", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetElement(XName.Get("staves", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// The part-symbol element indicates how a symbol for a multi-staff part is indicated in the score.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, divisions?, key*, time*, staves?, partsymbol?, instruments?, clef*, staffdetails*, transpose*, directive*, measurestyle*)
    /// </para>
    /// </summary>
    public partsymbol partsymbol {
        get {
            XElement x = this.GetElement(XName.Get("part-symbol", ""));
            return ((partsymbol)(x));
        }
        set {
            this.SetElement(XName.Get("part-symbol", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The instruments element is only used if more than one instrument is represented in the part (e.g., oboe I and II where they play together most of the time). If absent, a value of 1 is assumed.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, divisions?, key*, time*, staves?, partsymbol?, instruments?, clef*, staffdetails*, transpose*, directive*, measurestyle*)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> instruments {
        get {
            XElement x = this.GetElement(XName.Get("instruments", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetElement(XName.Get("instruments", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Clefs are represented by a combination of sign, line, and clef-octave-change elements.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, divisions?, key*, time*, staves?, partsymbol?, instruments?, clef*, staffdetails*, transpose*, directive*, measurestyle*)
    /// </para>
    /// </summary>
    public IList<clef> clef {
        get {
            if ((this.clefField == null)) {
                this.clefField = new XTypedList<clef>(this, LinqToXsdTypeManager.Instance, XName.Get("clef", ""));
            }
            return this.clefField;
        }
        set {
            if ((value == null)) {
                this.clefField = null;
            }
            else {
                if ((this.clefField == null)) {
                    this.clefField = XTypedList<clef>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("clef", ""));
                }
                else {
                    XTypedServices.SetList<clef>(this.clefField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The staff-details element is used to indicate different types of staves.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, divisions?, key*, time*, staves?, partsymbol?, instruments?, clef*, staffdetails*, transpose*, directive*, measurestyle*)
    /// </para>
    /// </summary>
    public IList<staffdetails> staffdetails {
        get {
            if ((this.staffdetailsField == null)) {
                this.staffdetailsField = new XTypedList<staffdetails>(this, LinqToXsdTypeManager.Instance, XName.Get("staff-details", ""));
            }
            return this.staffdetailsField;
        }
        set {
            if ((value == null)) {
                this.staffdetailsField = null;
            }
            else {
                if ((this.staffdetailsField == null)) {
                    this.staffdetailsField = XTypedList<staffdetails>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("staff-details", ""));
                }
                else {
                    XTypedServices.SetList<staffdetails>(this.staffdetailsField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// If the part is being encoded for a transposing instrument in written vs. concert pitch, the transposition must be encoded in the transpose element using the transpose type.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, divisions?, key*, time*, staves?, partsymbol?, instruments?, clef*, staffdetails*, transpose*, directive*, measurestyle*)
    /// </para>
    /// </summary>
    public IList<transpose> transpose {
        get {
            if ((this.transposeField == null)) {
                this.transposeField = new XTypedList<transpose>(this, LinqToXsdTypeManager.Instance, XName.Get("transpose", ""));
            }
            return this.transposeField;
        }
        set {
            if ((value == null)) {
                this.transposeField = null;
            }
            else {
                if ((this.transposeField == null)) {
                    this.transposeField = XTypedList<transpose>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("transpose", ""));
                }
                else {
                    XTypedServices.SetList<transpose>(this.transposeField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Directives are like directions, but can be grouped together with attributes for convenience. This is typically used for tempo markings at the beginning of a piece of music. This element has been deprecated in Version 2.0 in favor of the directive attribute for direction elements. Language names come from ISO 639, with optional country subcodes from ISO 3166.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, divisions?, key*, time*, staves?, partsymbol?, instruments?, clef*, staffdetails*, transpose*, directive*, measurestyle*)
    /// </para>
    /// </summary>
    public IList<attributes.directiveLocalType> directive {
        get {
            if ((this.directiveField == null)) {
                this.directiveField = new XTypedList<directiveLocalType>(this, LinqToXsdTypeManager.Instance, XName.Get("directive", ""));
            }
            return this.directiveField;
        }
        set {
            if ((value == null)) {
                this.directiveField = null;
            }
            else {
                if ((this.directiveField == null)) {
                    this.directiveField = XTypedList<directiveLocalType>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("directive", ""));
                }
                else {
                    XTypedServices.SetList<directiveLocalType>(this.directiveField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// A measure-style indicates a special way to print partial to multiple measures within a part. This includes multiple rests over several measures, repeats of beats, single, or multiple measures, and use of slash notation.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, divisions?, key*, time*, staves?, partsymbol?, instruments?, clef*, staffdetails*, transpose*, directive*, measurestyle*)
    /// </para>
    /// </summary>
    public IList<measurestyle> measurestyle {
        get {
            if ((this.measurestyleField == null)) {
                this.measurestyleField = new XTypedList<measurestyle>(this, LinqToXsdTypeManager.Instance, XName.Get("measure-style", ""));
            }
            return this.measurestyleField;
        }
        set {
            if ((value == null)) {
                this.measurestyleField = null;
            }
            else {
                if ((this.measurestyleField == null)) {
                    this.measurestyleField = XTypedList<measurestyle>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("measure-style", ""));
                }
                else {
                    XTypedServices.SetList<measurestyle>(this.measurestyleField, value);
                }
            }
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("attributes", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<attributes>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("footnote", ""), typeof(formattedtext));
        localElementDictionary.Add(XName.Get("level", ""), typeof(level));
        localElementDictionary.Add(XName.Get("divisions", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("key", ""), typeof(key));
        localElementDictionary.Add(XName.Get("time", ""), typeof(time));
        localElementDictionary.Add(XName.Get("staves", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("part-symbol", ""), typeof(partsymbol));
        localElementDictionary.Add(XName.Get("instruments", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("clef", ""), typeof(clef));
        localElementDictionary.Add(XName.Get("staff-details", ""), typeof(staffdetails));
        localElementDictionary.Add(XName.Get("transpose", ""), typeof(transpose));
        localElementDictionary.Add(XName.Get("directive", ""), typeof(directiveLocalType));
        localElementDictionary.Add(XName.Get("measure-style", ""), typeof(measurestyle));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
    
    public partial class directiveLocalType : XTypedElement, IXMetaData {
        
         public static explicit operator directiveLocalType(XElement xe) { return XTypedServices.ToXTypedElement<directiveLocalType>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
        
        public directiveLocalType() {
        }
        
        public string TypedValue {
            get {
                XElement x = this.Untyped;
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
            set {
                this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public System.Nullable<decimal> defaultx {
            get {
                XAttribute x = this.Attribute(XName.Get("default-x", ""));
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public System.Nullable<decimal> defaulty {
            get {
                XAttribute x = this.Attribute(XName.Get("default-y", ""));
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public System.Nullable<decimal> relativex {
            get {
                XAttribute x = this.Attribute(XName.Get("relative-x", ""));
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public System.Nullable<decimal> relativey {
            get {
                XAttribute x = this.Attribute(XName.Get("relative-y", ""));
                if ((x == null)) {
                    return null;
                }
                return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string fontfamily {
            get {
                XAttribute x = this.Attribute(XName.Get("font-family", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string fontstyle {
            get {
                XAttribute x = this.Attribute(XName.Get("font-style", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public object fontsize {
            get {
                XAttribute x = this.Attribute(XName.Get("font-size", ""));
                return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
            }
            set {
                this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string fontweight {
            get {
                XAttribute x = this.Attribute(XName.Get("font-weight", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public string color {
            get {
                XAttribute x = this.Attribute(XName.Get("color", ""));
                return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
            }
            set {
                this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
            }
        }
        
        /// <summary>
        /// <para>
        /// Occurrence: optional
        /// </para>
        /// </summary>
        public object lang {
            get {
                XAttribute x = this.Attribute(XName.Get("lang", "http://www.w3.org/XML/1998/namespace"));
                return XTypedServices.ParseUnionValue(x, global::www.w3.org.XML.Item1998.@namespace.lang.TypeDefinition);
            }
            set {
                this.SetUnionAttribute(value, "lang", this, XName.Get("lang", "http://www.w3.org/XML/1998/namespace"), global::www.w3.org.XML.Item1998.@namespace.lang.TypeDefinition);
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        XName IXMetaData.SchemaName {
            get {
                return XName.Get("directive", "");
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        SchemaOrigin IXMetaData.TypeOrigin {
            get {
                return SchemaOrigin.Fragment;
            }
        }
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        ILinqToXsdTypeManager IXMetaData.TypeManager {
            get {
                return LinqToXsdTypeManager.Instance;
            }
        }
        
        public override XTypedElement Clone() {
            return XTypedServices.CloneXTypedElement<directiveLocalType>(this);
        }
        
        ContentModelEntity IXMetaData.GetContentModel() {
            return ContentModelEntity.Default;
        }
    }
}

/// <summary>
/// <para>
/// The beat-repeat type is used to indicate that a single beat (but possibly many notes) is repeated. Both the start and stop of the beat being repeated should be specified. The slashes attribute specifies the number of slashes to use in the symbol. The use-dots attribute indicates whether or not to use dots as well (for instance, with mixed rhythm patterns). By default, the value for slashes is 1 and the value for use-dots is no.
///	
///The beat-repeat element specifies a notation style for repetitions. The actual music being repeated needs to be repeated within the MusicXML file. This element specifies the notation that indicates the repeat.
/// </para>
/// <para>
/// Regular expression: (slashtype, slashdot*)?
/// </para>
/// </summary>
public partial class beatrepeat : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> slashdotField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator beatrepeat(XElement xe) { return XTypedServices.ToXTypedElement<beatrepeat>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static beatrepeat() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("slash-type", "")), new NamedContentModelEntity(XName.Get("slash-dot", "")));
    }
    
    /// <summary>
    /// <para>
    /// The beat-repeat type is used to indicate that a single beat (but possibly many notes) is repeated. Both the start and stop of the beat being repeated should be specified. The slashes attribute specifies the number of slashes to use in the symbol. The use-dots attribute indicates whether or not to use dots as well (for instance, with mixed rhythm patterns). By default, the value for slashes is 1 and the value for use-dots is no.
    ///	
    ///The beat-repeat element specifies a notation style for repetitions. The actual music being repeated needs to be repeated within the MusicXML file. This element specifies the notation that indicates the repeat.
    /// </para>
    /// <para>
    /// Regular expression: (slashtype, slashdot*)?
    /// </para>
    /// </summary>
    public beatrepeat() {
    }
    
    /// <summary>
    /// <para>
    /// The slash-type element indicates the graphical note type to use for the display of repetition marks.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (slashtype, slashdot*)?
    /// </para>
    /// </summary>
    public string slashtype {
        get {
            XElement x = this.GetElement(XName.Get("slash-type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("slash-type", ""), value, "slashtype", global::notetypevalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The slash-dot element is used to specify any augmentation dots in the note type used to display repetition marks.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (slashtype, slashdot*)?
    /// </para>
    /// </summary>
    public IList<empty> slashdot {
        get {
            if ((this.slashdotField == null)) {
                this.slashdotField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("slash-dot", ""));
            }
            return this.slashdotField;
        }
        set {
            if ((value == null)) {
                this.slashdotField = null;
            }
            else {
                if ((this.slashdotField == null)) {
                    this.slashdotField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("slash-dot", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.slashdotField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> slashes {
        get {
            XAttribute x = this.Attribute(XName.Get("slashes", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("slashes", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string usedots {
        get {
            XAttribute x = this.Attribute(XName.Get("use-dots", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("use-dots", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("beat-repeat", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<beatrepeat>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("slash-type", ""), typeof(string));
        localElementDictionary.Add(XName.Get("slash-dot", ""), typeof(empty));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// A cancel element indicates that the old key signature should be cancelled before the new one appears. This will always happen when changing to C major or A minor and need not be specified then. The cancel value matches the fifths value of the cancelled key signature (e.g., a cancel of -2 will provide an explicit cancellation for changing from B flat major to F major). The optional location attribute indicates whether the cancellation appears relative to the new key signature.
/// </para>
/// </summary>
public partial class cancel : XTypedElement, IXMetaData {
    
         public static explicit operator cancel(XElement xe) { return XTypedServices.ToXTypedElement<cancel>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// A cancel element indicates that the old key signature should be cancelled before the new one appears. This will always happen when changing to C major or A minor and need not be specified then. The cancel value matches the fifths value of the cancelled key signature (e.g., a cancel of -2 will provide an explicit cancellation for changing from B flat major to F major). The optional location attribute indicates whether the cancellation appears relative to the new key signature.
    /// </para>
    /// </summary>
    public cancel() {
    }
    
    public decimal TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::fifths.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string location {
        get {
            XAttribute x = this.Attribute(XName.Get("location", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("location", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("cancel", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<cancel>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Clefs are represented by a combination of sign, line, and clef-octave-change elements. The optional number attribute refers to staff numbers within the part. A value of 1 is assumed if not present.
///
///Sometimes clefs are added to the staff in non-standard line positions, either to indicate cue passages, or when there are multiple clefs present simultaneously on one staff. In this situation, the additional attribute is set to "yes" and the line value is ignored. The size attribute is used for clefs where the additional attribute is "yes". It is typically used to indicate cue clefs.
///
///Sometimes clefs at the start of a measure need to appear after the barline rather than before, as for cues or for use after a repeated section. The after-barline attribute is set to "yes" in this situation. The attribute is ignored for mid-measure clefs.
///
///Clefs appear at the start of each system unless the print-object attribute has been set to "no" or the additional attribute has been set to "yes".
/// </para>
/// <para>
/// Regular expression: (sign, line?, clefoctavechange?)
/// </para>
/// </summary>
public partial class clef : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator clef(XElement xe) { return XTypedServices.ToXTypedElement<clef>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static clef() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("sign", "")), new NamedContentModelEntity(XName.Get("line", "")), new NamedContentModelEntity(XName.Get("clef-octave-change", "")));
    }
    
    /// <summary>
    /// <para>
    /// Clefs are represented by a combination of sign, line, and clef-octave-change elements. The optional number attribute refers to staff numbers within the part. A value of 1 is assumed if not present.
    ///
    ///Sometimes clefs are added to the staff in non-standard line positions, either to indicate cue passages, or when there are multiple clefs present simultaneously on one staff. In this situation, the additional attribute is set to "yes" and the line value is ignored. The size attribute is used for clefs where the additional attribute is "yes". It is typically used to indicate cue clefs.
    ///
    ///Sometimes clefs at the start of a measure need to appear after the barline rather than before, as for cues or for use after a repeated section. The after-barline attribute is set to "yes" in this situation. The attribute is ignored for mid-measure clefs.
    ///
    ///Clefs appear at the start of each system unless the print-object attribute has been set to "no" or the additional attribute has been set to "yes".
    /// </para>
    /// <para>
    /// Regular expression: (sign, line?, clefoctavechange?)
    /// </para>
    /// </summary>
    public clef() {
    }
    
    /// <summary>
    /// <para>
    /// The sign element represents the clef symbol.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (sign, line?, clefoctavechange?)
    /// </para>
    /// </summary>
    public string sign {
        get {
            XElement x = this.GetElement(XName.Get("sign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("sign", ""), value, "sign", global::clefsign.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Line numbers are counted from the bottom of the staff. Standard values are 2 for the G sign (treble clef), 4 for the F sign (bass clef), 3 for the C sign (alto clef) and 5 for TAB (on a 6-line staff).
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (sign, line?, clefoctavechange?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> line {
        get {
            XElement x = this.GetElement(XName.Get("line", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("line", ""), value, "line", global::staffline.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The clef-octave-change element is used for transposing clefs. A treble clef for tenors would have a value of -1.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (sign, line?, clefoctavechange?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> clefoctavechange {
        get {
            XElement x = this.GetElement(XName.Get("clef-octave-change", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
        set {
            this.SetElement(XName.Get("clef-octave-change", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string additional {
        get {
            XAttribute x = this.Attribute(XName.Get("additional", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("additional", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string size {
        get {
            XAttribute x = this.Attribute(XName.Get("size", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("size", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string afterbarline {
        get {
            XAttribute x = this.Attribute(XName.Get("after-barline", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("after-barline", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("clef", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<clef>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("sign", ""), typeof(string));
        localElementDictionary.Add(XName.Get("line", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("clef-octave-change", ""), typeof(decimal));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The interchangeable type is used to represent the second in a pair of interchangeable dual time signatures, such as the 6/8 in 3/4 (6/8). A separate symbol attribute value is available compared to the time element's symbol attribute, which applies to the first of the dual time signatures. The parentheses attribute value is yes by default.
/// </para>
/// <para>
/// Regular expression: (timerelation?, (beats, beattype)+)
/// </para>
/// </summary>
public partial class interchangeable : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<string> beatsField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<string> beattypeField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator interchangeable(XElement xe) { return XTypedServices.ToXTypedElement<interchangeable>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static interchangeable() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The interchangeable type is used to represent the second in a pair of interchangeable dual time signatures, such as the 6/8 in 3/4 (6/8). A separate symbol attribute value is available compared to the time element's symbol attribute, which applies to the first of the dual time signatures. The parentheses attribute value is yes by default.
    /// </para>
    /// <para>
    /// Regular expression: (timerelation?, (beats, beattype)+)
    /// </para>
    /// </summary>
    public interchangeable() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (timerelation?, (beats, beattype)+)
    /// </para>
    /// </summary>
    public string timerelation {
        get {
            XElement x = this.GetElement(XName.Get("time-relation", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("time-relation", ""), value, "timerelation", global::timerelation.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The beats element indicates the number of beats, as found in the numerator of a time signature.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (timerelation?, (beats, beattype)+)
    /// </para>
    /// </summary>
    public IList<string> beats {
        get {
            if ((this.beatsField == null)) {
                this.beatsField = new XSimpleList<string>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, XName.Get("beats", ""));
            }
            return this.beatsField;
        }
        set {
            if ((value == null)) {
                this.beatsField = null;
            }
            else {
                if ((this.beatsField == null)) {
                    this.beatsField = XSimpleList<string>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, value, XName.Get("beats", ""));
                }
                else {
                    XTypedServices.SetList<System.String>(this.beatsField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The beat-type element indicates the beat unit, as found in the denominator of a time signature.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (timerelation?, (beats, beattype)+)
    /// </para>
    /// </summary>
    public IList<string> beattype {
        get {
            if ((this.beattypeField == null)) {
                this.beattypeField = new XSimpleList<string>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, XName.Get("beat-type", ""));
            }
            return this.beattypeField;
        }
        set {
            if ((value == null)) {
                this.beattypeField = null;
            }
            else {
                if ((this.beattypeField == null)) {
                    this.beattypeField = XSimpleList<string>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, value, XName.Get("beat-type", ""));
                }
                else {
                    XTypedServices.SetList<System.String>(this.beattypeField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string symbol {
        get {
            XAttribute x = this.Attribute(XName.Get("symbol", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("symbol", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string separator {
        get {
            XAttribute x = this.Attribute(XName.Get("separator", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("separator", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("interchangeable", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<interchangeable>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("time-relation", ""), typeof(string));
        localElementDictionary.Add(XName.Get("beats", ""), typeof(string));
        localElementDictionary.Add(XName.Get("beat-type", ""), typeof(string));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The key type represents a key signature. Both traditional and non-traditional key signatures are supported. The optional number attribute refers to staff numbers. If absent, the key signature applies to all staves in the part. Key signatures appear at the start of each system unless the print-object attribute has been set to "no".
/// </para>
/// <para>
/// Regular expression: (((cancel?, fifths, mode?)|(keystep, keyalter, keyaccidental?)*), keyoctave*)
/// </para>
/// </summary>
public partial class key : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<string> keystepField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<decimal> keyalterField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<string> keyaccidentalField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<keyoctave> keyoctaveField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator key(XElement xe) { return XTypedServices.ToXTypedElement<key>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static key() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The key type represents a key signature. Both traditional and non-traditional key signatures are supported. The optional number attribute refers to staff numbers. If absent, the key signature applies to all staves in the part. Key signatures appear at the start of each system unless the print-object attribute has been set to "no".
    /// </para>
    /// <para>
    /// Regular expression: (((cancel?, fifths, mode?)|(keystep, keyalter, keyaccidental?)*), keyoctave*)
    /// </para>
    /// </summary>
    public key() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((cancel?, fifths, mode?)|(keystep, keyalter, keyaccidental?)*), keyoctave*)
    /// </para>
    /// </summary>
    public cancel cancel {
        get {
            XElement x = this.GetElement(XName.Get("cancel", ""));
            return ((cancel)(x));
        }
        set {
            this.SetElement(XName.Get("cancel", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((cancel?, fifths, mode?)|(keystep, keyalter, keyaccidental?)*), keyoctave*)
    /// </para>
    /// </summary>
    public decimal fifths {
        get {
            XElement x = this.GetElement(XName.Get("fifths", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("fifths", ""), value, "fifths", global::fifths.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((cancel?, fifths, mode?)|(keystep, keyalter, keyaccidental?)*), keyoctave*)
    /// </para>
    /// </summary>
    public string mode {
        get {
            XElement x = this.GetElement(XName.Get("mode", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("mode", ""), value, "mode", global::mode.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Non-traditional key signatures can be represented using the Humdrum/Scot concept of a list of altered tones. The key-step element indicates the pitch step to be altered, represented using the same names as in the step element.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((cancel?, fifths, mode?)|(keystep, keyalter, keyaccidental?)*), keyoctave*)
    /// </para>
    /// </summary>
    public IList<string> keystep {
        get {
            if ((this.keystepField == null)) {
                this.keystepField = new XSimpleList<string>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, XName.Get("key-step", ""));
            }
            return this.keystepField;
        }
        set {
            if ((value == null)) {
                this.keystepField = null;
            }
            else {
                if ((this.keystepField == null)) {
                    this.keystepField = XSimpleList<string>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, value, XName.Get("key-step", ""));
                }
                else {
                    XTypedServices.SetList<System.String>(this.keystepField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Non-traditional key signatures can be represented using the Humdrum/Scot concept of a list of altered tones. The key-alter element represents the alteration for a given pitch step, represented with semitones in the same manner as the alter element.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((cancel?, fifths, mode?)|(keystep, keyalter, keyaccidental?)*), keyoctave*)
    /// </para>
    /// </summary>
    public IList<decimal> keyalter {
        get {
            if ((this.keyalterField == null)) {
                this.keyalterField = new XSimpleList<decimal>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype, XName.Get("key-alter", ""));
            }
            return this.keyalterField;
        }
        set {
            if ((value == null)) {
                this.keyalterField = null;
            }
            else {
                if ((this.keyalterField == null)) {
                    this.keyalterField = XSimpleList<decimal>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype, value, XName.Get("key-alter", ""));
                }
                else {
                    XTypedServices.SetList<System.Decimal>(this.keyalterField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Non-traditional key signatures can be represented using the Humdrum/Scot concept of a list of altered tones. The key-accidental element indicates the accidental to be displayed in the key signature, represented in the same manner as the accidental element. It is used for disambiguating microtonal accidentals.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((cancel?, fifths, mode?)|(keystep, keyalter, keyaccidental?)*), keyoctave*)
    /// </para>
    /// </summary>
    public IList<string> keyaccidental {
        get {
            if ((this.keyaccidentalField == null)) {
                this.keyaccidentalField = new XSimpleList<string>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, XName.Get("key-accidental", ""));
            }
            return this.keyaccidentalField;
        }
        set {
            if ((value == null)) {
                this.keyaccidentalField = null;
            }
            else {
                if ((this.keyaccidentalField == null)) {
                    this.keyaccidentalField = XSimpleList<string>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, value, XName.Get("key-accidental", ""));
                }
                else {
                    XTypedServices.SetList<System.String>(this.keyaccidentalField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The optional list of key-octave elements is used to specify in which octave each element of the key signature appears.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (((cancel?, fifths, mode?)|(keystep, keyalter, keyaccidental?)*), keyoctave*)
    /// </para>
    /// </summary>
    public IList<keyoctave> keyoctave {
        get {
            if ((this.keyoctaveField == null)) {
                this.keyoctaveField = new XTypedList<keyoctave>(this, LinqToXsdTypeManager.Instance, XName.Get("key-octave", ""));
            }
            return this.keyoctaveField;
        }
        set {
            if ((value == null)) {
                this.keyoctaveField = null;
            }
            else {
                if ((this.keyoctaveField == null)) {
                    this.keyoctaveField = XTypedList<keyoctave>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("key-octave", ""));
                }
                else {
                    XTypedServices.SetList<keyoctave>(this.keyoctaveField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("key", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<key>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("cancel", ""), typeof(cancel));
        localElementDictionary.Add(XName.Get("fifths", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("mode", ""), typeof(string));
        localElementDictionary.Add(XName.Get("key-step", ""), typeof(string));
        localElementDictionary.Add(XName.Get("key-alter", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("key-accidental", ""), typeof(string));
        localElementDictionary.Add(XName.Get("key-octave", ""), typeof(keyoctave));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The key-octave element specifies in which octave an element of a key signature appears. The content specifies the octave value using the same values as the display-octave element. The number attribute is a positive integer that refers to the key signature element in left-to-right order. If the cancel attribute is set to yes, then this number refers to an element specified by the cancel element. It is no by default.
/// </para>
/// </summary>
public partial class keyoctave : XTypedElement, IXMetaData {
    
         public static explicit operator keyoctave(XElement xe) { return XTypedServices.ToXTypedElement<keyoctave>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The key-octave element specifies in which octave an element of a key signature appears. The content specifies the octave value using the same values as the display-octave element. The number attribute is a positive integer that refers to the key signature element in left-to-right order. If the cancel attribute is set to yes, then this number refers to an element specified by the cancel element. It is no by default.
    /// </para>
    /// </summary>
    public keyoctave() {
    }
    
    public decimal TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::octave.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public decimal number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string cancel {
        get {
            XAttribute x = this.Attribute(XName.Get("cancel", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("cancel", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("key-octave", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<keyoctave>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The measure-repeat type is used for both single and multiple measure repeats. The text of the element indicates the number of measures to be repeated in a single pattern. The slashes attribute specifies the number of slashes to use in the repeat sign. It is 1 if not specified. Both the start and the stop of the measure-repeat must be specified. The text of the element is ignored when the type is stop.
///	
///The measure-repeat element specifies a notation style for repetitions. The actual music being repeated needs to be repeated within the MusicXML file. This element specifies the notation that indicates the repeat.
/// </para>
/// </summary>
public partial class measurerepeat : XTypedElement, IXMetaData {
    
         public static explicit operator measurerepeat(XElement xe) { return XTypedServices.ToXTypedElement<measurerepeat>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The measure-repeat type is used for both single and multiple measure repeats. The text of the element indicates the number of measures to be repeated in a single pattern. The slashes attribute specifies the number of slashes to use in the repeat sign. It is 1 if not specified. Both the start and the stop of the measure-repeat must be specified. The text of the element is ignored when the type is stop.
    ///	
    ///The measure-repeat element specifies a notation style for repetitions. The actual music being repeated needs to be repeated within the MusicXML file. This element specifies the notation that indicates the repeat.
    /// </para>
    /// </summary>
    public measurerepeat() {
    }
    
    public object TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseUnionValue(x, global::positiveintegerorempty.TypeDefinition);
        }
        set {
            this.SetUnionValue(value, "TypedValue", this, global::positiveintegerorempty.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> slashes {
        get {
            XAttribute x = this.Attribute(XName.Get("slashes", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("slashes", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("measure-repeat", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<measurerepeat>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// A measure-style indicates a special way to print partial to multiple measures within a part. This includes multiple rests over several measures, repeats of beats, single, or multiple measures, and use of slash notation.
///
///The multiple-rest and measure-repeat symbols indicate the number of measures covered in the element content. The beat-repeat and slash elements can cover partial measures. All but the multiple-rest element use a type attribute to indicate starting and stopping the use of the style. The optional number attribute specifies the staff number from top to bottom on the system, as with clef.
/// </para>
/// <para>
/// Regular expression: (multiplerest | measurerepeat | beatrepeat | slash)
/// </para>
/// </summary>
public partial class measurestyle : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator measurestyle(XElement xe) { return XTypedServices.ToXTypedElement<measurestyle>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static measurestyle() {
        BuildElementDictionary();
        contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(XName.Get("multiple-rest", "")), new NamedContentModelEntity(XName.Get("measure-repeat", "")), new NamedContentModelEntity(XName.Get("beat-repeat", "")), new NamedContentModelEntity(XName.Get("slash", "")));
    }
    
    /// <summary>
    /// <para>
    /// A measure-style indicates a special way to print partial to multiple measures within a part. This includes multiple rests over several measures, repeats of beats, single, or multiple measures, and use of slash notation.
    ///
    ///The multiple-rest and measure-repeat symbols indicate the number of measures covered in the element content. The beat-repeat and slash elements can cover partial measures. All but the multiple-rest element use a type attribute to indicate starting and stopping the use of the style. The optional number attribute specifies the staff number from top to bottom on the system, as with clef.
    /// </para>
    /// <para>
    /// Regular expression: (multiplerest | measurerepeat | beatrepeat | slash)
    /// </para>
    /// </summary>
    public measurestyle() {
    }
    
    public measurestyle(multiplerest multiplerest) {
        this.multiplerest = multiplerest;
    }
    
    public measurestyle(measurerepeat measurerepeat) {
        this.measurerepeat = measurerepeat;
    }
    
    public measurestyle(beatrepeat beatrepeat) {
        this.beatrepeat = beatrepeat;
    }
    
    public measurestyle(slash slash) {
        this.slash = slash;
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (multiplerest | measurerepeat | beatrepeat | slash)
    /// </para>
    /// </summary>
    public multiplerest multiplerest {
        get {
            XElement x = this.GetElement(XName.Get("multiple-rest", ""));
            return ((multiplerest)(x));
        }
        set {
            this.SetElement(XName.Get("multiple-rest", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (multiplerest | measurerepeat | beatrepeat | slash)
    /// </para>
    /// </summary>
    public measurerepeat measurerepeat {
        get {
            XElement x = this.GetElement(XName.Get("measure-repeat", ""));
            return ((measurerepeat)(x));
        }
        set {
            this.SetElement(XName.Get("measure-repeat", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (multiplerest | measurerepeat | beatrepeat | slash)
    /// </para>
    /// </summary>
    public beatrepeat beatrepeat {
        get {
            XElement x = this.GetElement(XName.Get("beat-repeat", ""));
            return ((beatrepeat)(x));
        }
        set {
            this.SetElement(XName.Get("beat-repeat", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (multiplerest | measurerepeat | beatrepeat | slash)
    /// </para>
    /// </summary>
    public slash slash {
        get {
            XElement x = this.GetElement(XName.Get("slash", ""));
            return ((slash)(x));
        }
        set {
            this.SetElement(XName.Get("slash", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("measure-style", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<measurestyle>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("multiple-rest", ""), typeof(multiplerest));
        localElementDictionary.Add(XName.Get("measure-repeat", ""), typeof(measurerepeat));
        localElementDictionary.Add(XName.Get("beat-repeat", ""), typeof(beatrepeat));
        localElementDictionary.Add(XName.Get("slash", ""), typeof(slash));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The text of the multiple-rest type indicates the number of measures in the multiple rest. Multiple rests may use the 1-bar / 2-bar / 4-bar rest symbols, or a single shape. The use-symbols attribute indicates which to use; it is no if not specified. The element text is ignored when the type is stop.
/// </para>
/// </summary>
public partial class multiplerest : XTypedElement, IXMetaData {
    
         public static explicit operator multiplerest(XElement xe) { return XTypedServices.ToXTypedElement<multiplerest>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The text of the multiple-rest type indicates the number of measures in the multiple rest. Multiple rests may use the 1-bar / 2-bar / 4-bar rest symbols, or a single shape. The use-symbols attribute indicates which to use; it is no if not specified. The element text is ignored when the type is stop.
    /// </para>
    /// </summary>
    public multiplerest() {
    }
    
    public object TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseUnionValue(x, global::positiveintegerorempty.TypeDefinition);
        }
        set {
            this.SetUnionValue(value, "TypedValue", this, global::positiveintegerorempty.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string usesymbols {
        get {
            XAttribute x = this.Attribute(XName.Get("use-symbols", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("use-symbols", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("multiple-rest", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<multiplerest>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The part-symbol type indicates how a symbol for a multi-staff part is indicated in the score; brace is the default value. The top-staff and bottom-staff elements are used when the brace does not extend across the entire part. For example, in a 3-staff organ part, the top-staff will typically be 1 for the right hand, while the bottom-staff will typically be 2 for the left hand. Staff 3 for the pedals is usually outside the brace.
/// </para>
/// </summary>
public partial class partsymbol : XTypedElement, IXMetaData {
    
         public static explicit operator partsymbol(XElement xe) { return XTypedServices.ToXTypedElement<partsymbol>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The part-symbol type indicates how a symbol for a multi-staff part is indicated in the score; brace is the default value. The top-staff and bottom-staff elements are used when the brace does not extend across the entire part. For example, in a 3-staff organ part, the top-staff will typically be 1 for the right hand, while the bottom-staff will typically be 2 for the left hand. Staff 3 for the pedals is usually outside the brace.
    /// </para>
    /// </summary>
    public partsymbol() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::groupsymbolvalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> topstaff {
        get {
            XAttribute x = this.Attribute(XName.Get("top-staff", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("top-staff", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> bottomstaff {
        get {
            XAttribute x = this.Attribute(XName.Get("bottom-staff", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bottom-staff", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("part-symbol", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<partsymbol>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The slash type is used to indicate that slash notation is to be used. If the slash is on every beat, use-stems is no (the default). To indicate rhythms but not pitches, use-stems is set to yes. The type attribute indicates whether this is the start or stop of a slash notation style. The use-dots attribute works as for the beat-repeat element, and only has effect if use-stems is no.
/// </para>
/// <para>
/// Regular expression: (slashtype, slashdot*)?
/// </para>
/// </summary>
public partial class slash : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> slashdotField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator slash(XElement xe) { return XTypedServices.ToXTypedElement<slash>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static slash() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("slash-type", "")), new NamedContentModelEntity(XName.Get("slash-dot", "")));
    }
    
    /// <summary>
    /// <para>
    /// The slash type is used to indicate that slash notation is to be used. If the slash is on every beat, use-stems is no (the default). To indicate rhythms but not pitches, use-stems is set to yes. The type attribute indicates whether this is the start or stop of a slash notation style. The use-dots attribute works as for the beat-repeat element, and only has effect if use-stems is no.
    /// </para>
    /// <para>
    /// Regular expression: (slashtype, slashdot*)?
    /// </para>
    /// </summary>
    public slash() {
    }
    
    /// <summary>
    /// <para>
    /// The slash-type element indicates the graphical note type to use for the display of repetition marks.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (slashtype, slashdot*)?
    /// </para>
    /// </summary>
    public string slashtype {
        get {
            XElement x = this.GetElement(XName.Get("slash-type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("slash-type", ""), value, "slashtype", global::notetypevalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The slash-dot element is used to specify any augmentation dots in the note type used to display repetition marks.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (slashtype, slashdot*)?
    /// </para>
    /// </summary>
    public IList<empty> slashdot {
        get {
            if ((this.slashdotField == null)) {
                this.slashdotField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("slash-dot", ""));
            }
            return this.slashdotField;
        }
        set {
            if ((value == null)) {
                this.slashdotField = null;
            }
            else {
                if ((this.slashdotField == null)) {
                    this.slashdotField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("slash-dot", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.slashdotField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string usedots {
        get {
            XAttribute x = this.Attribute(XName.Get("use-dots", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("use-dots", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string usestems {
        get {
            XAttribute x = this.Attribute(XName.Get("use-stems", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("use-stems", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("slash", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<slash>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("slash-type", ""), typeof(string));
        localElementDictionary.Add(XName.Get("slash-dot", ""), typeof(empty));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The staff-details element is used to indicate different types of staves. The optional number attribute specifies the staff number from top to bottom on the system, as with clef. The print-object attribute is used to indicate when a staff is not printed in a part, usually in large scores where empty parts are omitted. It is yes by default. If print-spacing is yes while print-object is no, the score is printed in cutaway format where vertical space is left for the empty part.
/// </para>
/// <para>
/// Regular expression: (stafftype?, stafflines?, stafftuning*, capo?, staffsize?)
/// </para>
/// </summary>
public partial class staffdetails : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<stafftuning> stafftuningField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator staffdetails(XElement xe) { return XTypedServices.ToXTypedElement<staffdetails>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static staffdetails() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("staff-type", "")), new NamedContentModelEntity(XName.Get("staff-lines", "")), new NamedContentModelEntity(XName.Get("staff-tuning", "")), new NamedContentModelEntity(XName.Get("capo", "")), new NamedContentModelEntity(XName.Get("staff-size", "")));
    }
    
    /// <summary>
    /// <para>
    /// The staff-details element is used to indicate different types of staves. The optional number attribute specifies the staff number from top to bottom on the system, as with clef. The print-object attribute is used to indicate when a staff is not printed in a part, usually in large scores where empty parts are omitted. It is yes by default. If print-spacing is yes while print-object is no, the score is printed in cutaway format where vertical space is left for the empty part.
    /// </para>
    /// <para>
    /// Regular expression: (stafftype?, stafflines?, stafftuning*, capo?, staffsize?)
    /// </para>
    /// </summary>
    public staffdetails() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (stafftype?, stafflines?, stafftuning*, capo?, staffsize?)
    /// </para>
    /// </summary>
    public string stafftype {
        get {
            XElement x = this.GetElement(XName.Get("staff-type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("staff-type", ""), value, "stafftype", global::stafftype.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The staff-lines element specifies the number of lines for a non 5-line staff.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (stafftype?, stafflines?, stafftuning*, capo?, staffsize?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> stafflines {
        get {
            XElement x = this.GetElement(XName.Get("staff-lines", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetElement(XName.Get("staff-lines", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (stafftype?, stafflines?, stafftuning*, capo?, staffsize?)
    /// </para>
    /// </summary>
    public IList<stafftuning> stafftuning {
        get {
            if ((this.stafftuningField == null)) {
                this.stafftuningField = new XTypedList<stafftuning>(this, LinqToXsdTypeManager.Instance, XName.Get("staff-tuning", ""));
            }
            return this.stafftuningField;
        }
        set {
            if ((value == null)) {
                this.stafftuningField = null;
            }
            else {
                if ((this.stafftuningField == null)) {
                    this.stafftuningField = XTypedList<stafftuning>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("staff-tuning", ""));
                }
                else {
                    XTypedServices.SetList<stafftuning>(this.stafftuningField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The capo element indicates at which fret a capo should be placed on a fretted instrument. This changes the open tuning of the strings specified by staff-tuning by the specified number of half-steps.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (stafftype?, stafflines?, stafftuning*, capo?, staffsize?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> capo {
        get {
            XElement x = this.GetElement(XName.Get("capo", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetElement(XName.Get("capo", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// The staff-size element indicates how large a staff space is on this staff, expressed as a percentage of the work's default scaling. Values less than 100 make the staff space smaller while values over 100 make the staff space larger. A staff-type of cue, ossia, or editorial implies a staff-size of less than 100, but the exact value is implementation-dependent unless specified here. Staff size affects staff height only, not the relationship of the staff to the left and right margins.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (stafftype?, stafflines?, stafftuning*, capo?, staffsize?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> staffsize {
        get {
            XElement x = this.GetElement(XName.Get("staff-size", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("staff-size", ""), value, "staffsize", global::nonnegativedecimal.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string showfrets {
        get {
            XAttribute x = this.Attribute(XName.Get("show-frets", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("show-frets", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printspacing {
        get {
            XAttribute x = this.Attribute(XName.Get("print-spacing", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-spacing", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("staff-details", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<staffdetails>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("staff-type", ""), typeof(string));
        localElementDictionary.Add(XName.Get("staff-lines", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("staff-tuning", ""), typeof(stafftuning));
        localElementDictionary.Add(XName.Get("capo", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("staff-size", ""), typeof(decimal));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The staff-tuning type specifies the open, non-capo tuning of the lines on a tablature staff.
/// </para>
/// <para>
/// Regular expression: (tuningstep, tuningalter?, tuningoctave)
/// </para>
/// </summary>
public partial class stafftuning : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator stafftuning(XElement xe) { return XTypedServices.ToXTypedElement<stafftuning>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static stafftuning() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("tuning-step", "")), new NamedContentModelEntity(XName.Get("tuning-alter", "")), new NamedContentModelEntity(XName.Get("tuning-octave", "")));
    }
    
    /// <summary>
    /// <para>
    /// The staff-tuning type specifies the open, non-capo tuning of the lines on a tablature staff.
    /// </para>
    /// <para>
    /// Regular expression: (tuningstep, tuningalter?, tuningoctave)
    /// </para>
    /// </summary>
    public stafftuning() {
    }
    
    /// <summary>
    /// <para>
    /// The tuning-step element is represented like the step element, with a different name to reflect is different function.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (tuningstep, tuningalter?, tuningoctave)
    /// </para>
    /// </summary>
    public string tuningstep {
        get {
            XElement x = this.GetElement(XName.Get("tuning-step", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("tuning-step", ""), value, "tuningstep", global::step.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The tuning-alter element is represented like the alter element, with a different name to reflect is different function.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (tuningstep, tuningalter?, tuningoctave)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> tuningalter {
        get {
            XElement x = this.GetElement(XName.Get("tuning-alter", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("tuning-alter", ""), value, "tuningalter", global::semitones.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The tuning-octave element is represented like the octave element, with a different name to reflect is different function.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (tuningstep, tuningalter?, tuningoctave)
    /// </para>
    /// </summary>
    public decimal tuningoctave {
        get {
            XElement x = this.GetElement(XName.Get("tuning-octave", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("tuning-octave", ""), value, "tuningoctave", global::octave.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> line {
        get {
            XAttribute x = this.Attribute(XName.Get("line", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("staff-tuning", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<stafftuning>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("tuning-step", ""), typeof(string));
        localElementDictionary.Add(XName.Get("tuning-alter", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("tuning-octave", ""), typeof(decimal));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// Time signatures are represented by the beats element for the numerator and the beat-type element for the denominator. The symbol attribute is used indicate common and cut time symbols as well as a single number display. Multiple pairs of beat and beat-type elements are used for composite time signatures with multiple denominators, such as 2/4 + 3/8. A composite such as 3+2/8 requires only one beat/beat-type pair.
///
///The print-object attribute allows a time signature to be specified but not printed, as is the case for excerpts from the middle of a score. The value is "yes" if not present. The optional number attribute refers to staff numbers within the part. If absent, the time signature applies to all staves in the part.
/// </para>
/// <para>
/// Regular expression: (((beats, beattype)+, interchangeable?)|senzamisura)
/// </para>
/// </summary>
public partial class time : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<string> beatsField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<string> beattypeField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator time(XElement xe) { return XTypedServices.ToXTypedElement<time>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static time() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// Time signatures are represented by the beats element for the numerator and the beat-type element for the denominator. The symbol attribute is used indicate common and cut time symbols as well as a single number display. Multiple pairs of beat and beat-type elements are used for composite time signatures with multiple denominators, such as 2/4 + 3/8. A composite such as 3+2/8 requires only one beat/beat-type pair.
    ///
    ///The print-object attribute allows a time signature to be specified but not printed, as is the case for excerpts from the middle of a score. The value is "yes" if not present. The optional number attribute refers to staff numbers within the part. If absent, the time signature applies to all staves in the part.
    /// </para>
    /// <para>
    /// Regular expression: (((beats, beattype)+, interchangeable?)|senzamisura)
    /// </para>
    /// </summary>
    public time() {
    }
    
    /// <summary>
    /// <para>
    /// The beats element indicates the number of beats, as found in the numerator of a time signature.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((beats, beattype)+, interchangeable?)|senzamisura)
    /// </para>
    /// </summary>
    public IList<string> beats {
        get {
            if ((this.beatsField == null)) {
                this.beatsField = new XSimpleList<string>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, XName.Get("beats", ""));
            }
            return this.beatsField;
        }
        set {
            if ((value == null)) {
                this.beatsField = null;
            }
            else {
                if ((this.beatsField == null)) {
                    this.beatsField = XSimpleList<string>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, value, XName.Get("beats", ""));
                }
                else {
                    XTypedServices.SetList<System.String>(this.beatsField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The beat-type element indicates the beat unit, as found in the denominator of a time signature.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((beats, beattype)+, interchangeable?)|senzamisura)
    /// </para>
    /// </summary>
    public IList<string> beattype {
        get {
            if ((this.beattypeField == null)) {
                this.beattypeField = new XSimpleList<string>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, XName.Get("beat-type", ""));
            }
            return this.beattypeField;
        }
        set {
            if ((value == null)) {
                this.beattypeField = null;
            }
            else {
                if ((this.beattypeField == null)) {
                    this.beattypeField = XSimpleList<string>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, value, XName.Get("beat-type", ""));
                }
                else {
                    XTypedServices.SetList<System.String>(this.beattypeField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((beats, beattype)+, interchangeable?)|senzamisura)
    /// </para>
    /// </summary>
    public interchangeable interchangeable {
        get {
            XElement x = this.GetElement(XName.Get("interchangeable", ""));
            return ((interchangeable)(x));
        }
        set {
            this.SetElement(XName.Get("interchangeable", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// A senza-misura element explicitly indicates that no time signature is present. The optional element content indicates the symbol to be used, if any, such as an X. The time element's symbol attribute is not used when a senza-misura element is present.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (((beats, beattype)+, interchangeable?)|senzamisura)
    /// </para>
    /// </summary>
    public string senzamisura {
        get {
            XElement x = this.GetElement(XName.Get("senza-misura", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("senza-misura", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string symbol {
        get {
            XAttribute x = this.Attribute(XName.Get("symbol", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("symbol", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string separator {
        get {
            XAttribute x = this.Attribute(XName.Get("separator", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("separator", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("time", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<time>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("beats", ""), typeof(string));
        localElementDictionary.Add(XName.Get("beat-type", ""), typeof(string));
        localElementDictionary.Add(XName.Get("interchangeable", ""), typeof(interchangeable));
        localElementDictionary.Add(XName.Get("senza-misura", ""), typeof(string));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The transpose type represents what must be added to a written pitch to get a correct sounding pitch. The optional number attribute refers to staff numbers, from top to bottom on the system. If absent, the transposition applies to all staves in the part. Per-staff transposition is most often used in parts that represent multiple instruments.
/// </para>
/// <para>
/// Regular expression: (diatonic?, chromatic, octavechange?, @double?)
/// </para>
/// </summary>
public partial class transpose : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator transpose(XElement xe) { return XTypedServices.ToXTypedElement<transpose>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static transpose() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("diatonic", "")), new NamedContentModelEntity(XName.Get("chromatic", "")), new NamedContentModelEntity(XName.Get("octave-change", "")), new NamedContentModelEntity(XName.Get("double", "")));
    }
    
    /// <summary>
    /// <para>
    /// The transpose type represents what must be added to a written pitch to get a correct sounding pitch. The optional number attribute refers to staff numbers, from top to bottom on the system. If absent, the transposition applies to all staves in the part. Per-staff transposition is most often used in parts that represent multiple instruments.
    /// </para>
    /// <para>
    /// Regular expression: (diatonic?, chromatic, octavechange?, @double?)
    /// </para>
    /// </summary>
    public transpose() {
    }
    
    /// <summary>
    /// <para>
    /// The diatonic element specifies the number of pitch steps needed to go from written to sounding pitch. This allows for correct spelling of enharmonic transpositions.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (diatonic?, chromatic, octavechange?, @double?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> diatonic {
        get {
            XElement x = this.GetElement(XName.Get("diatonic", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
        set {
            this.SetElement(XName.Get("diatonic", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// The chromatic element represents the number of semitones needed to get from written to sounding pitch. This value does not include octave-change values; the values for both elements need to be added to the written pitch to get the correct sounding pitch.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (diatonic?, chromatic, octavechange?, @double?)
    /// </para>
    /// </summary>
    public decimal chromatic {
        get {
            XElement x = this.GetElement(XName.Get("chromatic", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("chromatic", ""), value, "chromatic", global::semitones.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The octave-change element indicates how many octaves to add to get from written pitch to sounding pitch.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (diatonic?, chromatic, octavechange?, @double?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> octavechange {
        get {
            XElement x = this.GetElement(XName.Get("octave-change", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
        set {
            this.SetElement(XName.Get("octave-change", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// If the double element is present, it indicates that the music is doubled one octave down from what is currently written (as is the case for mixed cello / bass parts in orchestral literature).
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (diatonic?, chromatic, octavechange?, @double?)
    /// </para>
    /// </summary>
    public empty @double {
        get {
            XElement x = this.GetElement(XName.Get("double", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("double", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("transpose", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<transpose>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("diatonic", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("chromatic", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("octave-change", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("double", ""), typeof(empty));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The bar-style-color type contains barline style and color information.
/// </para>
/// </summary>
public partial class barstylecolor : XTypedElement, IXMetaData {
    
         public static explicit operator barstylecolor(XElement xe) { return XTypedServices.ToXTypedElement<barstylecolor>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The bar-style-color type contains barline style and color information.
    /// </para>
    /// </summary>
    public barstylecolor() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::barstyle.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("bar-style-color", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<barstylecolor>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// If a barline is other than a normal single barline, it should be represented by a barline type that describes it. This includes information about repeats and multiple endings, as well as line style. Barline data is on the same level as the other musical data in a score - a child of a measure in a partwise score, or a part in a timewise score. This allows for barlines within measures, as in dotted barlines that subdivide measures in complex meters. The two fermata elements allow for fermatas on both sides of the barline (the lower one inverted).
///	
///Barlines have a location attribute to make it easier to process barlines independently of the other musical data in a score. It is often easier to set up measures separately from entering notes. The location attribute must match where the barline element occurs within the rest of the musical data in the score. If location is left, it should be the first element in the measure, aside from the print, bookmark, and link elements. If location is right, it should be the last element, again with the possible exception of the print, bookmark, and link elements. If no location is specified, the right barline is the default. The segno, coda, and divisions attributes work the same way as in the sound element. They are used for playback when barline elements contain segno or coda child elements.
/// </para>
/// <para>
/// Regular expression: (barstyle?, (footnote)?, (level)?, wavyline?, segno?, coda?, fermata*, ending?, repeat?)
/// </para>
/// </summary>
public partial class barline : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<fermata> fermataField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static string locationDefaultValue = "right";
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator barline(XElement xe) { return XTypedServices.ToXTypedElement<barline>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static barline() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// If a barline is other than a normal single barline, it should be represented by a barline type that describes it. This includes information about repeats and multiple endings, as well as line style. Barline data is on the same level as the other musical data in a score - a child of a measure in a partwise score, or a part in a timewise score. This allows for barlines within measures, as in dotted barlines that subdivide measures in complex meters. The two fermata elements allow for fermatas on both sides of the barline (the lower one inverted).
    ///	
    ///Barlines have a location attribute to make it easier to process barlines independently of the other musical data in a score. It is often easier to set up measures separately from entering notes. The location attribute must match where the barline element occurs within the rest of the musical data in the score. If location is left, it should be the first element in the measure, aside from the print, bookmark, and link elements. If location is right, it should be the last element, again with the possible exception of the print, bookmark, and link elements. If no location is specified, the right barline is the default. The segno, coda, and divisions attributes work the same way as in the sound element. They are used for playback when barline elements contain segno or coda child elements.
    /// </para>
    /// <para>
    /// Regular expression: (barstyle?, (footnote)?, (level)?, wavyline?, segno?, coda?, fermata*, ending?, repeat?)
    /// </para>
    /// </summary>
    public barline() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (barstyle?, (footnote)?, (level)?, wavyline?, segno?, coda?, fermata*, ending?, repeat?)
    /// </para>
    /// </summary>
    public barstylecolor barstyle {
        get {
            XElement x = this.GetElement(XName.Get("bar-style", ""));
            return ((barstylecolor)(x));
        }
        set {
            this.SetElement(XName.Get("bar-style", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (barstyle?, (footnote)?, (level)?, wavyline?, segno?, coda?, fermata*, ending?, repeat?)
    /// </para>
    /// </summary>
    public formattedtext footnote {
        get {
            XElement x = this.GetElement(XName.Get("footnote", ""));
            return ((formattedtext)(x));
        }
        set {
            this.SetElement(XName.Get("footnote", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (barstyle?, (footnote)?, (level)?, wavyline?, segno?, coda?, fermata*, ending?, repeat?)
    /// </para>
    /// </summary>
    public level level {
        get {
            XElement x = this.GetElement(XName.Get("level", ""));
            return ((level)(x));
        }
        set {
            this.SetElement(XName.Get("level", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (barstyle?, (footnote)?, (level)?, wavyline?, segno?, coda?, fermata*, ending?, repeat?)
    /// </para>
    /// </summary>
    public wavyline wavyline {
        get {
            XElement x = this.GetElement(XName.Get("wavy-line", ""));
            return ((wavyline)(x));
        }
        set {
            this.SetElement(XName.Get("wavy-line", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (barstyle?, (footnote)?, (level)?, wavyline?, segno?, coda?, fermata*, ending?, repeat?)
    /// </para>
    /// </summary>
    public emptyprintstylealign segno {
        get {
            XElement x = this.GetElement(XName.Get("segno", ""));
            return ((emptyprintstylealign)(x));
        }
        set {
            this.SetElement(XName.Get("segno", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (barstyle?, (footnote)?, (level)?, wavyline?, segno?, coda?, fermata*, ending?, repeat?)
    /// </para>
    /// </summary>
    public emptyprintstylealign coda {
        get {
            XElement x = this.GetElement(XName.Get("coda", ""));
            return ((emptyprintstylealign)(x));
        }
        set {
            this.SetElement(XName.Get("coda", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (barstyle?, (footnote)?, (level)?, wavyline?, segno?, coda?, fermata*, ending?, repeat?)
    /// </para>
    /// </summary>
    public IList<fermata> fermata {
        get {
            if ((this.fermataField == null)) {
                this.fermataField = new XTypedList<fermata>(this, LinqToXsdTypeManager.Instance, XName.Get("fermata", ""));
            }
            return this.fermataField;
        }
        set {
            if ((value == null)) {
                this.fermataField = null;
            }
            else {
                if ((this.fermataField == null)) {
                    this.fermataField = XTypedList<fermata>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("fermata", ""));
                }
                else {
                    XTypedServices.SetList<fermata>(this.fermataField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (barstyle?, (footnote)?, (level)?, wavyline?, segno?, coda?, fermata*, ending?, repeat?)
    /// </para>
    /// </summary>
    public ending ending {
        get {
            XElement x = this.GetElement(XName.Get("ending", ""));
            return ((ending)(x));
        }
        set {
            this.SetElement(XName.Get("ending", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (barstyle?, (footnote)?, (level)?, wavyline?, segno?, coda?, fermata*, ending?, repeat?)
    /// </para>
    /// </summary>
    public repeat repeat {
        get {
            XElement x = this.GetElement(XName.Get("repeat", ""));
            return ((repeat)(x));
        }
        set {
            this.SetElement(XName.Get("repeat", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string location {
        get {
            XAttribute x = this.Attribute(XName.Get("location", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype, locationDefaultValue);
        }
        set {
            this.SetAttribute(XName.Get("location", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string segno1 {
        get {
            XAttribute x = this.Attribute(XName.Get("segno", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("segno", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string coda1 {
        get {
            XAttribute x = this.Attribute(XName.Get("coda", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("coda", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> divisions {
        get {
            XAttribute x = this.Attribute(XName.Get("divisions", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("divisions", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("barline", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<barline>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("bar-style", ""), typeof(barstylecolor));
        localElementDictionary.Add(XName.Get("footnote", ""), typeof(formattedtext));
        localElementDictionary.Add(XName.Get("level", ""), typeof(level));
        localElementDictionary.Add(XName.Get("wavy-line", ""), typeof(wavyline));
        localElementDictionary.Add(XName.Get("segno", ""), typeof(emptyprintstylealign));
        localElementDictionary.Add(XName.Get("coda", ""), typeof(emptyprintstylealign));
        localElementDictionary.Add(XName.Get("fermata", ""), typeof(fermata));
        localElementDictionary.Add(XName.Get("ending", ""), typeof(ending));
        localElementDictionary.Add(XName.Get("repeat", ""), typeof(repeat));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The ending type represents multiple (e.g. first and second) endings. Typically, the start type is associated with the left barline of the first measure in an ending. The stop and discontinue types are associated with the right barline of the last measure in an ending. Stop is used when the ending mark concludes with a downward jog, as is typical for first endings. Discontinue is used when there is no downward jog, as is typical for second endings that do not conclude a piece. The length of the jog can be specified using the end-length attribute. The text-x and text-y attributes are offsets that specify where the baseline of the start of the ending text appears, relative to the start of the ending line.
///	
///The number attribute reflects the numeric values of what is under the ending line. Single endings such as "1" or comma-separated multiple endings such as "1,2" may be used. The ending element text is used when the text displayed in the ending is different than what appears in the number attribute. The print-object element is used to indicate when an ending is present but not printed, as is often the case for many parts in a full score.
/// </para>
/// </summary>
public partial class ending : XTypedElement, IXMetaData {
    
         public static explicit operator ending(XElement xe) { return XTypedServices.ToXTypedElement<ending>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The ending type represents multiple (e.g. first and second) endings. Typically, the start type is associated with the left barline of the first measure in an ending. The stop and discontinue types are associated with the right barline of the last measure in an ending. Stop is used when the ending mark concludes with a downward jog, as is typical for first endings. Discontinue is used when there is no downward jog, as is typical for second endings that do not conclude a piece. The length of the jog can be specified using the end-length attribute. The text-x and text-y attributes are offsets that specify where the baseline of the start of the ending text appears, relative to the start of the ending line.
    ///	
    ///The number attribute reflects the numeric values of what is under the ending line. Single endings such as "1" or comma-separated multiple endings such as "1,2" may be used. The ending element text is used when the text displayed in the ending is different than what appears in the number attribute. The print-object element is used to indicate when an ending is present but not printed, as is often the case for many parts in a full score.
    /// </para>
    /// </summary>
    public ending() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> endlength {
        get {
            XAttribute x = this.Attribute(XName.Get("end-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("end-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> textx {
        get {
            XAttribute x = this.Attribute(XName.Get("text-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("text-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> texty {
        get {
            XAttribute x = this.Attribute(XName.Get("text-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("text-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("ending", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<ending>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The repeat type represents repeat marks. The start of the repeat has a forward direction while the end of the repeat has a backward direction. Backward repeats that are not part of an ending can use the times attribute to indicate the number of times the repeated section is played.
/// </para>
/// </summary>
public partial class repeat : XTypedElement, IXMetaData {
    
         public static explicit operator repeat(XElement xe) { return XTypedServices.ToXTypedElement<repeat>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The repeat type represents repeat marks. The start of the repeat has a forward direction while the end of the repeat has a backward direction. Backward repeats that are not part of an ending can use the times attribute to indicate the number of times the repeated section is played.
    /// </para>
    /// </summary>
    public repeat() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string direction {
        get {
            XAttribute x = this.Attribute(XName.Get("direction", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("direction", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> times {
        get {
            XAttribute x = this.Attribute(XName.Get("times", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("times", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string winged {
        get {
            XAttribute x = this.Attribute(XName.Get("winged", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("winged", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("repeat", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<repeat>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The accord type represents the tuning of a single string in the scordatura element. It uses the same group of elements as the staff-tuning element. Strings are numbered from high to low.
/// </para>
/// <para>
/// Regular expression: (tuningstep, tuningalter?, tuningoctave)
/// </para>
/// </summary>
public partial class accord : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator accord(XElement xe) { return XTypedServices.ToXTypedElement<accord>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static accord() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("tuning-step", "")), new NamedContentModelEntity(XName.Get("tuning-alter", "")), new NamedContentModelEntity(XName.Get("tuning-octave", "")));
    }
    
    /// <summary>
    /// <para>
    /// The accord type represents the tuning of a single string in the scordatura element. It uses the same group of elements as the staff-tuning element. Strings are numbered from high to low.
    /// </para>
    /// <para>
    /// Regular expression: (tuningstep, tuningalter?, tuningoctave)
    /// </para>
    /// </summary>
    public accord() {
    }
    
    /// <summary>
    /// <para>
    /// The tuning-step element is represented like the step element, with a different name to reflect is different function.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (tuningstep, tuningalter?, tuningoctave)
    /// </para>
    /// </summary>
    public string tuningstep {
        get {
            XElement x = this.GetElement(XName.Get("tuning-step", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("tuning-step", ""), value, "tuningstep", global::step.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The tuning-alter element is represented like the alter element, with a different name to reflect is different function.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (tuningstep, tuningalter?, tuningoctave)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> tuningalter {
        get {
            XElement x = this.GetElement(XName.Get("tuning-alter", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("tuning-alter", ""), value, "tuningalter", global::semitones.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The tuning-octave element is represented like the octave element, with a different name to reflect is different function.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (tuningstep, tuningalter?, tuningoctave)
    /// </para>
    /// </summary>
    public decimal tuningoctave {
        get {
            XElement x = this.GetElement(XName.Get("tuning-octave", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("tuning-octave", ""), value, "tuningoctave", global::octave.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> @string {
        get {
            XAttribute x = this.Attribute(XName.Get("string", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("string", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("accord", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<accord>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("tuning-step", ""), typeof(string));
        localElementDictionary.Add(XName.Get("tuning-alter", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("tuning-octave", ""), typeof(decimal));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The accordion-registration type is use for accordion registration symbols. These are circular symbols divided horizontally into high, middle, and low sections that correspond to 4', 8', and 16' pipes. Each accordion-high, accordion-middle, and accordion-low element represents the presence of one or more dots in the registration diagram. An accordion-registration element needs to have at least one of the child elements present.
/// </para>
/// <para>
/// Regular expression: (accordionhigh?, accordionmiddle?, accordionlow?)
/// </para>
/// </summary>
public partial class accordionregistration : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator accordionregistration(XElement xe) { return XTypedServices.ToXTypedElement<accordionregistration>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static accordionregistration() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("accordion-high", "")), new NamedContentModelEntity(XName.Get("accordion-middle", "")), new NamedContentModelEntity(XName.Get("accordion-low", "")));
    }
    
    /// <summary>
    /// <para>
    /// The accordion-registration type is use for accordion registration symbols. These are circular symbols divided horizontally into high, middle, and low sections that correspond to 4', 8', and 16' pipes. Each accordion-high, accordion-middle, and accordion-low element represents the presence of one or more dots in the registration diagram. An accordion-registration element needs to have at least one of the child elements present.
    /// </para>
    /// <para>
    /// Regular expression: (accordionhigh?, accordionmiddle?, accordionlow?)
    /// </para>
    /// </summary>
    public accordionregistration() {
    }
    
    /// <summary>
    /// <para>
    /// The accordion-high element indicates the presence of a dot in the high (4') section of the registration symbol.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (accordionhigh?, accordionmiddle?, accordionlow?)
    /// </para>
    /// </summary>
    public empty accordionhigh {
        get {
            XElement x = this.GetElement(XName.Get("accordion-high", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("accordion-high", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The accordion-middle element indicates the presence of 1 to 3 dots in the middle (8') section of the registration symbol.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (accordionhigh?, accordionmiddle?, accordionlow?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> accordionmiddle {
        get {
            XElement x = this.GetElement(XName.Get("accordion-middle", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("accordion-middle", ""), value, "accordionmiddle", global::accordionmiddle.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The accordion-low element indicates the presence of a dot in the low (16') section of the registration symbol.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (accordionhigh?, accordionmiddle?, accordionlow?)
    /// </para>
    /// </summary>
    public empty accordionlow {
        get {
            XElement x = this.GetElement(XName.Get("accordion-low", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("accordion-low", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("accordion-registration", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<accordionregistration>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("accordion-high", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("accordion-middle", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("accordion-low", ""), typeof(empty));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The barre element indicates placing a finger over multiple strings on a single fret. The type is "start" for the lowest pitched string (e.g., the string with the highest MusicXML number) and is "stop" for the highest pitched string.
/// </para>
/// </summary>
public partial class barre : XTypedElement, IXMetaData {
    
         public static explicit operator barre(XElement xe) { return XTypedServices.ToXTypedElement<barre>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The barre element indicates placing a finger over multiple strings on a single fret. The type is "start" for the lowest pitched string (e.g., the string with the highest MusicXML number) and is "stop" for the highest pitched string.
    /// </para>
    /// </summary>
    public barre() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("barre", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<barre>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The bass type is used to indicate a bass note in popular music chord symbols, e.g. G/C. It is generally not used in functional harmony, as inversion is generally not used in pop chord symbols. As with root, it is divided into step and alter elements, similar to pitches.
/// </para>
/// <para>
/// Regular expression: (bassstep, bassalter?)
/// </para>
/// </summary>
public partial class bass : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator bass(XElement xe) { return XTypedServices.ToXTypedElement<bass>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static bass() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("bass-step", "")), new NamedContentModelEntity(XName.Get("bass-alter", "")));
    }
    
    /// <summary>
    /// <para>
    /// The bass type is used to indicate a bass note in popular music chord symbols, e.g. G/C. It is generally not used in functional harmony, as inversion is generally not used in pop chord symbols. As with root, it is divided into step and alter elements, similar to pitches.
    /// </para>
    /// <para>
    /// Regular expression: (bassstep, bassalter?)
    /// </para>
    /// </summary>
    public bass() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (bassstep, bassalter?)
    /// </para>
    /// </summary>
    public bassstep bassstep {
        get {
            XElement x = this.GetElement(XName.Get("bass-step", ""));
            return ((bassstep)(x));
        }
        set {
            this.SetElement(XName.Get("bass-step", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (bassstep, bassalter?)
    /// </para>
    /// </summary>
    public bassalter bassalter {
        get {
            XElement x = this.GetElement(XName.Get("bass-alter", ""));
            return ((bassalter)(x));
        }
        set {
            this.SetElement(XName.Get("bass-alter", ""), value);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("bass", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<bass>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("bass-step", ""), typeof(bassstep));
        localElementDictionary.Add(XName.Get("bass-alter", ""), typeof(bassalter));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The bass-alter type represents the chromatic alteration of the bass of the current chord within the harmony element. In some chord styles, the text for the bass-step element may include bass-alter information. In that case, the print-object attribute of the bass-alter element can be set to no. The location attribute indicates whether the alteration should appear to the left or the right of the bass-step; it is right by default.
/// </para>
/// </summary>
public partial class bassalter : XTypedElement, IXMetaData {
    
         public static explicit operator bassalter(XElement xe) { return XTypedServices.ToXTypedElement<bassalter>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The bass-alter type represents the chromatic alteration of the bass of the current chord within the harmony element. In some chord styles, the text for the bass-step element may include bass-alter information. In that case, the print-object attribute of the bass-alter element can be set to no. The location attribute indicates whether the alteration should appear to the left or the right of the bass-step; it is right by default.
    /// </para>
    /// </summary>
    public bassalter() {
    }
    
    public decimal TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::semitones.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string location {
        get {
            XAttribute x = this.Attribute(XName.Get("location", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("location", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("bass-alter", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<bassalter>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The bass-step type represents the pitch step of the bass of the current chord within the harmony element. The text attribute indicates how the bass should appear in a score if not using the element contents.
/// </para>
/// </summary>
public partial class bassstep : XTypedElement, IXMetaData {
    
         public static explicit operator bassstep(XElement xe) { return XTypedServices.ToXTypedElement<bassstep>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The bass-step type represents the pitch step of the bass of the current chord within the harmony element. The text attribute indicates how the bass should appear in a score if not using the element contents.
    /// </para>
    /// </summary>
    public bassstep() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::step.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string text {
        get {
            XAttribute x = this.Attribute(XName.Get("text", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("text", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("bass-step", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<bassstep>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The beater type represents pictograms for beaters, mallets, and sticks that do not have different materials represented in the pictogram.
/// </para>
/// </summary>
public partial class beater : XTypedElement, IXMetaData {
    
         public static explicit operator beater(XElement xe) { return XTypedServices.ToXTypedElement<beater>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The beater type represents pictograms for beaters, mallets, and sticks that do not have different materials represented in the pictogram.
    /// </para>
    /// </summary>
    public beater() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::beatervalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string tip {
        get {
            XAttribute x = this.Attribute(XName.Get("tip", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("tip", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("beater", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<beater>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Brackets are combined with words in a variety of modern directions. The line-end attribute specifies if there is a jog up or down (or both), an arrow, or nothing at the start or end of the bracket. If the line-end is up or down, the length of the jog can be specified using the end-length attribute. The line-type is solid by default.
/// </para>
/// </summary>
public partial class bracket : XTypedElement, IXMetaData {
    
         public static explicit operator bracket(XElement xe) { return XTypedServices.ToXTypedElement<bracket>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// Brackets are combined with words in a variety of modern directions. The line-end attribute specifies if there is a jog up or down (or both), an arrow, or nothing at the start or end of the bracket. If the line-end is up or down, the length of the jog can be specified using the end-length attribute. The line-type is solid by default.
    /// </para>
    /// </summary>
    public bracket() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string lineend {
        get {
            XAttribute x = this.Attribute(XName.Get("line-end", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line-end", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> endlength {
        get {
            XAttribute x = this.Attribute(XName.Get("end-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("end-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string linetype {
        get {
            XAttribute x = this.Attribute(XName.Get("line-type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line-type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> dashlength {
        get {
            XAttribute x = this.Attribute(XName.Get("dash-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dash-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> spacelength {
        get {
            XAttribute x = this.Attribute(XName.Get("space-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("space-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("bracket", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<bracket>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The dashes type represents dashes, used for instance with cresc. and dim. marks.
/// </para>
/// </summary>
public partial class dashes : XTypedElement, IXMetaData {
    
         public static explicit operator dashes(XElement xe) { return XTypedServices.ToXTypedElement<dashes>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The dashes type represents dashes, used for instance with cresc. and dim. marks.
    /// </para>
    /// </summary>
    public dashes() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> dashlength {
        get {
            XAttribute x = this.Attribute(XName.Get("dash-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dash-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> spacelength {
        get {
            XAttribute x = this.Attribute(XName.Get("space-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("space-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("dashes", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<dashes>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The degree type is used to add, alter, or subtract individual notes in the chord. The print-object attribute can be used to keep the degree from printing separately when it has already taken into account in the text attribute of the kind element. The degree-value and degree-type text attributes specify how the value and type of the degree should be displayed.
///	
///A harmony of kind "other" can be spelled explicitly by using a series of degree elements together with a root.
/// </para>
/// <para>
/// Regular expression: (degreevalue, degreealter, degreetype)
/// </para>
/// </summary>
public partial class degree : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator degree(XElement xe) { return XTypedServices.ToXTypedElement<degree>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static degree() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("degree-value", "")), new NamedContentModelEntity(XName.Get("degree-alter", "")), new NamedContentModelEntity(XName.Get("degree-type", "")));
    }
    
    /// <summary>
    /// <para>
    /// The degree type is used to add, alter, or subtract individual notes in the chord. The print-object attribute can be used to keep the degree from printing separately when it has already taken into account in the text attribute of the kind element. The degree-value and degree-type text attributes specify how the value and type of the degree should be displayed.
    ///	
    ///A harmony of kind "other" can be spelled explicitly by using a series of degree elements together with a root.
    /// </para>
    /// <para>
    /// Regular expression: (degreevalue, degreealter, degreetype)
    /// </para>
    /// </summary>
    public degree() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (degreevalue, degreealter, degreetype)
    /// </para>
    /// </summary>
    public degreevalue degreevalue {
        get {
            XElement x = this.GetElement(XName.Get("degree-value", ""));
            return ((degreevalue)(x));
        }
        set {
            this.SetElement(XName.Get("degree-value", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (degreevalue, degreealter, degreetype)
    /// </para>
    /// </summary>
    public degreealter degreealter {
        get {
            XElement x = this.GetElement(XName.Get("degree-alter", ""));
            return ((degreealter)(x));
        }
        set {
            this.SetElement(XName.Get("degree-alter", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (degreevalue, degreealter, degreetype)
    /// </para>
    /// </summary>
    public degreetype degreetype {
        get {
            XElement x = this.GetElement(XName.Get("degree-type", ""));
            return ((degreetype)(x));
        }
        set {
            this.SetElement(XName.Get("degree-type", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("degree", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<degree>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("degree-value", ""), typeof(degreevalue));
        localElementDictionary.Add(XName.Get("degree-alter", ""), typeof(degreealter));
        localElementDictionary.Add(XName.Get("degree-type", ""), typeof(degreetype));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The degree-alter type represents the chromatic alteration for the current degree. If the degree-type value is alter or subtract, the degree-alter value is relative to the degree already in the chord based on its kind element. If the degree-type value is add, the degree-alter is relative to a dominant chord (major and perfect intervals except for a minor seventh). The plus-minus attribute is used to indicate if plus and minus symbols should be used instead of sharp and flat symbols to display the degree alteration; it is no by default.
/// </para>
/// </summary>
public partial class degreealter : XTypedElement, IXMetaData {
    
         public static explicit operator degreealter(XElement xe) { return XTypedServices.ToXTypedElement<degreealter>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The degree-alter type represents the chromatic alteration for the current degree. If the degree-type value is alter or subtract, the degree-alter value is relative to the degree already in the chord based on its kind element. If the degree-type value is add, the degree-alter is relative to a dominant chord (major and perfect intervals except for a minor seventh). The plus-minus attribute is used to indicate if plus and minus symbols should be used instead of sharp and flat symbols to display the degree alteration; it is no by default.
    /// </para>
    /// </summary>
    public degreealter() {
    }
    
    public decimal TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::semitones.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string plusminus {
        get {
            XAttribute x = this.Attribute(XName.Get("plus-minus", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("plus-minus", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("degree-alter", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<degreealter>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The degree-type type indicates if this degree is an addition, alteration, or subtraction relative to the kind of the current chord. The value of the degree-type element affects the interpretation of the value of the degree-alter element. The text attribute specifies how the type of the degree should be displayed in a score.
/// </para>
/// </summary>
public partial class degreetype : XTypedElement, IXMetaData {
    
         public static explicit operator degreetype(XElement xe) { return XTypedServices.ToXTypedElement<degreetype>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The degree-type type indicates if this degree is an addition, alteration, or subtraction relative to the kind of the current chord. The value of the degree-type element affects the interpretation of the value of the degree-alter element. The text attribute specifies how the type of the degree should be displayed in a score.
    /// </para>
    /// </summary>
    public degreetype() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::degreetypevalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string text {
        get {
            XAttribute x = this.Attribute(XName.Get("text", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("text", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("degree-type", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<degreetype>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The content of the degree-value type is a number indicating the degree of the chord (1 for the root, 3 for third, etc). The text attribute specifies how the type of the degree should be displayed in a score. The degree-value symbol attribute indicates that a symbol should be used in specifying the degree. If the symbol attribute is present, the value of the text attribute follows the symbol.
/// </para>
/// </summary>
public partial class degreevalue : XTypedElement, IXMetaData {
    
         public static explicit operator degreevalue(XElement xe) { return XTypedServices.ToXTypedElement<degreevalue>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The content of the degree-value type is a number indicating the degree of the chord (1 for the root, 3 for third, etc). The text attribute specifies how the type of the degree should be displayed in a score. The degree-value symbol attribute indicates that a symbol should be used in specifying the degree. If the symbol attribute is present, the value of the text attribute follows the symbol.
    /// </para>
    /// </summary>
    public degreevalue() {
    }
    
    public decimal TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string symbol {
        get {
            XAttribute x = this.Attribute(XName.Get("symbol", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("symbol", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string text {
        get {
            XAttribute x = this.Attribute(XName.Get("text", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("text", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("degree-value", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<degreevalue>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// A direction is a musical indication that is not attached to a specific note. Two or more may be combined to indicate starts and stops of wedges, dashes, etc.
///	
///By default, a series of direction-type elements and a series of child elements of a direction-type within a single direction element follow one another in sequence visually. For a series of direction-type children, non-positional formatting attributes are carried over from the previous element by default.
/// </para>
/// <para>
/// Regular expression: (directiontype+, offset?, (footnote)?, (level)?, (voice)?, (staff)?, sound?)
/// </para>
/// </summary>
public partial class direction : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<directiontype> directiontypeField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator direction(XElement xe) { return XTypedServices.ToXTypedElement<direction>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static direction() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// A direction is a musical indication that is not attached to a specific note. Two or more may be combined to indicate starts and stops of wedges, dashes, etc.
    ///	
    ///By default, a series of direction-type elements and a series of child elements of a direction-type within a single direction element follow one another in sequence visually. For a series of direction-type children, non-positional formatting attributes are carried over from the previous element by default.
    /// </para>
    /// <para>
    /// Regular expression: (directiontype+, offset?, (footnote)?, (level)?, (voice)?, (staff)?, sound?)
    /// </para>
    /// </summary>
    public direction() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, repeating
    /// </para>
    /// <para>
    /// Regular expression: (directiontype+, offset?, (footnote)?, (level)?, (voice)?, (staff)?, sound?)
    /// </para>
    /// </summary>
    public IList<directiontype> directiontype {
        get {
            if ((this.directiontypeField == null)) {
                this.directiontypeField = new XTypedList<directiontype>(this, LinqToXsdTypeManager.Instance, XName.Get("direction-type", ""));
            }
            return this.directiontypeField;
        }
        set {
            if ((value == null)) {
                this.directiontypeField = null;
            }
            else {
                if ((this.directiontypeField == null)) {
                    this.directiontypeField = XTypedList<directiontype>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("direction-type", ""));
                }
                else {
                    XTypedServices.SetList<directiontype>(this.directiontypeField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (directiontype+, offset?, (footnote)?, (level)?, (voice)?, (staff)?, sound?)
    /// </para>
    /// </summary>
    public offset offset {
        get {
            XElement x = this.GetElement(XName.Get("offset", ""));
            return ((offset)(x));
        }
        set {
            this.SetElement(XName.Get("offset", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (directiontype+, offset?, (footnote)?, (level)?, (voice)?, (staff)?, sound?)
    /// </para>
    /// </summary>
    public formattedtext footnote {
        get {
            XElement x = this.GetElement(XName.Get("footnote", ""));
            return ((formattedtext)(x));
        }
        set {
            this.SetElement(XName.Get("footnote", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (directiontype+, offset?, (footnote)?, (level)?, (voice)?, (staff)?, sound?)
    /// </para>
    /// </summary>
    public level level {
        get {
            XElement x = this.GetElement(XName.Get("level", ""));
            return ((level)(x));
        }
        set {
            this.SetElement(XName.Get("level", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (directiontype+, offset?, (footnote)?, (level)?, (voice)?, (staff)?, sound?)
    /// </para>
    /// </summary>
    public string voice {
        get {
            XElement x = this.GetElement(XName.Get("voice", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("voice", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Staff assignment is only needed for music notated on multiple staves. Used by both notes and directions. Staff values are numbers, with 1 referring to the top-most staff in a part.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (directiontype+, offset?, (footnote)?, (level)?, (voice)?, (staff)?, sound?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> staff {
        get {
            XElement x = this.GetElement(XName.Get("staff", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetElement(XName.Get("staff", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (directiontype+, offset?, (footnote)?, (level)?, (voice)?, (staff)?, sound?)
    /// </para>
    /// </summary>
    public sound sound {
        get {
            XElement x = this.GetElement(XName.Get("sound", ""));
            return ((sound)(x));
        }
        set {
            this.SetElement(XName.Get("sound", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string directive {
        get {
            XAttribute x = this.Attribute(XName.Get("directive", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("directive", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("direction", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<direction>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("direction-type", ""), typeof(directiontype));
        localElementDictionary.Add(XName.Get("offset", ""), typeof(offset));
        localElementDictionary.Add(XName.Get("footnote", ""), typeof(formattedtext));
        localElementDictionary.Add(XName.Get("level", ""), typeof(level));
        localElementDictionary.Add(XName.Get("voice", ""), typeof(string));
        localElementDictionary.Add(XName.Get("staff", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("sound", ""), typeof(sound));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Textual direction types may have more than 1 component due to multiple fonts. The dynamics element may also be used in the notations element. Attribute groups related to print suggestions apply to the individual direction-type, not to the overall direction.
/// </para>
/// <para>
/// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
/// </para>
/// </summary>
public partial class directiontype : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<formattedtext> rehearsalField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyprintstylealign> segnoField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<formattedtext> wordsField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyprintstylealign> codaField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<dynamics> dynamicsField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<percussion> percussionField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator directiontype(XElement xe) { return XTypedServices.ToXTypedElement<directiontype>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static directiontype() {
        BuildElementDictionary();
        contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(XName.Get("rehearsal", "")), new NamedContentModelEntity(XName.Get("segno", "")), new NamedContentModelEntity(XName.Get("words", "")), new NamedContentModelEntity(XName.Get("coda", "")), new NamedContentModelEntity(XName.Get("wedge", "")), new NamedContentModelEntity(XName.Get("dynamics", "")), new NamedContentModelEntity(XName.Get("dashes", "")), new NamedContentModelEntity(XName.Get("bracket", "")), new NamedContentModelEntity(XName.Get("pedal", "")), new NamedContentModelEntity(XName.Get("metronome", "")), new NamedContentModelEntity(XName.Get("octave-shift", "")), new NamedContentModelEntity(XName.Get("harp-pedals", "")), new NamedContentModelEntity(XName.Get("damp", "")), new NamedContentModelEntity(XName.Get("damp-all", "")), new NamedContentModelEntity(XName.Get("eyeglasses", "")), new NamedContentModelEntity(XName.Get("string-mute", "")), new NamedContentModelEntity(XName.Get("scordatura", "")), new NamedContentModelEntity(XName.Get("image", "")), new NamedContentModelEntity(XName.Get("principal-voice", "")), new NamedContentModelEntity(XName.Get("accordion-registration", "")), new NamedContentModelEntity(XName.Get("percussion", "")), new NamedContentModelEntity(XName.Get("other-direction", "")));
    }
    
    /// <summary>
    /// <para>
    /// Textual direction types may have more than 1 component due to multiple fonts. The dynamics element may also be used in the notations element. Attribute groups related to print suggestions apply to the individual direction-type, not to the overall direction.
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public directiontype() {
    }
    
    /// <summary>
    /// <para>
    /// The rehearsal type specifies a rehearsal mark. Language is Italian ("it") by default. Enclosure is square by default. Left justification is assumed if not specified.
    /// </para>
    /// <para>
    /// Occurrence: required, repeating, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public IList<formattedtext> rehearsal {
        get {
            if ((this.rehearsalField == null)) {
                this.rehearsalField = new XTypedList<formattedtext>(this, LinqToXsdTypeManager.Instance, XName.Get("rehearsal", ""));
            }
            return this.rehearsalField;
        }
        set {
            if ((value == null)) {
                this.rehearsalField = null;
            }
            else {
                if ((this.rehearsalField == null)) {
                    this.rehearsalField = XTypedList<formattedtext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("rehearsal", ""));
                }
                else {
                    XTypedServices.SetList<formattedtext>(this.rehearsalField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The segno element is the visual indicator of a segno sign. A sound element is needed to guide playback applications reliably.
    /// </para>
    /// <para>
    /// Occurrence: required, repeating, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public IList<emptyprintstylealign> segno {
        get {
            if ((this.segnoField == null)) {
                this.segnoField = new XTypedList<emptyprintstylealign>(this, LinqToXsdTypeManager.Instance, XName.Get("segno", ""));
            }
            return this.segnoField;
        }
        set {
            if ((value == null)) {
                this.segnoField = null;
            }
            else {
                if ((this.segnoField == null)) {
                    this.segnoField = XTypedList<emptyprintstylealign>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("segno", ""));
                }
                else {
                    XTypedServices.SetList<emptyprintstylealign>(this.segnoField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The words element specifies a standard text direction. Left justification is assumed if not specified. Language is Italian ("it") by default. Enclosure is none by default.
    /// </para>
    /// <para>
    /// Occurrence: required, repeating, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public IList<formattedtext> words {
        get {
            if ((this.wordsField == null)) {
                this.wordsField = new XTypedList<formattedtext>(this, LinqToXsdTypeManager.Instance, XName.Get("words", ""));
            }
            return this.wordsField;
        }
        set {
            if ((value == null)) {
                this.wordsField = null;
            }
            else {
                if ((this.wordsField == null)) {
                    this.wordsField = XTypedList<formattedtext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("words", ""));
                }
                else {
                    XTypedServices.SetList<formattedtext>(this.wordsField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The coda element is the visual indicator of a coda sign. A sound element is needed to guide playback applications reliably.
    /// </para>
    /// <para>
    /// Occurrence: required, repeating, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public IList<emptyprintstylealign> coda {
        get {
            if ((this.codaField == null)) {
                this.codaField = new XTypedList<emptyprintstylealign>(this, LinqToXsdTypeManager.Instance, XName.Get("coda", ""));
            }
            return this.codaField;
        }
        set {
            if ((value == null)) {
                this.codaField = null;
            }
            else {
                if ((this.codaField == null)) {
                    this.codaField = XTypedList<emptyprintstylealign>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("coda", ""));
                }
                else {
                    XTypedServices.SetList<emptyprintstylealign>(this.codaField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public wedge wedge {
        get {
            XElement x = this.GetElement(XName.Get("wedge", ""));
            return ((wedge)(x));
        }
        set {
            this.SetElement(XName.Get("wedge", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, repeating, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public IList<dynamics> dynamics {
        get {
            if ((this.dynamicsField == null)) {
                this.dynamicsField = new XTypedList<dynamics>(this, LinqToXsdTypeManager.Instance, XName.Get("dynamics", ""));
            }
            return this.dynamicsField;
        }
        set {
            if ((value == null)) {
                this.dynamicsField = null;
            }
            else {
                if ((this.dynamicsField == null)) {
                    this.dynamicsField = XTypedList<dynamics>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("dynamics", ""));
                }
                else {
                    XTypedServices.SetList<dynamics>(this.dynamicsField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public dashes dashes {
        get {
            XElement x = this.GetElement(XName.Get("dashes", ""));
            return ((dashes)(x));
        }
        set {
            this.SetElement(XName.Get("dashes", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public bracket bracket {
        get {
            XElement x = this.GetElement(XName.Get("bracket", ""));
            return ((bracket)(x));
        }
        set {
            this.SetElement(XName.Get("bracket", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public pedal pedal {
        get {
            XElement x = this.GetElement(XName.Get("pedal", ""));
            return ((pedal)(x));
        }
        set {
            this.SetElement(XName.Get("pedal", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public metronome metronome {
        get {
            XElement x = this.GetElement(XName.Get("metronome", ""));
            return ((metronome)(x));
        }
        set {
            this.SetElement(XName.Get("metronome", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public octaveshift octaveshift {
        get {
            XElement x = this.GetElement(XName.Get("octave-shift", ""));
            return ((octaveshift)(x));
        }
        set {
            this.SetElement(XName.Get("octave-shift", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public harppedals harppedals {
        get {
            XElement x = this.GetElement(XName.Get("harp-pedals", ""));
            return ((harppedals)(x));
        }
        set {
            this.SetElement(XName.Get("harp-pedals", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The damp element specifies a harp damping mark.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public emptyprintstylealign damp {
        get {
            XElement x = this.GetElement(XName.Get("damp", ""));
            return ((emptyprintstylealign)(x));
        }
        set {
            this.SetElement(XName.Get("damp", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The damp-all element specifies a harp damping mark for all strings.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public emptyprintstylealign dampall {
        get {
            XElement x = this.GetElement(XName.Get("damp-all", ""));
            return ((emptyprintstylealign)(x));
        }
        set {
            this.SetElement(XName.Get("damp-all", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The eyeglasses element specifies the eyeglasses symbol, common in commercial music.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public emptyprintstylealign eyeglasses {
        get {
            XElement x = this.GetElement(XName.Get("eyeglasses", ""));
            return ((emptyprintstylealign)(x));
        }
        set {
            this.SetElement(XName.Get("eyeglasses", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public stringmute stringmute {
        get {
            XElement x = this.GetElement(XName.Get("string-mute", ""));
            return ((stringmute)(x));
        }
        set {
            this.SetElement(XName.Get("string-mute", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public scordatura scordatura {
        get {
            XElement x = this.GetElement(XName.Get("scordatura", ""));
            return ((scordatura)(x));
        }
        set {
            this.SetElement(XName.Get("scordatura", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public image image {
        get {
            XElement x = this.GetElement(XName.Get("image", ""));
            return ((image)(x));
        }
        set {
            this.SetElement(XName.Get("image", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public principalvoice principalvoice {
        get {
            XElement x = this.GetElement(XName.Get("principal-voice", ""));
            return ((principalvoice)(x));
        }
        set {
            this.SetElement(XName.Get("principal-voice", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public accordionregistration accordionregistration {
        get {
            XElement x = this.GetElement(XName.Get("accordion-registration", ""));
            return ((accordionregistration)(x));
        }
        set {
            this.SetElement(XName.Get("accordion-registration", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, repeating, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public IList<percussion> percussion {
        get {
            if ((this.percussionField == null)) {
                this.percussionField = new XTypedList<percussion>(this, LinqToXsdTypeManager.Instance, XName.Get("percussion", ""));
            }
            return this.percussionField;
        }
        set {
            if ((value == null)) {
                this.percussionField = null;
            }
            else {
                if ((this.percussionField == null)) {
                    this.percussionField = XTypedList<percussion>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("percussion", ""));
                }
                else {
                    XTypedServices.SetList<percussion>(this.percussionField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (rehearsal+ | segno+ | words+ | coda+ | wedge | dynamics+ | dashes | bracket | pedal | metronome | octaveshift | harppedals | damp | dampall | eyeglasses | stringmute | scordatura | image | principalvoice | accordionregistration | percussion+ | otherdirection)
    /// </para>
    /// </summary>
    public otherdirection otherdirection {
        get {
            XElement x = this.GetElement(XName.Get("other-direction", ""));
            return ((otherdirection)(x));
        }
        set {
            this.SetElement(XName.Get("other-direction", ""), value);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("direction-type", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<directiontype>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("rehearsal", ""), typeof(formattedtext));
        localElementDictionary.Add(XName.Get("segno", ""), typeof(emptyprintstylealign));
        localElementDictionary.Add(XName.Get("words", ""), typeof(formattedtext));
        localElementDictionary.Add(XName.Get("coda", ""), typeof(emptyprintstylealign));
        localElementDictionary.Add(XName.Get("wedge", ""), typeof(wedge));
        localElementDictionary.Add(XName.Get("dynamics", ""), typeof(dynamics));
        localElementDictionary.Add(XName.Get("dashes", ""), typeof(dashes));
        localElementDictionary.Add(XName.Get("bracket", ""), typeof(bracket));
        localElementDictionary.Add(XName.Get("pedal", ""), typeof(pedal));
        localElementDictionary.Add(XName.Get("metronome", ""), typeof(metronome));
        localElementDictionary.Add(XName.Get("octave-shift", ""), typeof(octaveshift));
        localElementDictionary.Add(XName.Get("harp-pedals", ""), typeof(harppedals));
        localElementDictionary.Add(XName.Get("damp", ""), typeof(emptyprintstylealign));
        localElementDictionary.Add(XName.Get("damp-all", ""), typeof(emptyprintstylealign));
        localElementDictionary.Add(XName.Get("eyeglasses", ""), typeof(emptyprintstylealign));
        localElementDictionary.Add(XName.Get("string-mute", ""), typeof(stringmute));
        localElementDictionary.Add(XName.Get("scordatura", ""), typeof(scordatura));
        localElementDictionary.Add(XName.Get("image", ""), typeof(image));
        localElementDictionary.Add(XName.Get("principal-voice", ""), typeof(principalvoice));
        localElementDictionary.Add(XName.Get("accordion-registration", ""), typeof(accordionregistration));
        localElementDictionary.Add(XName.Get("percussion", ""), typeof(percussion));
        localElementDictionary.Add(XName.Get("other-direction", ""), typeof(otherdirection));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The feature type is a part of the grouping element used for musical analysis. The type attribute represents the type of the feature and the element content represents its value. This type is flexible to allow for different analyses.
/// </para>
/// </summary>
public partial class feature : XTypedElement, IXMetaData {
    
         public static explicit operator feature(XElement xe) { return XTypedServices.ToXTypedElement<feature>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The feature type is a part of the grouping element used for musical analysis. The type attribute represents the type of the feature and the element content represents its value. This type is flexible to allow for different analyses.
    /// </para>
    /// </summary>
    public feature() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("feature", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<feature>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The first-fret type indicates which fret is shown in the top space of the frame; it is fret 1 if the element is not present. The optional text attribute indicates how this is represented in the fret diagram, while the location attribute indicates whether the text appears to the left or right of the frame.
/// </para>
/// </summary>
public partial class firstfret : XTypedElement, IXMetaData {
    
         public static explicit operator firstfret(XElement xe) { return XTypedServices.ToXTypedElement<firstfret>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The first-fret type indicates which fret is shown in the top space of the frame; it is fret 1 if the element is not present. The optional text attribute indicates how this is represented in the fret diagram, while the location attribute indicates whether the text appears to the left or right of the frame.
    /// </para>
    /// </summary>
    public firstfret() {
    }
    
    public decimal TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string text {
        get {
            XAttribute x = this.Attribute(XName.Get("text", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("text", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string location {
        get {
            XAttribute x = this.Attribute(XName.Get("location", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("location", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("first-fret", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<firstfret>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The frame type represents a frame or fretboard diagram used together with a chord symbol. The representation is based on the NIFF guitar grid with additional information. The frame type's unplayed attribute indicates what to display above a string that has no associated frame-note element. Typical values are x and the empty string. If the attribute is not present, the display of the unplayed string is application-defined.
/// </para>
/// <para>
/// Regular expression: (framestrings, framefrets, firstfret?, framenote+)
/// </para>
/// </summary>
public partial class frame : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<framenote> framenoteField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator frame(XElement xe) { return XTypedServices.ToXTypedElement<frame>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static frame() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("frame-strings", "")), new NamedContentModelEntity(XName.Get("frame-frets", "")), new NamedContentModelEntity(XName.Get("first-fret", "")), new NamedContentModelEntity(XName.Get("frame-note", "")));
    }
    
    /// <summary>
    /// <para>
    /// The frame type represents a frame or fretboard diagram used together with a chord symbol. The representation is based on the NIFF guitar grid with additional information. The frame type's unplayed attribute indicates what to display above a string that has no associated frame-note element. Typical values are x and the empty string. If the attribute is not present, the display of the unplayed string is application-defined.
    /// </para>
    /// <para>
    /// Regular expression: (framestrings, framefrets, firstfret?, framenote+)
    /// </para>
    /// </summary>
    public frame() {
    }
    
    /// <summary>
    /// <para>
    /// The frame-strings element gives the overall size of the frame in vertical lines (strings).
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (framestrings, framefrets, firstfret?, framenote+)
    /// </para>
    /// </summary>
    public decimal framestrings {
        get {
            XElement x = this.GetElement(XName.Get("frame-strings", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetElement(XName.Get("frame-strings", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// The frame-frets element gives the overall size of the frame in horizontal spaces (frets).
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (framestrings, framefrets, firstfret?, framenote+)
    /// </para>
    /// </summary>
    public decimal framefrets {
        get {
            XElement x = this.GetElement(XName.Get("frame-frets", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetElement(XName.Get("frame-frets", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (framestrings, framefrets, firstfret?, framenote+)
    /// </para>
    /// </summary>
    public firstfret firstfret {
        get {
            XElement x = this.GetElement(XName.Get("first-fret", ""));
            return ((firstfret)(x));
        }
        set {
            this.SetElement(XName.Get("first-fret", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, repeating
    /// </para>
    /// <para>
    /// Regular expression: (framestrings, framefrets, firstfret?, framenote+)
    /// </para>
    /// </summary>
    public IList<framenote> framenote {
        get {
            if ((this.framenoteField == null)) {
                this.framenoteField = new XTypedList<framenote>(this, LinqToXsdTypeManager.Instance, XName.Get("frame-note", ""));
            }
            return this.framenoteField;
        }
        set {
            if ((value == null)) {
                this.framenoteField = null;
            }
            else {
                if ((this.framenoteField == null)) {
                    this.framenoteField = XTypedList<framenote>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("frame-note", ""));
                }
                else {
                    XTypedServices.SetList<framenote>(this.framenoteField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> height {
        get {
            XAttribute x = this.Attribute(XName.Get("height", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("height", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> width {
        get {
            XAttribute x = this.Attribute(XName.Get("width", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("width", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string unplayed {
        get {
            XAttribute x = this.Attribute(XName.Get("unplayed", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("unplayed", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("frame", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<frame>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("frame-strings", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("frame-frets", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("first-fret", ""), typeof(firstfret));
        localElementDictionary.Add(XName.Get("frame-note", ""), typeof(framenote));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The frame-note type represents each note included in the frame. An open string will have a fret value of 0, while a muted string will not be associated with a frame-note element.
/// </para>
/// <para>
/// Regular expression: (@string, fret, fingering?, barre?)
/// </para>
/// </summary>
public partial class framenote : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator framenote(XElement xe) { return XTypedServices.ToXTypedElement<framenote>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static framenote() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("string", "")), new NamedContentModelEntity(XName.Get("fret", "")), new NamedContentModelEntity(XName.Get("fingering", "")), new NamedContentModelEntity(XName.Get("barre", "")));
    }
    
    /// <summary>
    /// <para>
    /// The frame-note type represents each note included in the frame. An open string will have a fret value of 0, while a muted string will not be associated with a frame-note element.
    /// </para>
    /// <para>
    /// Regular expression: (@string, fret, fingering?, barre?)
    /// </para>
    /// </summary>
    public framenote() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (@string, fret, fingering?, barre?)
    /// </para>
    /// </summary>
    public @string @string {
        get {
            XElement x = this.GetElement(XName.Get("string", ""));
            return ((@string)(x));
        }
        set {
            this.SetElement(XName.Get("string", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (@string, fret, fingering?, barre?)
    /// </para>
    /// </summary>
    public fret fret {
        get {
            XElement x = this.GetElement(XName.Get("fret", ""));
            return ((fret)(x));
        }
        set {
            this.SetElement(XName.Get("fret", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (@string, fret, fingering?, barre?)
    /// </para>
    /// </summary>
    public fingering fingering {
        get {
            XElement x = this.GetElement(XName.Get("fingering", ""));
            return ((fingering)(x));
        }
        set {
            this.SetElement(XName.Get("fingering", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (@string, fret, fingering?, barre?)
    /// </para>
    /// </summary>
    public barre barre {
        get {
            XElement x = this.GetElement(XName.Get("barre", ""));
            return ((barre)(x));
        }
        set {
            this.SetElement(XName.Get("barre", ""), value);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("frame-note", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<framenote>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("string", ""), typeof(@string));
        localElementDictionary.Add(XName.Get("fret", ""), typeof(fret));
        localElementDictionary.Add(XName.Get("fingering", ""), typeof(fingering));
        localElementDictionary.Add(XName.Get("barre", ""), typeof(barre));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The grouping type is used for musical analysis. When the type attribute is "start" or "single", it usually contains one or more feature elements. The number attribute is used for distinguishing between overlapping and hierarchical groupings. The member-of attribute allows for easy distinguishing of what grouping elements are in what hierarchy. Feature elements contained within a "stop" type of grouping may be ignored.
///	
///This element is flexible to allow for different types of analyses. Future versions of the MusicXML format may add elements that can represent more standardized categories of analysis data, allowing for easier data sharing.
/// </para>
/// <para>
/// Regular expression: (feature*)
/// </para>
/// </summary>
public partial class grouping : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<feature> featureField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static string numberDefaultValue = "1";
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator grouping(XElement xe) { return XTypedServices.ToXTypedElement<grouping>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static grouping() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("feature", "")));
    }
    
    /// <summary>
    /// <para>
    /// The grouping type is used for musical analysis. When the type attribute is "start" or "single", it usually contains one or more feature elements. The number attribute is used for distinguishing between overlapping and hierarchical groupings. The member-of attribute allows for easy distinguishing of what grouping elements are in what hierarchy. Feature elements contained within a "stop" type of grouping may be ignored.
    ///	
    ///This element is flexible to allow for different types of analyses. Future versions of the MusicXML format may add elements that can represent more standardized categories of analysis data, allowing for easier data sharing.
    /// </para>
    /// <para>
    /// Regular expression: (feature*)
    /// </para>
    /// </summary>
    public grouping() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (feature*)
    /// </para>
    /// </summary>
    public IList<feature> feature {
        get {
            if ((this.featureField == null)) {
                this.featureField = new XTypedList<feature>(this, LinqToXsdTypeManager.Instance, XName.Get("feature", ""));
            }
            return this.featureField;
        }
        set {
            if ((value == null)) {
                this.featureField = null;
            }
            else {
                if ((this.featureField == null)) {
                    this.featureField = XTypedList<feature>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("feature", ""));
                }
                else {
                    XTypedServices.SetList<feature>(this.featureField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype, numberDefaultValue);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string memberof {
        get {
            XAttribute x = this.Attribute(XName.Get("member-of", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("member-of", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("grouping", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<grouping>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("feature", ""), typeof(feature));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The harmony type is based on Humdrum's **harm encoding, extended to support chord symbols in popular music as well as functional harmony analysis in classical music.
///	
///If there are alternate harmonies possible, this can be specified using multiple harmony elements differentiated by type. Explicit harmonies have all note present in the music; implied have some notes missing but implied; alternate represents alternate analyses. 
///	
///The harmony object may be used for analysis or for chord symbols. The print-object attribute controls whether or not anything is printed due to the harmony element. The print-frame attribute controls printing of a frame or fretboard diagram. The print-style attribute group sets the default for the harmony, but individual elements can override this with their own print-style values.
/// </para>
/// <para>
/// Regular expression: (((root | function), kind, inversion?, bass?, degree*)+, frame?, offset?, (footnote)?, (level)?, (staff)?)
/// </para>
/// </summary>
public partial class harmony : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<root> rootField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<styletext> functionField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<kind> kindField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<inversion> inversionField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<bass> bassField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<degree> degreeField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator harmony(XElement xe) { return XTypedServices.ToXTypedElement<harmony>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static harmony() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The harmony type is based on Humdrum's **harm encoding, extended to support chord symbols in popular music as well as functional harmony analysis in classical music.
    ///	
    ///If there are alternate harmonies possible, this can be specified using multiple harmony elements differentiated by type. Explicit harmonies have all note present in the music; implied have some notes missing but implied; alternate represents alternate analyses. 
    ///	
    ///The harmony object may be used for analysis or for chord symbols. The print-object attribute controls whether or not anything is printed due to the harmony element. The print-frame attribute controls printing of a frame or fretboard diagram. The print-style attribute group sets the default for the harmony, but individual elements can override this with their own print-style values.
    /// </para>
    /// <para>
    /// Regular expression: (((root | function), kind, inversion?, bass?, degree*)+, frame?, offset?, (footnote)?, (level)?, (staff)?)
    /// </para>
    /// </summary>
    public harmony() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((root | function), kind, inversion?, bass?, degree*)+, frame?, offset?, (footnote)?, (level)?, (staff)?)
    /// </para>
    /// </summary>
    public IList<root> root {
        get {
            if ((this.rootField == null)) {
                this.rootField = new XTypedList<root>(this, LinqToXsdTypeManager.Instance, XName.Get("root", ""));
            }
            return this.rootField;
        }
        set {
            if ((value == null)) {
                this.rootField = null;
            }
            else {
                if ((this.rootField == null)) {
                    this.rootField = XTypedList<root>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("root", ""));
                }
                else {
                    XTypedServices.SetList<root>(this.rootField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The function element is used to represent classical functional harmony with an indication like I, II, III rather than C, D, E. It is relative to the key that is specified in the MusicXML encoding.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((root | function), kind, inversion?, bass?, degree*)+, frame?, offset?, (footnote)?, (level)?, (staff)?)
    /// </para>
    /// </summary>
    public IList<styletext> function {
        get {
            if ((this.functionField == null)) {
                this.functionField = new XTypedList<styletext>(this, LinqToXsdTypeManager.Instance, XName.Get("function", ""));
            }
            return this.functionField;
        }
        set {
            if ((value == null)) {
                this.functionField = null;
            }
            else {
                if ((this.functionField == null)) {
                    this.functionField = XTypedList<styletext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("function", ""));
                }
                else {
                    XTypedServices.SetList<styletext>(this.functionField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((root | function), kind, inversion?, bass?, degree*)+, frame?, offset?, (footnote)?, (level)?, (staff)?)
    /// </para>
    /// </summary>
    public IList<kind> kind {
        get {
            if ((this.kindField == null)) {
                this.kindField = new XTypedList<kind>(this, LinqToXsdTypeManager.Instance, XName.Get("kind", ""));
            }
            return this.kindField;
        }
        set {
            if ((value == null)) {
                this.kindField = null;
            }
            else {
                if ((this.kindField == null)) {
                    this.kindField = XTypedList<kind>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("kind", ""));
                }
                else {
                    XTypedServices.SetList<kind>(this.kindField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((root | function), kind, inversion?, bass?, degree*)+, frame?, offset?, (footnote)?, (level)?, (staff)?)
    /// </para>
    /// </summary>
    public IList<inversion> inversion {
        get {
            if ((this.inversionField == null)) {
                this.inversionField = new XTypedList<inversion>(this, LinqToXsdTypeManager.Instance, XName.Get("inversion", ""));
            }
            return this.inversionField;
        }
        set {
            if ((value == null)) {
                this.inversionField = null;
            }
            else {
                if ((this.inversionField == null)) {
                    this.inversionField = XTypedList<inversion>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("inversion", ""));
                }
                else {
                    XTypedServices.SetList<inversion>(this.inversionField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((root | function), kind, inversion?, bass?, degree*)+, frame?, offset?, (footnote)?, (level)?, (staff)?)
    /// </para>
    /// </summary>
    public IList<bass> bass {
        get {
            if ((this.bassField == null)) {
                this.bassField = new XTypedList<bass>(this, LinqToXsdTypeManager.Instance, XName.Get("bass", ""));
            }
            return this.bassField;
        }
        set {
            if ((value == null)) {
                this.bassField = null;
            }
            else {
                if ((this.bassField == null)) {
                    this.bassField = XTypedList<bass>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("bass", ""));
                }
                else {
                    XTypedServices.SetList<bass>(this.bassField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((root | function), kind, inversion?, bass?, degree*)+, frame?, offset?, (footnote)?, (level)?, (staff)?)
    /// </para>
    /// </summary>
    public IList<degree> degree {
        get {
            if ((this.degreeField == null)) {
                this.degreeField = new XTypedList<degree>(this, LinqToXsdTypeManager.Instance, XName.Get("degree", ""));
            }
            return this.degreeField;
        }
        set {
            if ((value == null)) {
                this.degreeField = null;
            }
            else {
                if ((this.degreeField == null)) {
                    this.degreeField = XTypedList<degree>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("degree", ""));
                }
                else {
                    XTypedServices.SetList<degree>(this.degreeField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (((root | function), kind, inversion?, bass?, degree*)+, frame?, offset?, (footnote)?, (level)?, (staff)?)
    /// </para>
    /// </summary>
    public frame frame {
        get {
            XElement x = this.GetElement(XName.Get("frame", ""));
            return ((frame)(x));
        }
        set {
            this.SetElement(XName.Get("frame", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (((root | function), kind, inversion?, bass?, degree*)+, frame?, offset?, (footnote)?, (level)?, (staff)?)
    /// </para>
    /// </summary>
    public offset offset {
        get {
            XElement x = this.GetElement(XName.Get("offset", ""));
            return ((offset)(x));
        }
        set {
            this.SetElement(XName.Get("offset", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((root | function), kind, inversion?, bass?, degree*)+, frame?, offset?, (footnote)?, (level)?, (staff)?)
    /// </para>
    /// </summary>
    public formattedtext footnote {
        get {
            XElement x = this.GetElement(XName.Get("footnote", ""));
            return ((formattedtext)(x));
        }
        set {
            this.SetElement(XName.Get("footnote", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((root | function), kind, inversion?, bass?, degree*)+, frame?, offset?, (footnote)?, (level)?, (staff)?)
    /// </para>
    /// </summary>
    public level level {
        get {
            XElement x = this.GetElement(XName.Get("level", ""));
            return ((level)(x));
        }
        set {
            this.SetElement(XName.Get("level", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Staff assignment is only needed for music notated on multiple staves. Used by both notes and directions. Staff values are numbers, with 1 referring to the top-most staff in a part.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((root | function), kind, inversion?, bass?, degree*)+, frame?, offset?, (footnote)?, (level)?, (staff)?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> staff {
        get {
            XElement x = this.GetElement(XName.Get("staff", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetElement(XName.Get("staff", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printframe {
        get {
            XAttribute x = this.Attribute(XName.Get("print-frame", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-frame", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("harmony", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<harmony>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("root", ""), typeof(root));
        localElementDictionary.Add(XName.Get("function", ""), typeof(styletext));
        localElementDictionary.Add(XName.Get("kind", ""), typeof(kind));
        localElementDictionary.Add(XName.Get("inversion", ""), typeof(inversion));
        localElementDictionary.Add(XName.Get("bass", ""), typeof(bass));
        localElementDictionary.Add(XName.Get("degree", ""), typeof(degree));
        localElementDictionary.Add(XName.Get("frame", ""), typeof(frame));
        localElementDictionary.Add(XName.Get("offset", ""), typeof(offset));
        localElementDictionary.Add(XName.Get("footnote", ""), typeof(formattedtext));
        localElementDictionary.Add(XName.Get("level", ""), typeof(level));
        localElementDictionary.Add(XName.Get("staff", ""), typeof(decimal));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The harp-pedals type is used to create harp pedal diagrams. The pedal-step and pedal-alter elements use the same values as the step and alter elements. For easiest reading, the pedal-tuning elements should follow standard harp pedal order, with pedal-step values of D, C, B, E, F, G, and A.
/// </para>
/// <para>
/// Regular expression: (pedaltuning+)
/// </para>
/// </summary>
public partial class harppedals : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<pedaltuning> pedaltuningField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator harppedals(XElement xe) { return XTypedServices.ToXTypedElement<harppedals>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static harppedals() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("pedal-tuning", "")));
    }
    
    /// <summary>
    /// <para>
    /// The harp-pedals type is used to create harp pedal diagrams. The pedal-step and pedal-alter elements use the same values as the step and alter elements. For easiest reading, the pedal-tuning elements should follow standard harp pedal order, with pedal-step values of D, C, B, E, F, G, and A.
    /// </para>
    /// <para>
    /// Regular expression: (pedaltuning+)
    /// </para>
    /// </summary>
    public harppedals() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, repeating
    /// </para>
    /// <para>
    /// Regular expression: (pedaltuning+)
    /// </para>
    /// </summary>
    public IList<pedaltuning> pedaltuning {
        get {
            if ((this.pedaltuningField == null)) {
                this.pedaltuningField = new XTypedList<pedaltuning>(this, LinqToXsdTypeManager.Instance, XName.Get("pedal-tuning", ""));
            }
            return this.pedaltuningField;
        }
        set {
            if ((value == null)) {
                this.pedaltuningField = null;
            }
            else {
                if ((this.pedaltuningField == null)) {
                    this.pedaltuningField = XTypedList<pedaltuning>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("pedal-tuning", ""));
                }
                else {
                    XTypedServices.SetList<pedaltuning>(this.pedaltuningField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("harp-pedals", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<harppedals>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("pedal-tuning", ""), typeof(pedaltuning));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The image type is used to include graphical images in a score.
/// </para>
/// </summary>
public partial class image : XTypedElement, IXMetaData {
    
         public static explicit operator image(XElement xe) { return XTypedServices.ToXTypedElement<image>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The image type is used to include graphical images in a score.
    /// </para>
    /// </summary>
    public image() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public System.Uri source {
        get {
            XAttribute x = this.Attribute(XName.Get("source", ""));
            return XTypedServices.ParseValue<System.Uri>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("source", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("image", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<image>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The inversion type represents harmony inversions. The value is a number indicating which inversion is used: 0 for root position, 1 for first inversion, etc.
/// </para>
/// </summary>
public partial class inversion : XTypedElement, IXMetaData {
    
         public static explicit operator inversion(XElement xe) { return XTypedServices.ToXTypedElement<inversion>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The inversion type represents harmony inversions. The value is a number indicating which inversion is used: 0 for root position, 1 for first inversion, etc.
    /// </para>
    /// </summary>
    public inversion() {
    }
    
    public decimal TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("inversion", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<inversion>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Kind indicates the type of chord. Degree elements can then add, subtract, or alter from these starting points
///	
///The attributes are used to indicate the formatting of the symbol. Since the kind element is the constant in all the harmony-chord groups that can make up a polychord, many formatting attributes are here.
///	
///The use-symbols attribute is yes if the kind should be represented when possible with harmony symbols rather than letters and numbers. These symbols include:
///	
///	major: a triangle, like Unicode 25B3
///	minor: -, like Unicode 002D
///	augmented: +, like Unicode 002B
///	diminished: °, like Unicode 00B0
///	half-diminished: ø, like Unicode 00F8
///	
///For the major-minor kind, only the minor symbol is used when use-symbols is yes. The major symbol is set using the symbol attribute in the degree-value element. The corresponding degree-alter value will usually be 0 in this case.
///
///The text attribute describes how the kind should be spelled in a score. If use-symbols is yes, the value of the text attribute follows the symbol. The stack-degrees attribute is yes if the degree elements should be stacked above each other. The parentheses-degrees attribute is yes if all the degrees should be in parentheses. The bracket-degrees attribute is yes if all the degrees should be in a bracket. If not specified, these values are implementation-specific. The alignment attributes are for the entire harmony-chord group of which this kind element is a part.
/// </para>
/// </summary>
public partial class kind : XTypedElement, IXMetaData {
    
         public static explicit operator kind(XElement xe) { return XTypedServices.ToXTypedElement<kind>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// Kind indicates the type of chord. Degree elements can then add, subtract, or alter from these starting points
    ///	
    ///The attributes are used to indicate the formatting of the symbol. Since the kind element is the constant in all the harmony-chord groups that can make up a polychord, many formatting attributes are here.
    ///	
    ///The use-symbols attribute is yes if the kind should be represented when possible with harmony symbols rather than letters and numbers. These symbols include:
    ///	
    ///	major: a triangle, like Unicode 25B3
    ///	minor: -, like Unicode 002D
    ///	augmented: +, like Unicode 002B
    ///	diminished: °, like Unicode 00B0
    ///	half-diminished: ø, like Unicode 00F8
    ///	
    ///For the major-minor kind, only the minor symbol is used when use-symbols is yes. The major symbol is set using the symbol attribute in the degree-value element. The corresponding degree-alter value will usually be 0 in this case.
    ///
    ///The text attribute describes how the kind should be spelled in a score. If use-symbols is yes, the value of the text attribute follows the symbol. The stack-degrees attribute is yes if the degree elements should be stacked above each other. The parentheses-degrees attribute is yes if all the degrees should be in parentheses. The bracket-degrees attribute is yes if all the degrees should be in a bracket. If not specified, these values are implementation-specific. The alignment attributes are for the entire harmony-chord group of which this kind element is a part.
    /// </para>
    /// </summary>
    public kind() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::kindvalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string usesymbols {
        get {
            XAttribute x = this.Attribute(XName.Get("use-symbols", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("use-symbols", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string text {
        get {
            XAttribute x = this.Attribute(XName.Get("text", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("text", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string stackdegrees {
        get {
            XAttribute x = this.Attribute(XName.Get("stack-degrees", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("stack-degrees", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string parenthesesdegrees {
        get {
            XAttribute x = this.Attribute(XName.Get("parentheses-degrees", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("parentheses-degrees", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string bracketdegrees {
        get {
            XAttribute x = this.Attribute(XName.Get("bracket-degrees", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bracket-degrees", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("kind", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<kind>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The measure-numbering type describes how frequently measure numbers are displayed on this part. The number attribute from the measure element is used for printing. Measures with an implicit attribute set to "yes" never display a measure number, regardless of the measure-numbering setting.
/// </para>
/// </summary>
public partial class measurenumbering : XTypedElement, IXMetaData {
    
         public static explicit operator measurenumbering(XElement xe) { return XTypedServices.ToXTypedElement<measurenumbering>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The measure-numbering type describes how frequently measure numbers are displayed on this part. The number attribute from the measure element is used for printing. Measures with an implicit attribute set to "yes" never display a measure number, regardless of the measure-numbering setting.
    /// </para>
    /// </summary>
    public measurenumbering() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::measurenumberingvalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("measure-numbering", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<measurenumbering>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The metronome type represents metronome marks and other metric relationships. The beat-unit group and per-minute element specify regular metronome marks. The metronome-note and metronome-relation elements allow for the specification of more complicated metric relationships, such as swing tempo marks where two eighths are equated to a quarter note / eighth note triplet. The parentheses attribute indicates whether or not to put the metronome mark in parentheses; its value is no if not specified.
/// </para>
/// <para>
/// Regular expression: ((beatunit, beatunitdot*, (perminute | (beatunit, beatunitdot*)))|(metronomenote+, (metronomerelation, metronomenote+)?))
/// </para>
/// </summary>
public partial class metronome : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<string> beatunitField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> beatunitdotField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<metronomenote> metronomenoteField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator metronome(XElement xe) { return XTypedServices.ToXTypedElement<metronome>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static metronome() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The metronome type represents metronome marks and other metric relationships. The beat-unit group and per-minute element specify regular metronome marks. The metronome-note and metronome-relation elements allow for the specification of more complicated metric relationships, such as swing tempo marks where two eighths are equated to a quarter note / eighth note triplet. The parentheses attribute indicates whether or not to put the metronome mark in parentheses; its value is no if not specified.
    /// </para>
    /// <para>
    /// Regular expression: ((beatunit, beatunitdot*, (perminute | (beatunit, beatunitdot*)))|(metronomenote+, (metronomerelation, metronomenote+)?))
    /// </para>
    /// </summary>
    public metronome() {
    }
    
    /// <summary>
    /// <para>
    /// The beat-unit element indicates the graphical note type to use in a metronome mark.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((beatunit, beatunitdot*, (perminute | (beatunit, beatunitdot*)))|(metronomenote+, (metronomerelation, metronomenote+)?))
    /// </para>
    /// </summary>
    public IList<string> beatunit {
        get {
            if ((this.beatunitField == null)) {
                this.beatunitField = new XSimpleList<string>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, XName.Get("beat-unit", ""));
            }
            return this.beatunitField;
        }
        set {
            if ((value == null)) {
                this.beatunitField = null;
            }
            else {
                if ((this.beatunitField == null)) {
                    this.beatunitField = XSimpleList<string>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, value, XName.Get("beat-unit", ""));
                }
                else {
                    XTypedServices.SetList<System.String>(this.beatunitField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The beat-unit-dot element is used to specify any augmentation dots for a metronome mark note.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((beatunit, beatunitdot*, (perminute | (beatunit, beatunitdot*)))|(metronomenote+, (metronomerelation, metronomenote+)?))
    /// </para>
    /// </summary>
    public IList<empty> beatunitdot {
        get {
            if ((this.beatunitdotField == null)) {
                this.beatunitdotField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("beat-unit-dot", ""));
            }
            return this.beatunitdotField;
        }
        set {
            if ((value == null)) {
                this.beatunitdotField = null;
            }
            else {
                if ((this.beatunitdotField == null)) {
                    this.beatunitdotField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("beat-unit-dot", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.beatunitdotField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((beatunit, beatunitdot*, (perminute | (beatunit, beatunitdot*)))|(metronomenote+, (metronomerelation, metronomenote+)?))
    /// </para>
    /// </summary>
    public perminute perminute {
        get {
            XElement x = this.GetElement(XName.Get("per-minute", ""));
            return ((perminute)(x));
        }
        set {
            this.SetElement(XName.Get("per-minute", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, repeating
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((beatunit, beatunitdot*, (perminute | (beatunit, beatunitdot*)))|(metronomenote+, (metronomerelation, metronomenote+)?))
    /// </para>
    /// </summary>
    public IList<metronomenote> metronomenote {
        get {
            if ((this.metronomenoteField == null)) {
                this.metronomenoteField = new XTypedList<metronomenote>(this, LinqToXsdTypeManager.Instance, XName.Get("metronome-note", ""));
            }
            return this.metronomenoteField;
        }
        set {
            if ((value == null)) {
                this.metronomenoteField = null;
            }
            else {
                if ((this.metronomenoteField == null)) {
                    this.metronomenoteField = XTypedList<metronomenote>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("metronome-note", ""));
                }
                else {
                    XTypedServices.SetList<metronomenote>(this.metronomenoteField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The metronome-relation element describes the relationship symbol that goes between the two sets of metronome-note elements. The currently allowed value is equals, but this may expand in future versions. If the element is empty, the equals value is used.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((beatunit, beatunitdot*, (perminute | (beatunit, beatunitdot*)))|(metronomenote+, (metronomerelation, metronomenote+)?))
    /// </para>
    /// </summary>
    public string metronomerelation {
        get {
            XElement x = this.GetElement(XName.Get("metronome-relation", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("metronome-relation", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string justify {
        get {
            XAttribute x = this.Attribute(XName.Get("justify", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("justify", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string parentheses {
        get {
            XAttribute x = this.Attribute(XName.Get("parentheses", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("parentheses", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("metronome", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<metronome>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("beat-unit", ""), typeof(string));
        localElementDictionary.Add(XName.Get("beat-unit-dot", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("per-minute", ""), typeof(perminute));
        localElementDictionary.Add(XName.Get("metronome-note", ""), typeof(metronomenote));
        localElementDictionary.Add(XName.Get("metronome-relation", ""), typeof(string));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The metronome-beam type works like the beam type in defining metric relationships, but does not include all the attributes available in the beam type.
/// </para>
/// </summary>
public partial class metronomebeam : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static decimal numberDefaultValue = System.Xml.XmlConvert.ToDecimal("1");
    
         public static explicit operator metronomebeam(XElement xe) { return XTypedServices.ToXTypedElement<metronomebeam>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The metronome-beam type works like the beam type in defining metric relationships, but does not include all the attributes available in the beam type.
    /// </para>
    /// </summary>
    public metronomebeam() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::beamvalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public decimal number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype, numberDefaultValue);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("metronome-beam", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<metronomebeam>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The metronome-note type defines the appearance of a note within a metric relationship mark.
/// </para>
/// <para>
/// Regular expression: (metronometype, metronomedot*, metronomebeam*, metronometuplet?)
/// </para>
/// </summary>
public partial class metronomenote : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> metronomedotField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<metronomebeam> metronomebeamField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator metronomenote(XElement xe) { return XTypedServices.ToXTypedElement<metronomenote>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static metronomenote() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("metronome-type", "")), new NamedContentModelEntity(XName.Get("metronome-dot", "")), new NamedContentModelEntity(XName.Get("metronome-beam", "")), new NamedContentModelEntity(XName.Get("metronome-tuplet", "")));
    }
    
    /// <summary>
    /// <para>
    /// The metronome-note type defines the appearance of a note within a metric relationship mark.
    /// </para>
    /// <para>
    /// Regular expression: (metronometype, metronomedot*, metronomebeam*, metronometuplet?)
    /// </para>
    /// </summary>
    public metronomenote() {
    }
    
    /// <summary>
    /// <para>
    /// The metronome-type element works like the type element in defining metric relationships.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (metronometype, metronomedot*, metronomebeam*, metronometuplet?)
    /// </para>
    /// </summary>
    public string metronometype {
        get {
            XElement x = this.GetElement(XName.Get("metronome-type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("metronome-type", ""), value, "metronometype", global::notetypevalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The metronome-dot element works like the dot element in defining metric relationships.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (metronometype, metronomedot*, metronomebeam*, metronometuplet?)
    /// </para>
    /// </summary>
    public IList<empty> metronomedot {
        get {
            if ((this.metronomedotField == null)) {
                this.metronomedotField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("metronome-dot", ""));
            }
            return this.metronomedotField;
        }
        set {
            if ((value == null)) {
                this.metronomedotField = null;
            }
            else {
                if ((this.metronomedotField == null)) {
                    this.metronomedotField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("metronome-dot", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.metronomedotField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (metronometype, metronomedot*, metronomebeam*, metronometuplet?)
    /// </para>
    /// </summary>
    public IList<metronomebeam> metronomebeam {
        get {
            if ((this.metronomebeamField == null)) {
                this.metronomebeamField = new XTypedList<metronomebeam>(this, LinqToXsdTypeManager.Instance, XName.Get("metronome-beam", ""));
            }
            return this.metronomebeamField;
        }
        set {
            if ((value == null)) {
                this.metronomebeamField = null;
            }
            else {
                if ((this.metronomebeamField == null)) {
                    this.metronomebeamField = XTypedList<metronomebeam>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("metronome-beam", ""));
                }
                else {
                    XTypedServices.SetList<metronomebeam>(this.metronomebeamField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (metronometype, metronomedot*, metronomebeam*, metronometuplet?)
    /// </para>
    /// </summary>
    public metronometuplet metronometuplet {
        get {
            XElement x = this.GetElement(XName.Get("metronome-tuplet", ""));
            return ((metronometuplet)(x));
        }
        set {
            this.SetElement(XName.Get("metronome-tuplet", ""), value);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("metronome-note", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<metronomenote>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("metronome-type", ""), typeof(string));
        localElementDictionary.Add(XName.Get("metronome-dot", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("metronome-beam", ""), typeof(metronomebeam));
        localElementDictionary.Add(XName.Get("metronome-tuplet", ""), typeof(metronometuplet));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The metronome-tuplet type uses the same element structure as the time-modification element along with some attributes from the tuplet element.
/// </para>
/// <para>
/// Regular expression: (actualnotes, normalnotes, (normaltype, normaldot*)?)
/// </para>
/// </summary>
public partial class metronometuplet : global::timemodification, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator metronometuplet(XElement xe) { return XTypedServices.ToXTypedElement<metronometuplet>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static metronometuplet() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The metronome-tuplet type uses the same element structure as the time-modification element along with some attributes from the tuplet element.
    /// </para>
    /// <para>
    /// Regular expression: (actualnotes, normalnotes, (normaltype, normaldot*)?)
    /// </para>
    /// </summary>
    public metronometuplet() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string bracket {
        get {
            XAttribute x = this.Attribute(XName.Get("bracket", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bracket", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string shownumber {
        get {
            XAttribute x = this.Attribute(XName.Get("show-number", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("show-number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("metronome-tuplet", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<metronometuplet>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("actual-notes", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("normal-notes", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("normal-type", ""), typeof(string));
        localElementDictionary.Add(XName.Get("normal-dot", ""), typeof(empty));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The octave shift type indicates where notes are shifted up or down from their true pitched values because of printing difficulty. Thus a treble clef line noted with 8va will be indicated with an octave-shift down from the pitch data indicated in the notes. A size of 8 indicates one octave; a size of 15 indicates two octaves.
/// </para>
/// </summary>
public partial class octaveshift : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static decimal sizeDefaultValue = System.Xml.XmlConvert.ToDecimal("8");
    
         public static explicit operator octaveshift(XElement xe) { return XTypedServices.ToXTypedElement<octaveshift>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The octave shift type indicates where notes are shifted up or down from their true pitched values because of printing difficulty. Thus a treble clef line noted with 8va will be indicated with an octave-shift down from the pitch data indicated in the notes. A size of 8 indicates one octave; a size of 15 indicates two octaves.
    /// </para>
    /// </summary>
    public octaveshift() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public decimal size {
        get {
            XAttribute x = this.Attribute(XName.Get("size", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype, sizeDefaultValue);
        }
        set {
            this.SetAttribute(XName.Get("size", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> dashlength {
        get {
            XAttribute x = this.Attribute(XName.Get("dash-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dash-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> spacelength {
        get {
            XAttribute x = this.Attribute(XName.Get("space-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("space-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("octave-shift", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<octaveshift>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// An offset is represented in terms of divisions, and indicates where the direction will appear relative to the current musical location. This affects the visual appearance of the direction. If the sound attribute is "yes", then the offset affects playback too. If the sound attribute is "no", then any sound associated with the direction takes effect at the current location. The sound attribute is "no" by default for compatibility with earlier versions of the MusicXML format. If an element within a direction includes a default-x attribute, the offset value will be ignored when determining the appearance of that element.
/// </para>
/// </summary>
public partial class offset : XTypedElement, IXMetaData {
    
         public static explicit operator offset(XElement xe) { return XTypedServices.ToXTypedElement<offset>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// An offset is represented in terms of divisions, and indicates where the direction will appear relative to the current musical location. This affects the visual appearance of the direction. If the sound attribute is "yes", then the offset affects playback too. If the sound attribute is "no", then any sound associated with the direction takes effect at the current location. The sound attribute is "no" by default for compatibility with earlier versions of the MusicXML format. If an element within a direction includes a default-x attribute, the offset value will be ignored when determining the appearance of that element.
    /// </para>
    /// </summary>
    public offset() {
    }
    
    public decimal TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::divisions.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string sound {
        get {
            XAttribute x = this.Attribute(XName.Get("sound", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("sound", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("offset", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<offset>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The other-direction type is used to define any direction symbols not yet in the current version of the MusicXML format. This allows extended representation, though without application interoperability.
/// </para>
/// </summary>
public partial class otherdirection : XTypedElement, IXMetaData {
    
         public static explicit operator otherdirection(XElement xe) { return XTypedServices.ToXTypedElement<otherdirection>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The other-direction type is used to define any direction symbols not yet in the current version of the MusicXML format. This allows extended representation, though without application interoperability.
    /// </para>
    /// </summary>
    public otherdirection() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("other-direction", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<otherdirection>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The pedal type represents piano pedal marks. The line attribute is yes if pedal lines are used. The sign attribute is yes if Ped and * signs are used. For MusicXML 2.0 compatibility, the sign attribute is yes by default if the line attribute is no, and is no by default if the line attribute is yes. The change and continue types are used when the line attribute is yes. The change type indicates a pedal lift and retake indicated with an inverted V marking. The continue type allows more precise formatting across system breaks and for more complex pedaling lines. The alignment attributes are ignored if the line attribute is yes.
/// </para>
/// </summary>
public partial class pedal : XTypedElement, IXMetaData {
    
         public static explicit operator pedal(XElement xe) { return XTypedServices.ToXTypedElement<pedal>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The pedal type represents piano pedal marks. The line attribute is yes if pedal lines are used. The sign attribute is yes if Ped and * signs are used. For MusicXML 2.0 compatibility, the sign attribute is yes by default if the line attribute is no, and is no by default if the line attribute is yes. The change and continue types are used when the line attribute is yes. The change type indicates a pedal lift and retake indicated with an inverted V marking. The continue type allows more precise formatting across system breaks and for more complex pedaling lines. The alignment attributes are ignored if the line attribute is yes.
    /// </para>
    /// </summary>
    public pedal() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string line {
        get {
            XAttribute x = this.Attribute(XName.Get("line", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string sign {
        get {
            XAttribute x = this.Attribute(XName.Get("sign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("sign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("pedal", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<pedal>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The pedal-tuning type specifies the tuning of a single harp pedal.
/// </para>
/// <para>
/// Regular expression: (pedalstep, pedalalter)
/// </para>
/// </summary>
public partial class pedaltuning : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator pedaltuning(XElement xe) { return XTypedServices.ToXTypedElement<pedaltuning>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static pedaltuning() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("pedal-step", "")), new NamedContentModelEntity(XName.Get("pedal-alter", "")));
    }
    
    /// <summary>
    /// <para>
    /// The pedal-tuning type specifies the tuning of a single harp pedal.
    /// </para>
    /// <para>
    /// Regular expression: (pedalstep, pedalalter)
    /// </para>
    /// </summary>
    public pedaltuning() {
    }
    
    /// <summary>
    /// <para>
    /// The pedal-step element defines the pitch step for a single harp pedal.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (pedalstep, pedalalter)
    /// </para>
    /// </summary>
    public string pedalstep {
        get {
            XElement x = this.GetElement(XName.Get("pedal-step", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("pedal-step", ""), value, "pedalstep", global::step.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The pedal-alter element defines the chromatic alteration for a single harp pedal.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (pedalstep, pedalalter)
    /// </para>
    /// </summary>
    public decimal pedalalter {
        get {
            XElement x = this.GetElement(XName.Get("pedal-alter", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("pedal-alter", ""), value, "pedalalter", global::semitones.TypeDefinition);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("pedal-tuning", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<pedaltuning>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("pedal-step", ""), typeof(string));
        localElementDictionary.Add(XName.Get("pedal-alter", ""), typeof(decimal));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The per-minute type can be a number, or a text description including numbers. If a font is specified, it overrides the font specified for the overall metronome element. This allows separate specification of a music font for the beat-unit and a text font for the numeric value, in cases where a single metronome font is not used.
/// </para>
/// </summary>
public partial class perminute : XTypedElement, IXMetaData {
    
         public static explicit operator perminute(XElement xe) { return XTypedServices.ToXTypedElement<perminute>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The per-minute type can be a number, or a text description including numbers. If a font is specified, it overrides the font specified for the overall metronome element. This allows separate specification of a music font for the beat-unit and a text font for the numeric value, in cases where a single metronome font is not used.
    /// </para>
    /// </summary>
    public perminute() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("per-minute", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<perminute>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The percussion element is used to define percussion pictogram symbols. Definitions for these symbols can be found in Kurt Stone's "Music Notation in the Twentieth Century" on pages 206-212 and 223. Some values are added to these based on how usage has evolved in the 30 years since Stone's book was published.
/// </para>
/// <para>
/// Regular expression: (glass | metal | wood | pitched | membrane | effect | timpani | beater | stick | sticklocation | otherpercussion)
/// </para>
/// </summary>
public partial class percussion : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator percussion(XElement xe) { return XTypedServices.ToXTypedElement<percussion>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static percussion() {
        BuildElementDictionary();
        contentModel = new ChoiceContentModelEntity(new NamedContentModelEntity(XName.Get("glass", "")), new NamedContentModelEntity(XName.Get("metal", "")), new NamedContentModelEntity(XName.Get("wood", "")), new NamedContentModelEntity(XName.Get("pitched", "")), new NamedContentModelEntity(XName.Get("membrane", "")), new NamedContentModelEntity(XName.Get("effect", "")), new NamedContentModelEntity(XName.Get("timpani", "")), new NamedContentModelEntity(XName.Get("beater", "")), new NamedContentModelEntity(XName.Get("stick", "")), new NamedContentModelEntity(XName.Get("stick-location", "")), new NamedContentModelEntity(XName.Get("other-percussion", "")));
    }
    
    /// <summary>
    /// <para>
    /// The percussion element is used to define percussion pictogram symbols. Definitions for these symbols can be found in Kurt Stone's "Music Notation in the Twentieth Century" on pages 206-212 and 223. Some values are added to these based on how usage has evolved in the 30 years since Stone's book was published.
    /// </para>
    /// <para>
    /// Regular expression: (glass | metal | wood | pitched | membrane | effect | timpani | beater | stick | sticklocation | otherpercussion)
    /// </para>
    /// </summary>
    public percussion() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (glass | metal | wood | pitched | membrane | effect | timpani | beater | stick | sticklocation | otherpercussion)
    /// </para>
    /// </summary>
    public string glass {
        get {
            XElement x = this.GetElement(XName.Get("glass", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("glass", ""), value, "glass", global::glass.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (glass | metal | wood | pitched | membrane | effect | timpani | beater | stick | sticklocation | otherpercussion)
    /// </para>
    /// </summary>
    public string metal {
        get {
            XElement x = this.GetElement(XName.Get("metal", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("metal", ""), value, "metal", global::metal.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (glass | metal | wood | pitched | membrane | effect | timpani | beater | stick | sticklocation | otherpercussion)
    /// </para>
    /// </summary>
    public string wood {
        get {
            XElement x = this.GetElement(XName.Get("wood", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("wood", ""), value, "wood", global::wood.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (glass | metal | wood | pitched | membrane | effect | timpani | beater | stick | sticklocation | otherpercussion)
    /// </para>
    /// </summary>
    public string pitched {
        get {
            XElement x = this.GetElement(XName.Get("pitched", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("pitched", ""), value, "pitched", global::pitched.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (glass | metal | wood | pitched | membrane | effect | timpani | beater | stick | sticklocation | otherpercussion)
    /// </para>
    /// </summary>
    public string membrane {
        get {
            XElement x = this.GetElement(XName.Get("membrane", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("membrane", ""), value, "membrane", global::membrane.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (glass | metal | wood | pitched | membrane | effect | timpani | beater | stick | sticklocation | otherpercussion)
    /// </para>
    /// </summary>
    public string effect {
        get {
            XElement x = this.GetElement(XName.Get("effect", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("effect", ""), value, "effect", global::effect.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (glass | metal | wood | pitched | membrane | effect | timpani | beater | stick | sticklocation | otherpercussion)
    /// </para>
    /// </summary>
    public empty timpani {
        get {
            XElement x = this.GetElement(XName.Get("timpani", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("timpani", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (glass | metal | wood | pitched | membrane | effect | timpani | beater | stick | sticklocation | otherpercussion)
    /// </para>
    /// </summary>
    public beater beater {
        get {
            XElement x = this.GetElement(XName.Get("beater", ""));
            return ((beater)(x));
        }
        set {
            this.SetElement(XName.Get("beater", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (glass | metal | wood | pitched | membrane | effect | timpani | beater | stick | sticklocation | otherpercussion)
    /// </para>
    /// </summary>
    public stick stick {
        get {
            XElement x = this.GetElement(XName.Get("stick", ""));
            return ((stick)(x));
        }
        set {
            this.SetElement(XName.Get("stick", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (glass | metal | wood | pitched | membrane | effect | timpani | beater | stick | sticklocation | otherpercussion)
    /// </para>
    /// </summary>
    public string sticklocation {
        get {
            XElement x = this.GetElement(XName.Get("stick-location", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("stick-location", ""), value, "sticklocation", global::sticklocation.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (glass | metal | wood | pitched | membrane | effect | timpani | beater | stick | sticklocation | otherpercussion)
    /// </para>
    /// </summary>
    public string otherpercussion {
        get {
            XElement x = this.GetElement(XName.Get("other-percussion", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("other-percussion", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string enclosure {
        get {
            XAttribute x = this.Attribute(XName.Get("enclosure", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("enclosure", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("percussion", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<percussion>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("glass", ""), typeof(string));
        localElementDictionary.Add(XName.Get("metal", ""), typeof(string));
        localElementDictionary.Add(XName.Get("wood", ""), typeof(string));
        localElementDictionary.Add(XName.Get("pitched", ""), typeof(string));
        localElementDictionary.Add(XName.Get("membrane", ""), typeof(string));
        localElementDictionary.Add(XName.Get("effect", ""), typeof(string));
        localElementDictionary.Add(XName.Get("timpani", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("beater", ""), typeof(beater));
        localElementDictionary.Add(XName.Get("stick", ""), typeof(stick));
        localElementDictionary.Add(XName.Get("stick-location", ""), typeof(string));
        localElementDictionary.Add(XName.Get("other-percussion", ""), typeof(string));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The principal-voice element represents principal and secondary voices in a score, either for analysis or for square bracket symbols that appear in a score. The symbol attribute indicates the type of symbol used at the start of the principal-voice. The content of the principal-voice element is used for analysis and may be any text value. When used for analysis separate from any printed score markings, the symbol attribute should be set to "none".
/// </para>
/// </summary>
public partial class principalvoice : XTypedElement, IXMetaData {
    
         public static explicit operator principalvoice(XElement xe) { return XTypedServices.ToXTypedElement<principalvoice>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The principal-voice element represents principal and secondary voices in a score, either for analysis or for square bracket symbols that appear in a score. The symbol attribute indicates the type of symbol used at the start of the principal-voice. The content of the principal-voice element is used for analysis and may be any text value. When used for analysis separate from any printed score markings, the symbol attribute should be set to "none".
    /// </para>
    /// </summary>
    public principalvoice() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string symbol {
        get {
            XAttribute x = this.Attribute(XName.Get("symbol", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("symbol", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("principal-voice", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<principalvoice>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The print type contains general printing parameters, including the layout elements defined in the layout.mod file. The part-name-display and part-abbreviation-display elements used in the score.mod file may also be used here to change how a part name or abbreviation is displayed over the course of a piece. They take effect when the current measure or a succeeding measure starts a new system.
///	
///Layout elements in a print statement only apply to the current page, system, staff, or measure. Music that follows continues to take the default values from the layout included in the defaults element.
/// </para>
/// <para>
/// Regular expression: (pagelayout?, systemlayout?, stafflayout*, measurelayout?, measurenumbering?, partnamedisplay?, partabbreviationdisplay?)
/// </para>
/// </summary>
public partial class print : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<stafflayout> stafflayoutField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator print(XElement xe) { return XTypedServices.ToXTypedElement<print>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static print() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("page-layout", "")), new NamedContentModelEntity(XName.Get("system-layout", "")), new NamedContentModelEntity(XName.Get("staff-layout", "")), new NamedContentModelEntity(XName.Get("measure-layout", "")), new NamedContentModelEntity(XName.Get("measure-numbering", "")), new NamedContentModelEntity(XName.Get("part-name-display", "")), new NamedContentModelEntity(XName.Get("part-abbreviation-display", "")));
    }
    
    /// <summary>
    /// <para>
    /// The print type contains general printing parameters, including the layout elements defined in the layout.mod file. The part-name-display and part-abbreviation-display elements used in the score.mod file may also be used here to change how a part name or abbreviation is displayed over the course of a piece. They take effect when the current measure or a succeeding measure starts a new system.
    ///	
    ///Layout elements in a print statement only apply to the current page, system, staff, or measure. Music that follows continues to take the default values from the layout included in the defaults element.
    /// </para>
    /// <para>
    /// Regular expression: (pagelayout?, systemlayout?, stafflayout*, measurelayout?, measurenumbering?, partnamedisplay?, partabbreviationdisplay?)
    /// </para>
    /// </summary>
    public print() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (pagelayout?, systemlayout?, stafflayout*, measurelayout?, measurenumbering?, partnamedisplay?, partabbreviationdisplay?)
    /// </para>
    /// </summary>
    public pagelayout pagelayout {
        get {
            XElement x = this.GetElement(XName.Get("page-layout", ""));
            return ((pagelayout)(x));
        }
        set {
            this.SetElement(XName.Get("page-layout", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (pagelayout?, systemlayout?, stafflayout*, measurelayout?, measurenumbering?, partnamedisplay?, partabbreviationdisplay?)
    /// </para>
    /// </summary>
    public systemlayout systemlayout {
        get {
            XElement x = this.GetElement(XName.Get("system-layout", ""));
            return ((systemlayout)(x));
        }
        set {
            this.SetElement(XName.Get("system-layout", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (pagelayout?, systemlayout?, stafflayout*, measurelayout?, measurenumbering?, partnamedisplay?, partabbreviationdisplay?)
    /// </para>
    /// </summary>
    public IList<stafflayout> stafflayout {
        get {
            if ((this.stafflayoutField == null)) {
                this.stafflayoutField = new XTypedList<stafflayout>(this, LinqToXsdTypeManager.Instance, XName.Get("staff-layout", ""));
            }
            return this.stafflayoutField;
        }
        set {
            if ((value == null)) {
                this.stafflayoutField = null;
            }
            else {
                if ((this.stafflayoutField == null)) {
                    this.stafflayoutField = XTypedList<stafflayout>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("staff-layout", ""));
                }
                else {
                    XTypedServices.SetList<stafflayout>(this.stafflayoutField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (pagelayout?, systemlayout?, stafflayout*, measurelayout?, measurenumbering?, partnamedisplay?, partabbreviationdisplay?)
    /// </para>
    /// </summary>
    public measurelayout measurelayout {
        get {
            XElement x = this.GetElement(XName.Get("measure-layout", ""));
            return ((measurelayout)(x));
        }
        set {
            this.SetElement(XName.Get("measure-layout", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (pagelayout?, systemlayout?, stafflayout*, measurelayout?, measurenumbering?, partnamedisplay?, partabbreviationdisplay?)
    /// </para>
    /// </summary>
    public measurenumbering measurenumbering {
        get {
            XElement x = this.GetElement(XName.Get("measure-numbering", ""));
            return ((measurenumbering)(x));
        }
        set {
            this.SetElement(XName.Get("measure-numbering", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (pagelayout?, systemlayout?, stafflayout*, measurelayout?, measurenumbering?, partnamedisplay?, partabbreviationdisplay?)
    /// </para>
    /// </summary>
    public namedisplay partnamedisplay {
        get {
            XElement x = this.GetElement(XName.Get("part-name-display", ""));
            return ((namedisplay)(x));
        }
        set {
            this.SetElement(XName.Get("part-name-display", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (pagelayout?, systemlayout?, stafflayout*, measurelayout?, measurenumbering?, partnamedisplay?, partabbreviationdisplay?)
    /// </para>
    /// </summary>
    public namedisplay partabbreviationdisplay {
        get {
            XElement x = this.GetElement(XName.Get("part-abbreviation-display", ""));
            return ((namedisplay)(x));
        }
        set {
            this.SetElement(XName.Get("part-abbreviation-display", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> staffspacing {
        get {
            XAttribute x = this.Attribute(XName.Get("staff-spacing", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("staff-spacing", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string newsystem {
        get {
            XAttribute x = this.Attribute(XName.Get("new-system", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("new-system", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string newpage {
        get {
            XAttribute x = this.Attribute(XName.Get("new-page", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("new-page", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> blankpage {
        get {
            XAttribute x = this.Attribute(XName.Get("blank-page", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("blank-page", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string pagenumber {
        get {
            XAttribute x = this.Attribute(XName.Get("page-number", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("page-number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("print", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<print>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("page-layout", ""), typeof(pagelayout));
        localElementDictionary.Add(XName.Get("system-layout", ""), typeof(systemlayout));
        localElementDictionary.Add(XName.Get("staff-layout", ""), typeof(stafflayout));
        localElementDictionary.Add(XName.Get("measure-layout", ""), typeof(measurelayout));
        localElementDictionary.Add(XName.Get("measure-numbering", ""), typeof(measurenumbering));
        localElementDictionary.Add(XName.Get("part-name-display", ""), typeof(namedisplay));
        localElementDictionary.Add(XName.Get("part-abbreviation-display", ""), typeof(namedisplay));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The root type indicates a pitch like C, D, E vs. a function indication like I, II, III. It is used with chord symbols in popular music. The root element has a root-step and optional root-alter element similar to the step and alter elements, but renamed to distinguish the different musical meanings.
/// </para>
/// <para>
/// Regular expression: (rootstep, rootalter?)
/// </para>
/// </summary>
public partial class root : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator root(XElement xe) { return XTypedServices.ToXTypedElement<root>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static root() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("root-step", "")), new NamedContentModelEntity(XName.Get("root-alter", "")));
    }
    
    /// <summary>
    /// <para>
    /// The root type indicates a pitch like C, D, E vs. a function indication like I, II, III. It is used with chord symbols in popular music. The root element has a root-step and optional root-alter element similar to the step and alter elements, but renamed to distinguish the different musical meanings.
    /// </para>
    /// <para>
    /// Regular expression: (rootstep, rootalter?)
    /// </para>
    /// </summary>
    public root() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (rootstep, rootalter?)
    /// </para>
    /// </summary>
    public rootstep rootstep {
        get {
            XElement x = this.GetElement(XName.Get("root-step", ""));
            return ((rootstep)(x));
        }
        set {
            this.SetElement(XName.Get("root-step", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (rootstep, rootalter?)
    /// </para>
    /// </summary>
    public rootalter rootalter {
        get {
            XElement x = this.GetElement(XName.Get("root-alter", ""));
            return ((rootalter)(x));
        }
        set {
            this.SetElement(XName.Get("root-alter", ""), value);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("root", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<root>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("root-step", ""), typeof(rootstep));
        localElementDictionary.Add(XName.Get("root-alter", ""), typeof(rootalter));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The root-alter type represents the chromatic alteration of the root of the current chord within the harmony element. In some chord styles, the text for the root-step element may include root-alter information. In that case, the print-object attribute of the root-alter element can be set to no. The location attribute indicates whether the alteration should appear to the left or the right of the root-step; it is right by default.
/// </para>
/// </summary>
public partial class rootalter : XTypedElement, IXMetaData {
    
         public static explicit operator rootalter(XElement xe) { return XTypedServices.ToXTypedElement<rootalter>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The root-alter type represents the chromatic alteration of the root of the current chord within the harmony element. In some chord styles, the text for the root-step element may include root-alter information. In that case, the print-object attribute of the root-alter element can be set to no. The location attribute indicates whether the alteration should appear to the left or the right of the root-step; it is right by default.
    /// </para>
    /// </summary>
    public rootalter() {
    }
    
    public decimal TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::semitones.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string location {
        get {
            XAttribute x = this.Attribute(XName.Get("location", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("location", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("root-alter", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<rootalter>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The root-step type represents the pitch step of the root of the current chord within the harmony element. The text attribute indicates how the root should appear in a score if not using the element contents.
/// </para>
/// </summary>
public partial class rootstep : XTypedElement, IXMetaData {
    
         public static explicit operator rootstep(XElement xe) { return XTypedServices.ToXTypedElement<rootstep>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The root-step type represents the pitch step of the root of the current chord within the harmony element. The text attribute indicates how the root should appear in a score if not using the element contents.
    /// </para>
    /// </summary>
    public rootstep() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::step.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string text {
        get {
            XAttribute x = this.Attribute(XName.Get("text", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("text", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("root-step", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<rootstep>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Scordatura string tunings are represented by a series of accord elements, similar to the staff-tuning elements. Strings are numbered from high to low.
/// </para>
/// <para>
/// Regular expression: (accord+)
/// </para>
/// </summary>
public partial class scordatura : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<accord> accordField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator scordatura(XElement xe) { return XTypedServices.ToXTypedElement<scordatura>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static scordatura() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("accord", "")));
    }
    
    /// <summary>
    /// <para>
    /// Scordatura string tunings are represented by a series of accord elements, similar to the staff-tuning elements. Strings are numbered from high to low.
    /// </para>
    /// <para>
    /// Regular expression: (accord+)
    /// </para>
    /// </summary>
    public scordatura() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, repeating
    /// </para>
    /// <para>
    /// Regular expression: (accord+)
    /// </para>
    /// </summary>
    public IList<accord> accord {
        get {
            if ((this.accordField == null)) {
                this.accordField = new XTypedList<accord>(this, LinqToXsdTypeManager.Instance, XName.Get("accord", ""));
            }
            return this.accordField;
        }
        set {
            if ((value == null)) {
                this.accordField = null;
            }
            else {
                if ((this.accordField == null)) {
                    this.accordField = XTypedList<accord>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("accord", ""));
                }
                else {
                    XTypedServices.SetList<accord>(this.accordField, value);
                }
            }
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("scordatura", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<scordatura>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("accord", ""), typeof(accord));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The sound element contains general playback parameters. They can stand alone within a part/measure, or be a component element within a direction.
///	
///Tempo is expressed in quarter notes per minute. If 0, the sound-generating program should prompt the user at the time of compiling a sound (MIDI) file.
///	
///Dynamics (or MIDI velocity) are expressed as a percentage of the default forte value (90 for MIDI 1.0).
///	
///Dacapo indicates to go back to the beginning of the movement. When used it always has the value "yes".
///	
///Segno and dalsegno are used for backwards jumps to a segno sign; coda and tocoda are used for forward jumps to a coda sign. If there are multiple jumps, the value of these parameters can be used to name and distinguish them. If segno or coda is used, the divisions attribute can also be used to indicate the number of divisions per quarter note. Otherwise sound and MIDI generating programs may have to recompute this.
///	
///By default, a dalsegno or dacapo attribute indicates that the jump should occur the first time through, while a tocoda attribute indicates the jump should occur the second time through. The time that jumps occur can be changed by using the time-only attribute.
///	
///Forward-repeat is used when a forward repeat sign is implied, and usually follows a bar line. When used it always has the value of "yes".
///	
///The fine attribute follows the final note or rest in a movement with a da capo or dal segno direction. If numeric, the value represents the actual duration of the final note or rest, which can be ambiguous in written notation and different among parts and voices. The value may also be "yes" to indicate no change to the final duration.
///	
///If the sound element applies only particular times through a repeat, the time-only attribute indicates which times to apply the sound element.
///	
///Pizzicato in a sound element effects all following notes. Yes indicates pizzicato, no indicates arco.
///
///The pan and elevation attributes are deprecated in Version 2.0. The pan and elevation elements in the midi-instrument element should be used instead. The meaning of the pan and elevation attributes is the same as for the pan and elevation elements. If both are present, the mid-instrument elements take priority.
///	
///The damper-pedal, soft-pedal, and sostenuto-pedal attributes effect playback of the three common piano pedals and their MIDI controller equivalents. The yes value indicates the pedal is depressed; no indicates the pedal is released. A numeric value from 0 to 100 may also be used for half pedaling. This value is the percentage that the pedal is depressed. A value of 0 is equivalent to no, and a value of 100 is equivalent to yes.
///	
///MIDI devices, MIDI instruments, and playback techniques are changed using the midi-device, midi-instrument, and play elements. When there are multiple instances of these elements, they should be grouped together by instrument using the id attribute values.
///
///The offset element is used to indicate that the sound takes place offset from the current score position. If the sound element is a child of a direction element, the sound offset element overrides the direction offset element if both elements are present. Note that the offset reflects the intended musical position for the change in sound. It should not be used to compensate for latency issues in particular hardware configurations.
/// </para>
/// <para>
/// Regular expression: ((mididevice?, midiinstrument?, play?)*, offset?)
/// </para>
/// </summary>
public partial class sound : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<mididevice> midideviceField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<midiinstrument> midiinstrumentField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<play> playField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator sound(XElement xe) { return XTypedServices.ToXTypedElement<sound>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static sound() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The sound element contains general playback parameters. They can stand alone within a part/measure, or be a component element within a direction.
    ///	
    ///Tempo is expressed in quarter notes per minute. If 0, the sound-generating program should prompt the user at the time of compiling a sound (MIDI) file.
    ///	
    ///Dynamics (or MIDI velocity) are expressed as a percentage of the default forte value (90 for MIDI 1.0).
    ///	
    ///Dacapo indicates to go back to the beginning of the movement. When used it always has the value "yes".
    ///	
    ///Segno and dalsegno are used for backwards jumps to a segno sign; coda and tocoda are used for forward jumps to a coda sign. If there are multiple jumps, the value of these parameters can be used to name and distinguish them. If segno or coda is used, the divisions attribute can also be used to indicate the number of divisions per quarter note. Otherwise sound and MIDI generating programs may have to recompute this.
    ///	
    ///By default, a dalsegno or dacapo attribute indicates that the jump should occur the first time through, while a tocoda attribute indicates the jump should occur the second time through. The time that jumps occur can be changed by using the time-only attribute.
    ///	
    ///Forward-repeat is used when a forward repeat sign is implied, and usually follows a bar line. When used it always has the value of "yes".
    ///	
    ///The fine attribute follows the final note or rest in a movement with a da capo or dal segno direction. If numeric, the value represents the actual duration of the final note or rest, which can be ambiguous in written notation and different among parts and voices. The value may also be "yes" to indicate no change to the final duration.
    ///	
    ///If the sound element applies only particular times through a repeat, the time-only attribute indicates which times to apply the sound element.
    ///	
    ///Pizzicato in a sound element effects all following notes. Yes indicates pizzicato, no indicates arco.
    ///
    ///The pan and elevation attributes are deprecated in Version 2.0. The pan and elevation elements in the midi-instrument element should be used instead. The meaning of the pan and elevation attributes is the same as for the pan and elevation elements. If both are present, the mid-instrument elements take priority.
    ///	
    ///The damper-pedal, soft-pedal, and sostenuto-pedal attributes effect playback of the three common piano pedals and their MIDI controller equivalents. The yes value indicates the pedal is depressed; no indicates the pedal is released. A numeric value from 0 to 100 may also be used for half pedaling. This value is the percentage that the pedal is depressed. A value of 0 is equivalent to no, and a value of 100 is equivalent to yes.
    ///	
    ///MIDI devices, MIDI instruments, and playback techniques are changed using the midi-device, midi-instrument, and play elements. When there are multiple instances of these elements, they should be grouped together by instrument using the id attribute values.
    ///
    ///The offset element is used to indicate that the sound takes place offset from the current score position. If the sound element is a child of a direction element, the sound offset element overrides the direction offset element if both elements are present. Note that the offset reflects the intended musical position for the change in sound. It should not be used to compensate for latency issues in particular hardware configurations.
    /// </para>
    /// <para>
    /// Regular expression: ((mididevice?, midiinstrument?, play?)*, offset?)
    /// </para>
    /// </summary>
    public sound() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((mididevice?, midiinstrument?, play?)*, offset?)
    /// </para>
    /// </summary>
    public IList<mididevice> mididevice {
        get {
            if ((this.midideviceField == null)) {
                this.midideviceField = new XTypedList<mididevice>(this, LinqToXsdTypeManager.Instance, XName.Get("midi-device", ""));
            }
            return this.midideviceField;
        }
        set {
            if ((value == null)) {
                this.midideviceField = null;
            }
            else {
                if ((this.midideviceField == null)) {
                    this.midideviceField = XTypedList<mididevice>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("midi-device", ""));
                }
                else {
                    XTypedServices.SetList<mididevice>(this.midideviceField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((mididevice?, midiinstrument?, play?)*, offset?)
    /// </para>
    /// </summary>
    public IList<midiinstrument> midiinstrument {
        get {
            if ((this.midiinstrumentField == null)) {
                this.midiinstrumentField = new XTypedList<midiinstrument>(this, LinqToXsdTypeManager.Instance, XName.Get("midi-instrument", ""));
            }
            return this.midiinstrumentField;
        }
        set {
            if ((value == null)) {
                this.midiinstrumentField = null;
            }
            else {
                if ((this.midiinstrumentField == null)) {
                    this.midiinstrumentField = XTypedList<midiinstrument>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("midi-instrument", ""));
                }
                else {
                    XTypedServices.SetList<midiinstrument>(this.midiinstrumentField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((mididevice?, midiinstrument?, play?)*, offset?)
    /// </para>
    /// </summary>
    public IList<play> play {
        get {
            if ((this.playField == null)) {
                this.playField = new XTypedList<play>(this, LinqToXsdTypeManager.Instance, XName.Get("play", ""));
            }
            return this.playField;
        }
        set {
            if ((value == null)) {
                this.playField = null;
            }
            else {
                if ((this.playField == null)) {
                    this.playField = XTypedList<play>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("play", ""));
                }
                else {
                    XTypedServices.SetList<play>(this.playField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: ((mididevice?, midiinstrument?, play?)*, offset?)
    /// </para>
    /// </summary>
    public offset offset {
        get {
            XElement x = this.GetElement(XName.Get("offset", ""));
            return ((offset)(x));
        }
        set {
            this.SetElement(XName.Get("offset", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> tempo {
        get {
            XAttribute x = this.Attribute(XName.Get("tempo", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("tempo", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> dynamics {
        get {
            XAttribute x = this.Attribute(XName.Get("dynamics", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dynamics", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string dacapo {
        get {
            XAttribute x = this.Attribute(XName.Get("dacapo", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dacapo", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string segno {
        get {
            XAttribute x = this.Attribute(XName.Get("segno", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("segno", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string dalsegno {
        get {
            XAttribute x = this.Attribute(XName.Get("dalsegno", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dalsegno", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string coda {
        get {
            XAttribute x = this.Attribute(XName.Get("coda", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("coda", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string tocoda {
        get {
            XAttribute x = this.Attribute(XName.Get("tocoda", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("tocoda", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> divisions {
        get {
            XAttribute x = this.Attribute(XName.Get("divisions", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("divisions", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string forwardrepeat {
        get {
            XAttribute x = this.Attribute(XName.Get("forward-repeat", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("forward-repeat", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fine {
        get {
            XAttribute x = this.Attribute(XName.Get("fine", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("fine", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string timeonly {
        get {
            XAttribute x = this.Attribute(XName.Get("time-only", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("time-only", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string pizzicato {
        get {
            XAttribute x = this.Attribute(XName.Get("pizzicato", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("pizzicato", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> pan {
        get {
            XAttribute x = this.Attribute(XName.Get("pan", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("pan", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> elevation {
        get {
            XAttribute x = this.Attribute(XName.Get("elevation", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("elevation", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object damperpedal {
        get {
            XAttribute x = this.Attribute(XName.Get("damper-pedal", ""));
            return XTypedServices.ParseUnionValue(x, global::yesnonumber.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "damperpedal", this, XName.Get("damper-pedal", ""), global::yesnonumber.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object softpedal {
        get {
            XAttribute x = this.Attribute(XName.Get("soft-pedal", ""));
            return XTypedServices.ParseUnionValue(x, global::yesnonumber.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "softpedal", this, XName.Get("soft-pedal", ""), global::yesnonumber.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object sostenutopedal {
        get {
            XAttribute x = this.Attribute(XName.Get("sostenuto-pedal", ""));
            return XTypedServices.ParseUnionValue(x, global::yesnonumber.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "sostenutopedal", this, XName.Get("sostenuto-pedal", ""), global::yesnonumber.TypeDefinition);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("sound", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<sound>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("midi-device", ""), typeof(mididevice));
        localElementDictionary.Add(XName.Get("midi-instrument", ""), typeof(midiinstrument));
        localElementDictionary.Add(XName.Get("play", ""), typeof(play));
        localElementDictionary.Add(XName.Get("offset", ""), typeof(offset));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The stick type represents pictograms where the material of the stick, mallet, or beater is included.
/// </para>
/// <para>
/// Regular expression: (sticktype, stickmaterial)
/// </para>
/// </summary>
public partial class stick : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator stick(XElement xe) { return XTypedServices.ToXTypedElement<stick>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static stick() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("stick-type", "")), new NamedContentModelEntity(XName.Get("stick-material", "")));
    }
    
    /// <summary>
    /// <para>
    /// The stick type represents pictograms where the material of the stick, mallet, or beater is included.
    /// </para>
    /// <para>
    /// Regular expression: (sticktype, stickmaterial)
    /// </para>
    /// </summary>
    public stick() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (sticktype, stickmaterial)
    /// </para>
    /// </summary>
    public string sticktype {
        get {
            XElement x = this.GetElement(XName.Get("stick-type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("stick-type", ""), value, "sticktype", global::sticktype.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (sticktype, stickmaterial)
    /// </para>
    /// </summary>
    public string stickmaterial {
        get {
            XElement x = this.GetElement(XName.Get("stick-material", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("stick-material", ""), value, "stickmaterial", global::stickmaterial.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string tip {
        get {
            XAttribute x = this.Attribute(XName.Get("tip", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("tip", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("stick", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<stick>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("stick-type", ""), typeof(string));
        localElementDictionary.Add(XName.Get("stick-material", ""), typeof(string));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The string-mute type represents string mute on and mute off symbols.
/// </para>
/// </summary>
public partial class stringmute : XTypedElement, IXMetaData {
    
         public static explicit operator stringmute(XElement xe) { return XTypedServices.ToXTypedElement<stringmute>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The string-mute type represents string mute on and mute off symbols.
    /// </para>
    /// </summary>
    public stringmute() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string halign {
        get {
            XAttribute x = this.Attribute(XName.Get("halign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("halign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string valign {
        get {
            XAttribute x = this.Attribute(XName.Get("valign", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("valign", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("string-mute", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<stringmute>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The wedge type represents crescendo and diminuendo wedge symbols. The type attribute is crescendo for the start of a wedge that is closed at the left side, and diminuendo for the start of a wedge that is closed on the right side. Spread values are measured in tenths; those at the start of a crescendo wedge or end of a diminuendo wedge are ignored. The niente attribute is yes if a circle appears at the point of the wedge, indicating a crescendo from nothing or diminuendo to nothing. It is no by default, and used only when the type is crescendo, or the type is stop for a wedge that began with a diminuendo type. The line-type is solid by default.
/// </para>
/// </summary>
public partial class wedge : XTypedElement, IXMetaData {
    
         public static explicit operator wedge(XElement xe) { return XTypedServices.ToXTypedElement<wedge>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The wedge type represents crescendo and diminuendo wedge symbols. The type attribute is crescendo for the start of a wedge that is closed at the left side, and diminuendo for the start of a wedge that is closed on the right side. Spread values are measured in tenths; those at the start of a crescendo wedge or end of a diminuendo wedge are ignored. The niente attribute is yes if a circle appears at the point of the wedge, indicating a crescendo from nothing or diminuendo to nothing. It is no by default, and used only when the type is crescendo, or the type is stop for a wedge that began with a diminuendo type. The line-type is solid by default.
    /// </para>
    /// </summary>
    public wedge() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> spread {
        get {
            XAttribute x = this.Attribute(XName.Get("spread", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("spread", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string niente {
        get {
            XAttribute x = this.Attribute(XName.Get("niente", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("niente", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string linetype {
        get {
            XAttribute x = this.Attribute(XName.Get("line-type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line-type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> dashlength {
        get {
            XAttribute x = this.Attribute(XName.Get("dash-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dash-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> spacelength {
        get {
            XAttribute x = this.Attribute(XName.Get("space-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("space-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("wedge", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<wedge>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The encoding element contains information about who did the digital encoding, when, with what software, and in what aspects. Standard type values for the encoder element are music, words, and arrangement, but other types may be used. The type attribute is only needed when there are multiple encoder elements.
/// </para>
/// <para>
/// Regular expression: (encodingdate | encoder | software | encodingdescription | supports)*
/// </para>
/// </summary>
public partial class encoding : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<System.DateTime> encodingdateField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<typedtext> encoderField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<string> softwareField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<string> encodingdescriptionField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<supports> supportsField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator encoding(XElement xe) { return XTypedServices.ToXTypedElement<encoding>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static encoding() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The encoding element contains information about who did the digital encoding, when, with what software, and in what aspects. Standard type values for the encoder element are music, words, and arrangement, but other types may be used. The type attribute is only needed when there are multiple encoder elements.
    /// </para>
    /// <para>
    /// Regular expression: (encodingdate | encoder | software | encodingdescription | supports)*
    /// </para>
    /// </summary>
    public encoding() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (encodingdate | encoder | software | encodingdescription | supports)*
    /// </para>
    /// </summary>
    public IList<System.DateTime> encodingdate {
        get {
            if ((this.encodingdateField == null)) {
                this.encodingdateField = new XSimpleList<System.DateTime>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Date).Datatype, XName.Get("encoding-date", ""));
            }
            return this.encodingdateField;
        }
        set {
            if ((value == null)) {
                this.encodingdateField = null;
            }
            else {
                if ((this.encodingdateField == null)) {
                    this.encodingdateField = XSimpleList<System.DateTime>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Date).Datatype, value, XName.Get("encoding-date", ""));
                }
                else {
                    XTypedServices.SetList<System.DateTime>(this.encodingdateField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (encodingdate | encoder | software | encodingdescription | supports)*
    /// </para>
    /// </summary>
    public IList<typedtext> encoder {
        get {
            if ((this.encoderField == null)) {
                this.encoderField = new XTypedList<typedtext>(this, LinqToXsdTypeManager.Instance, XName.Get("encoder", ""));
            }
            return this.encoderField;
        }
        set {
            if ((value == null)) {
                this.encoderField = null;
            }
            else {
                if ((this.encoderField == null)) {
                    this.encoderField = XTypedList<typedtext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("encoder", ""));
                }
                else {
                    XTypedServices.SetList<typedtext>(this.encoderField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (encodingdate | encoder | software | encodingdescription | supports)*
    /// </para>
    /// </summary>
    public IList<string> software {
        get {
            if ((this.softwareField == null)) {
                this.softwareField = new XSimpleList<string>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, XName.Get("software", ""));
            }
            return this.softwareField;
        }
        set {
            if ((value == null)) {
                this.softwareField = null;
            }
            else {
                if ((this.softwareField == null)) {
                    this.softwareField = XSimpleList<string>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, value, XName.Get("software", ""));
                }
                else {
                    XTypedServices.SetList<System.String>(this.softwareField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (encodingdate | encoder | software | encodingdescription | supports)*
    /// </para>
    /// </summary>
    public IList<string> encodingdescription {
        get {
            if ((this.encodingdescriptionField == null)) {
                this.encodingdescriptionField = new XSimpleList<string>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, XName.Get("encoding-description", ""));
            }
            return this.encodingdescriptionField;
        }
        set {
            if ((value == null)) {
                this.encodingdescriptionField = null;
            }
            else {
                if ((this.encodingdescriptionField == null)) {
                    this.encodingdescriptionField = XSimpleList<string>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, value, XName.Get("encoding-description", ""));
                }
                else {
                    XTypedServices.SetList<System.String>(this.encodingdescriptionField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (encodingdate | encoder | software | encodingdescription | supports)*
    /// </para>
    /// </summary>
    public IList<supports> supports {
        get {
            if ((this.supportsField == null)) {
                this.supportsField = new XTypedList<supports>(this, LinqToXsdTypeManager.Instance, XName.Get("supports", ""));
            }
            return this.supportsField;
        }
        set {
            if ((value == null)) {
                this.supportsField = null;
            }
            else {
                if ((this.supportsField == null)) {
                    this.supportsField = XTypedList<supports>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("supports", ""));
                }
                else {
                    XTypedServices.SetList<supports>(this.supportsField, value);
                }
            }
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("encoding", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<encoding>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("encoding-date", ""), typeof(System.DateTime));
        localElementDictionary.Add(XName.Get("encoder", ""), typeof(typedtext));
        localElementDictionary.Add(XName.Get("software", ""), typeof(string));
        localElementDictionary.Add(XName.Get("encoding-description", ""), typeof(string));
        localElementDictionary.Add(XName.Get("supports", ""), typeof(supports));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Identification contains basic metadata about the score. It includes the information in MuseData headers that may apply at a score-wide, movement-wide, or part-wide level. The creator, rights, source, and relation elements are based on Dublin Core.
/// </para>
/// <para>
/// Regular expression: (creator*, rights*, encoding?, source?, relation*, miscellaneous?)
/// </para>
/// </summary>
public partial class identification : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<typedtext> creatorField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<typedtext> rightsField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<typedtext> relationField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator identification(XElement xe) { return XTypedServices.ToXTypedElement<identification>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static identification() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("creator", "")), new NamedContentModelEntity(XName.Get("rights", "")), new NamedContentModelEntity(XName.Get("encoding", "")), new NamedContentModelEntity(XName.Get("source", "")), new NamedContentModelEntity(XName.Get("relation", "")), new NamedContentModelEntity(XName.Get("miscellaneous", "")));
    }
    
    /// <summary>
    /// <para>
    /// Identification contains basic metadata about the score. It includes the information in MuseData headers that may apply at a score-wide, movement-wide, or part-wide level. The creator, rights, source, and relation elements are based on Dublin Core.
    /// </para>
    /// <para>
    /// Regular expression: (creator*, rights*, encoding?, source?, relation*, miscellaneous?)
    /// </para>
    /// </summary>
    public identification() {
    }
    
    /// <summary>
    /// <para>
    /// The creator element is borrowed from Dublin Core. It is used for the creators of the score. The type attribute is used to distinguish different creative contributions. Thus, there can be multiple creators within an identification. Standard type values are composer, lyricist, and arranger. Other type values may be used for different types of creative roles. The type attribute should usually be used even if there is just a single creator element. The MusicXML format does not use the creator / contributor distinction from Dublin Core.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (creator*, rights*, encoding?, source?, relation*, miscellaneous?)
    /// </para>
    /// </summary>
    public IList<typedtext> creator {
        get {
            if ((this.creatorField == null)) {
                this.creatorField = new XTypedList<typedtext>(this, LinqToXsdTypeManager.Instance, XName.Get("creator", ""));
            }
            return this.creatorField;
        }
        set {
            if ((value == null)) {
                this.creatorField = null;
            }
            else {
                if ((this.creatorField == null)) {
                    this.creatorField = XTypedList<typedtext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("creator", ""));
                }
                else {
                    XTypedServices.SetList<typedtext>(this.creatorField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The rights element is borrowed from Dublin Core. It contains copyright and other intellectual property notices. Words, music, and derivatives can have different types, so multiple rights tags with different type attributes are supported. Standard type values are music, words, and arrangement, but other types may be used. The type attribute is only needed when there are multiple rights elements.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (creator*, rights*, encoding?, source?, relation*, miscellaneous?)
    /// </para>
    /// </summary>
    public IList<typedtext> rights {
        get {
            if ((this.rightsField == null)) {
                this.rightsField = new XTypedList<typedtext>(this, LinqToXsdTypeManager.Instance, XName.Get("rights", ""));
            }
            return this.rightsField;
        }
        set {
            if ((value == null)) {
                this.rightsField = null;
            }
            else {
                if ((this.rightsField == null)) {
                    this.rightsField = XTypedList<typedtext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("rights", ""));
                }
                else {
                    XTypedServices.SetList<typedtext>(this.rightsField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (creator*, rights*, encoding?, source?, relation*, miscellaneous?)
    /// </para>
    /// </summary>
    public encoding encoding {
        get {
            XElement x = this.GetElement(XName.Get("encoding", ""));
            return ((encoding)(x));
        }
        set {
            this.SetElement(XName.Get("encoding", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The source for the music that is encoded. This is similar to the Dublin Core source element.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (creator*, rights*, encoding?, source?, relation*, miscellaneous?)
    /// </para>
    /// </summary>
    public string source {
        get {
            XElement x = this.GetElement(XName.Get("source", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("source", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// A related resource for the music that is encoded. This is similar to the Dublin Core relation element. Standard type values are music, words, and arrangement, but other types may be used.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (creator*, rights*, encoding?, source?, relation*, miscellaneous?)
    /// </para>
    /// </summary>
    public IList<typedtext> relation {
        get {
            if ((this.relationField == null)) {
                this.relationField = new XTypedList<typedtext>(this, LinqToXsdTypeManager.Instance, XName.Get("relation", ""));
            }
            return this.relationField;
        }
        set {
            if ((value == null)) {
                this.relationField = null;
            }
            else {
                if ((this.relationField == null)) {
                    this.relationField = XTypedList<typedtext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("relation", ""));
                }
                else {
                    XTypedServices.SetList<typedtext>(this.relationField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (creator*, rights*, encoding?, source?, relation*, miscellaneous?)
    /// </para>
    /// </summary>
    public miscellaneous miscellaneous {
        get {
            XElement x = this.GetElement(XName.Get("miscellaneous", ""));
            return ((miscellaneous)(x));
        }
        set {
            this.SetElement(XName.Get("miscellaneous", ""), value);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("identification", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<identification>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("creator", ""), typeof(typedtext));
        localElementDictionary.Add(XName.Get("rights", ""), typeof(typedtext));
        localElementDictionary.Add(XName.Get("encoding", ""), typeof(encoding));
        localElementDictionary.Add(XName.Get("source", ""), typeof(string));
        localElementDictionary.Add(XName.Get("relation", ""), typeof(typedtext));
        localElementDictionary.Add(XName.Get("miscellaneous", ""), typeof(miscellaneous));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// If a program has other metadata not yet supported in the MusicXML format, it can go in the miscellaneous element. The miscellaneous type puts each separate part of metadata into its own miscellaneous-field type.
/// </para>
/// <para>
/// Regular expression: (miscellaneousfield*)
/// </para>
/// </summary>
public partial class miscellaneous : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<miscellaneousfield> miscellaneousfieldField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator miscellaneous(XElement xe) { return XTypedServices.ToXTypedElement<miscellaneous>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static miscellaneous() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("miscellaneous-field", "")));
    }
    
    /// <summary>
    /// <para>
    /// If a program has other metadata not yet supported in the MusicXML format, it can go in the miscellaneous element. The miscellaneous type puts each separate part of metadata into its own miscellaneous-field type.
    /// </para>
    /// <para>
    /// Regular expression: (miscellaneousfield*)
    /// </para>
    /// </summary>
    public miscellaneous() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (miscellaneousfield*)
    /// </para>
    /// </summary>
    public IList<miscellaneousfield> miscellaneousfield {
        get {
            if ((this.miscellaneousfieldField == null)) {
                this.miscellaneousfieldField = new XTypedList<miscellaneousfield>(this, LinqToXsdTypeManager.Instance, XName.Get("miscellaneous-field", ""));
            }
            return this.miscellaneousfieldField;
        }
        set {
            if ((value == null)) {
                this.miscellaneousfieldField = null;
            }
            else {
                if ((this.miscellaneousfieldField == null)) {
                    this.miscellaneousfieldField = XTypedList<miscellaneousfield>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("miscellaneous-field", ""));
                }
                else {
                    XTypedServices.SetList<miscellaneousfield>(this.miscellaneousfieldField, value);
                }
            }
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("miscellaneous", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<miscellaneous>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("miscellaneous-field", ""), typeof(miscellaneousfield));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// If a program has other metadata not yet supported in the MusicXML format, each type of metadata can go in a miscellaneous-field element. The required name attribute indicates the type of metadata the element content represents.
/// </para>
/// </summary>
public partial class miscellaneousfield : XTypedElement, IXMetaData {
    
         public static explicit operator miscellaneousfield(XElement xe) { return XTypedServices.ToXTypedElement<miscellaneousfield>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// If a program has other metadata not yet supported in the MusicXML format, each type of metadata can go in a miscellaneous-field element. The required name attribute indicates the type of metadata the element content represents.
    /// </para>
    /// </summary>
    public miscellaneousfield() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string name {
        get {
            XAttribute x = this.Attribute(XName.Get("name", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("miscellaneous-field", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<miscellaneousfield>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The supports type indicates if a MusicXML encoding supports a particular MusicXML element. This is recommended for elements like beam, stem, and accidental, where the absence of an element is ambiguous if you do not know if the encoding supports that element. For Version 2.0, the supports element is expanded to allow programs to indicate support for particular attributes or particular values. This lets applications communicate, for example, that all system and/or page breaks are contained in the MusicXML file.
/// </para>
/// </summary>
public partial class supports : XTypedElement, IXMetaData {
    
         public static explicit operator supports(XElement xe) { return XTypedServices.ToXTypedElement<supports>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The supports type indicates if a MusicXML encoding supports a particular MusicXML element. This is recommended for elements like beam, stem, and accidental, where the absence of an element is ambiguous if you do not know if the encoding supports that element. For Version 2.0, the supports element is expanded to allow programs to indicate support for particular attributes or particular values. This lets applications communicate, for example, that all system and/or page breaks are contained in the MusicXML file.
    /// </para>
    /// </summary>
    public supports() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string element {
        get {
            XAttribute x = this.Attribute(XName.Get("element", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("element", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string attribute {
        get {
            XAttribute x = this.Attribute(XName.Get("attribute", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("attribute", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string value {
        get {
            XAttribute x = this.Attribute(XName.Get("value", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("value", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("supports", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<supports>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The appearance type controls general graphical settings for the music's final form appearance on a printed page of display. This includes support for line widths, definitions for note sizes, and standard distances between notation elements, plus an extension element for other aspects of appearance.
/// </para>
/// <para>
/// Regular expression: (linewidth*, notesize*, distance*, otherappearance*)
/// </para>
/// </summary>
public partial class appearance : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<linewidth> linewidthField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<notesize> notesizeField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<distance> distanceField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<otherappearance> otherappearanceField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator appearance(XElement xe) { return XTypedServices.ToXTypedElement<appearance>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static appearance() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("line-width", "")), new NamedContentModelEntity(XName.Get("note-size", "")), new NamedContentModelEntity(XName.Get("distance", "")), new NamedContentModelEntity(XName.Get("other-appearance", "")));
    }
    
    /// <summary>
    /// <para>
    /// The appearance type controls general graphical settings for the music's final form appearance on a printed page of display. This includes support for line widths, definitions for note sizes, and standard distances between notation elements, plus an extension element for other aspects of appearance.
    /// </para>
    /// <para>
    /// Regular expression: (linewidth*, notesize*, distance*, otherappearance*)
    /// </para>
    /// </summary>
    public appearance() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (linewidth*, notesize*, distance*, otherappearance*)
    /// </para>
    /// </summary>
    public IList<linewidth> linewidth {
        get {
            if ((this.linewidthField == null)) {
                this.linewidthField = new XTypedList<linewidth>(this, LinqToXsdTypeManager.Instance, XName.Get("line-width", ""));
            }
            return this.linewidthField;
        }
        set {
            if ((value == null)) {
                this.linewidthField = null;
            }
            else {
                if ((this.linewidthField == null)) {
                    this.linewidthField = XTypedList<linewidth>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("line-width", ""));
                }
                else {
                    XTypedServices.SetList<linewidth>(this.linewidthField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (linewidth*, notesize*, distance*, otherappearance*)
    /// </para>
    /// </summary>
    public IList<notesize> notesize {
        get {
            if ((this.notesizeField == null)) {
                this.notesizeField = new XTypedList<notesize>(this, LinqToXsdTypeManager.Instance, XName.Get("note-size", ""));
            }
            return this.notesizeField;
        }
        set {
            if ((value == null)) {
                this.notesizeField = null;
            }
            else {
                if ((this.notesizeField == null)) {
                    this.notesizeField = XTypedList<notesize>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("note-size", ""));
                }
                else {
                    XTypedServices.SetList<notesize>(this.notesizeField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (linewidth*, notesize*, distance*, otherappearance*)
    /// </para>
    /// </summary>
    public IList<distance> distance {
        get {
            if ((this.distanceField == null)) {
                this.distanceField = new XTypedList<distance>(this, LinqToXsdTypeManager.Instance, XName.Get("distance", ""));
            }
            return this.distanceField;
        }
        set {
            if ((value == null)) {
                this.distanceField = null;
            }
            else {
                if ((this.distanceField == null)) {
                    this.distanceField = XTypedList<distance>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("distance", ""));
                }
                else {
                    XTypedServices.SetList<distance>(this.distanceField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (linewidth*, notesize*, distance*, otherappearance*)
    /// </para>
    /// </summary>
    public IList<otherappearance> otherappearance {
        get {
            if ((this.otherappearanceField == null)) {
                this.otherappearanceField = new XTypedList<otherappearance>(this, LinqToXsdTypeManager.Instance, XName.Get("other-appearance", ""));
            }
            return this.otherappearanceField;
        }
        set {
            if ((value == null)) {
                this.otherappearanceField = null;
            }
            else {
                if ((this.otherappearanceField == null)) {
                    this.otherappearanceField = XTypedList<otherappearance>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("other-appearance", ""));
                }
                else {
                    XTypedServices.SetList<otherappearance>(this.otherappearanceField, value);
                }
            }
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("appearance", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<appearance>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("line-width", ""), typeof(linewidth));
        localElementDictionary.Add(XName.Get("note-size", ""), typeof(notesize));
        localElementDictionary.Add(XName.Get("distance", ""), typeof(distance));
        localElementDictionary.Add(XName.Get("other-appearance", ""), typeof(otherappearance));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The distance element represents standard distances between notation elements in tenths. The type attribute defines what type of distance is being defined. Valid values include hyphen (for hyphens in lyrics) and beam.
/// </para>
/// </summary>
public partial class distance : XTypedElement, IXMetaData {
    
         public static explicit operator distance(XElement xe) { return XTypedServices.ToXTypedElement<distance>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The distance element represents standard distances between notation elements in tenths. The type attribute defines what type of distance is being defined. Valid values include hyphen (for hyphens in lyrics) and beam.
    /// </para>
    /// </summary>
    public distance() {
    }
    
    public decimal TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::tenths.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("distance", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<distance>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The line-width type indicates the width of a line type in tenths. The type attribute defines what type of line is being defined. Values include beam, bracket, dashes, enclosure, ending, extend, heavy barline, leger, light barline, octave shift, pedal, slur middle, slur tip, staff, stem, tie middle, tie tip, tuplet bracket, and wedge. The text content is expressed in tenths.
/// </para>
/// </summary>
public partial class linewidth : XTypedElement, IXMetaData {
    
         public static explicit operator linewidth(XElement xe) { return XTypedServices.ToXTypedElement<linewidth>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The line-width type indicates the width of a line type in tenths. The type attribute defines what type of line is being defined. Values include beam, bracket, dashes, enclosure, ending, extend, heavy barline, leger, light barline, octave shift, pedal, slur middle, slur tip, staff, stem, tie middle, tie tip, tuplet bracket, and wedge. The text content is expressed in tenths.
    /// </para>
    /// </summary>
    public linewidth() {
    }
    
    public decimal TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::tenths.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("line-width", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<linewidth>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The measure-layout type includes the horizontal distance from the previous measure.
/// </para>
/// <para>
/// Regular expression: (measuredistance?)
/// </para>
/// </summary>
public partial class measurelayout : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator measurelayout(XElement xe) { return XTypedServices.ToXTypedElement<measurelayout>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static measurelayout() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("measure-distance", "")));
    }
    
    /// <summary>
    /// <para>
    /// The measure-layout type includes the horizontal distance from the previous measure.
    /// </para>
    /// <para>
    /// Regular expression: (measuredistance?)
    /// </para>
    /// </summary>
    public measurelayout() {
    }
    
    /// <summary>
    /// <para>
    /// The measure-distance element specifies the horizontal distance from the previous measure. This value is only used for systems where there is horizontal whitespace in the middle of a system, as in systems with codas. To specify the measure width, use the width attribute of the measure element.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (measuredistance?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> measuredistance {
        get {
            XElement x = this.GetElement(XName.Get("measure-distance", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("measure-distance", ""), value, "measuredistance", global::tenths.TypeDefinition);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("measure-layout", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<measurelayout>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("measure-distance", ""), typeof(decimal));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The note-size type indicates the percentage of the regular note size to use for notes with a cue and large size as defined in the type element. The grace type is used for notes of cue size that that include a grace element. The cue type is used for all other notes with cue size, whether defined explicitly or implicitly via a cue element. The large type is used for notes of large size. The text content represent the numeric percentage. A value of 100 would be identical to the size of a regular note as defined by the music font.
/// </para>
/// </summary>
public partial class notesize : XTypedElement, IXMetaData {
    
         public static explicit operator notesize(XElement xe) { return XTypedServices.ToXTypedElement<notesize>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The note-size type indicates the percentage of the regular note size to use for notes with a cue and large size as defined in the type element. The grace type is used for notes of cue size that that include a grace element. The cue type is used for all other notes with cue size, whether defined explicitly or implicitly via a cue element. The large type is used for notes of large size. The text content represent the numeric percentage. A value of 100 would be identical to the size of a regular note as defined by the music font.
    /// </para>
    /// </summary>
    public notesize() {
    }
    
    public decimal TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::nonnegativedecimal.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("note-size", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<notesize>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The other-appearance type is used to define any graphical settings not yet in the current version of the MusicXML format. This allows extended representation, though without application interoperability.
/// </para>
/// </summary>
public partial class otherappearance : XTypedElement, IXMetaData {
    
         public static explicit operator otherappearance(XElement xe) { return XTypedServices.ToXTypedElement<otherappearance>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The other-appearance type is used to define any graphical settings not yet in the current version of the MusicXML format. This allows extended representation, though without application interoperability.
    /// </para>
    /// </summary>
    public otherappearance() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("other-appearance", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<otherappearance>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Page layout can be defined both in score-wide defaults and in the print element. Page margins are specified either for both even and odd pages, or via separate odd and even page number values. The type is not needed when used as part of a print element. If omitted when used in the defaults element, "both" is the default.
/// </para>
/// <para>
/// Regular expression: ((pageheight, pagewidth)?, pagemargins*)
/// </para>
/// </summary>
public partial class pagelayout : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<pagemargins> pagemarginsField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator pagelayout(XElement xe) { return XTypedServices.ToXTypedElement<pagelayout>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static pagelayout() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// Page layout can be defined both in score-wide defaults and in the print element. Page margins are specified either for both even and odd pages, or via separate odd and even page number values. The type is not needed when used as part of a print element. If omitted when used in the defaults element, "both" is the default.
    /// </para>
    /// <para>
    /// Regular expression: ((pageheight, pagewidth)?, pagemargins*)
    /// </para>
    /// </summary>
    public pagelayout() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((pageheight, pagewidth)?, pagemargins*)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> pageheight {
        get {
            XElement x = this.GetElement(XName.Get("page-height", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("page-height", ""), value, "pageheight", global::tenths.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((pageheight, pagewidth)?, pagemargins*)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> pagewidth {
        get {
            XElement x = this.GetElement(XName.Get("page-width", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("page-width", ""), value, "pagewidth", global::tenths.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: ((pageheight, pagewidth)?, pagemargins*)
    /// </para>
    /// </summary>
    public IList<pagemargins> pagemargins {
        get {
            if ((this.pagemarginsField == null)) {
                this.pagemarginsField = new XTypedList<pagemargins>(this, LinqToXsdTypeManager.Instance, XName.Get("page-margins", ""));
            }
            return this.pagemarginsField;
        }
        set {
            if ((value == null)) {
                this.pagemarginsField = null;
            }
            else {
                if ((this.pagemarginsField == null)) {
                    this.pagemarginsField = XTypedList<pagemargins>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("page-margins", ""));
                }
                else {
                    XTypedServices.SetList<pagemargins>(this.pagemarginsField, value);
                }
            }
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("page-layout", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<pagelayout>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("page-height", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("page-width", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("page-margins", ""), typeof(pagemargins));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Page margins are specified either for both even and odd pages, or via separate odd and even page number values. The type attribute is not needed when used as part of a print element. If omitted when the page-margins type is used in the defaults element, "both" is the default value.
/// </para>
/// <para>
/// Regular expression: (leftmargin, rightmargin, topmargin, bottommargin)
/// </para>
/// </summary>
public partial class pagemargins : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator pagemargins(XElement xe) { return XTypedServices.ToXTypedElement<pagemargins>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static pagemargins() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("left-margin", "")), new NamedContentModelEntity(XName.Get("right-margin", "")), new NamedContentModelEntity(XName.Get("top-margin", "")), new NamedContentModelEntity(XName.Get("bottom-margin", "")));
    }
    
    /// <summary>
    /// <para>
    /// Page margins are specified either for both even and odd pages, or via separate odd and even page number values. The type attribute is not needed when used as part of a print element. If omitted when the page-margins type is used in the defaults element, "both" is the default value.
    /// </para>
    /// <para>
    /// Regular expression: (leftmargin, rightmargin, topmargin, bottommargin)
    /// </para>
    /// </summary>
    public pagemargins() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (leftmargin, rightmargin, topmargin, bottommargin)
    /// </para>
    /// </summary>
    public decimal leftmargin {
        get {
            XElement x = this.GetElement(XName.Get("left-margin", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("left-margin", ""), value, "leftmargin", global::tenths.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (leftmargin, rightmargin, topmargin, bottommargin)
    /// </para>
    /// </summary>
    public decimal rightmargin {
        get {
            XElement x = this.GetElement(XName.Get("right-margin", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("right-margin", ""), value, "rightmargin", global::tenths.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (leftmargin, rightmargin, topmargin, bottommargin)
    /// </para>
    /// </summary>
    public decimal topmargin {
        get {
            XElement x = this.GetElement(XName.Get("top-margin", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("top-margin", ""), value, "topmargin", global::tenths.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (leftmargin, rightmargin, topmargin, bottommargin)
    /// </para>
    /// </summary>
    public decimal bottommargin {
        get {
            XElement x = this.GetElement(XName.Get("bottom-margin", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("bottom-margin", ""), value, "bottommargin", global::tenths.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("page-margins", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<pagemargins>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("left-margin", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("right-margin", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("top-margin", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("bottom-margin", ""), typeof(decimal));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// Margins, page sizes, and distances are all measured in tenths to keep MusicXML data in a consistent coordinate system as much as possible. The translation to absolute units is done with the scaling type, which specifies how many millimeters are equal to how many tenths. For a staff height of 7 mm, millimeters would be set to 7 while tenths is set to 40. The ability to set a formula rather than a single scaling factor helps avoid roundoff errors.
/// </para>
/// <para>
/// Regular expression: (millimeters, tenths)
/// </para>
/// </summary>
public partial class scaling : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator scaling(XElement xe) { return XTypedServices.ToXTypedElement<scaling>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static scaling() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("millimeters", "")), new NamedContentModelEntity(XName.Get("tenths", "")));
    }
    
    /// <summary>
    /// <para>
    /// Margins, page sizes, and distances are all measured in tenths to keep MusicXML data in a consistent coordinate system as much as possible. The translation to absolute units is done with the scaling type, which specifies how many millimeters are equal to how many tenths. For a staff height of 7 mm, millimeters would be set to 7 while tenths is set to 40. The ability to set a formula rather than a single scaling factor helps avoid roundoff errors.
    /// </para>
    /// <para>
    /// Regular expression: (millimeters, tenths)
    /// </para>
    /// </summary>
    public scaling() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (millimeters, tenths)
    /// </para>
    /// </summary>
    public decimal millimeters {
        get {
            XElement x = this.GetElement(XName.Get("millimeters", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("millimeters", ""), value, "millimeters", global::millimeters.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (millimeters, tenths)
    /// </para>
    /// </summary>
    public decimal tenths {
        get {
            XElement x = this.GetElement(XName.Get("tenths", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("tenths", ""), value, "tenths", global::tenths.TypeDefinition);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("scaling", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<scaling>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("millimeters", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("tenths", ""), typeof(decimal));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// Staff layout includes the vertical distance from the bottom line of the previous staff in this system to the top line of the staff specified by the number attribute. The optional number attribute refers to staff numbers within the part, from top to bottom on the system. A value of 1 is assumed if not present. When used in the defaults element, the values apply to all parts. This value is ignored for the first staff in a system.
/// </para>
/// <para>
/// Regular expression: (staffdistance?)
/// </para>
/// </summary>
public partial class stafflayout : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator stafflayout(XElement xe) { return XTypedServices.ToXTypedElement<stafflayout>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static stafflayout() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("staff-distance", "")));
    }
    
    /// <summary>
    /// <para>
    /// Staff layout includes the vertical distance from the bottom line of the previous staff in this system to the top line of the staff specified by the number attribute. The optional number attribute refers to staff numbers within the part, from top to bottom on the system. A value of 1 is assumed if not present. When used in the defaults element, the values apply to all parts. This value is ignored for the first staff in a system.
    /// </para>
    /// <para>
    /// Regular expression: (staffdistance?)
    /// </para>
    /// </summary>
    public stafflayout() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (staffdistance?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> staffdistance {
        get {
            XElement x = this.GetElement(XName.Get("staff-distance", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("staff-distance", ""), value, "staffdistance", global::tenths.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("staff-layout", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<stafflayout>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("staff-distance", ""), typeof(decimal));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The system-dividers element indicates the presence or absence of system dividers (also known as system separation marks) between systems displayed on the same page. Dividers on the left and right side of the page are controlled by the left-divider and right-divider elements respectively. The default vertical position is half the system-distance value from the top of the system that is below the divider. The default horizontal position is the left and right system margin, respectively.
///
///When used in the print element, the system-dividers element affects the dividers that would appear between the current system and the previous system.
/// </para>
/// <para>
/// Regular expression: (leftdivider, rightdivider)
/// </para>
/// </summary>
public partial class systemdividers : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator systemdividers(XElement xe) { return XTypedServices.ToXTypedElement<systemdividers>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static systemdividers() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("left-divider", "")), new NamedContentModelEntity(XName.Get("right-divider", "")));
    }
    
    /// <summary>
    /// <para>
    /// The system-dividers element indicates the presence or absence of system dividers (also known as system separation marks) between systems displayed on the same page. Dividers on the left and right side of the page are controlled by the left-divider and right-divider elements respectively. The default vertical position is half the system-distance value from the top of the system that is below the divider. The default horizontal position is the left and right system margin, respectively.
    ///
    ///When used in the print element, the system-dividers element affects the dividers that would appear between the current system and the previous system.
    /// </para>
    /// <para>
    /// Regular expression: (leftdivider, rightdivider)
    /// </para>
    /// </summary>
    public systemdividers() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (leftdivider, rightdivider)
    /// </para>
    /// </summary>
    public emptyprintobjectstylealign leftdivider {
        get {
            XElement x = this.GetElement(XName.Get("left-divider", ""));
            return ((emptyprintobjectstylealign)(x));
        }
        set {
            this.SetElement(XName.Get("left-divider", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (leftdivider, rightdivider)
    /// </para>
    /// </summary>
    public emptyprintobjectstylealign rightdivider {
        get {
            XElement x = this.GetElement(XName.Get("right-divider", ""));
            return ((emptyprintobjectstylealign)(x));
        }
        set {
            this.SetElement(XName.Get("right-divider", ""), value);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("system-dividers", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<systemdividers>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("left-divider", ""), typeof(emptyprintobjectstylealign));
        localElementDictionary.Add(XName.Get("right-divider", ""), typeof(emptyprintobjectstylealign));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// A system is a group of staves that are read and played simultaneously. System layout includes left and right margins and the vertical distance from the previous system. The system distance is measured from the bottom line of the previous system to the top line of the current system. It is ignored for the first system on a page. The top system distance is measured from the page's top margin to the top line of the first system. It is ignored for all but the first system on a page.
///	
///Sometimes the sum of measure widths in a system may not equal the system width specified by the layout elements due to roundoff or other errors. The behavior when reading MusicXML files in these cases is application-dependent. For instance, applications may find that the system layout data is more reliable than the sum of the measure widths, and adjust the measure widths accordingly.
/// </para>
/// <para>
/// Regular expression: (systemmargins?, systemdistance?, topsystemdistance?, systemdividers?)
/// </para>
/// </summary>
public partial class systemlayout : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator systemlayout(XElement xe) { return XTypedServices.ToXTypedElement<systemlayout>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static systemlayout() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("system-margins", "")), new NamedContentModelEntity(XName.Get("system-distance", "")), new NamedContentModelEntity(XName.Get("top-system-distance", "")), new NamedContentModelEntity(XName.Get("system-dividers", "")));
    }
    
    /// <summary>
    /// <para>
    /// A system is a group of staves that are read and played simultaneously. System layout includes left and right margins and the vertical distance from the previous system. The system distance is measured from the bottom line of the previous system to the top line of the current system. It is ignored for the first system on a page. The top system distance is measured from the page's top margin to the top line of the first system. It is ignored for all but the first system on a page.
    ///	
    ///Sometimes the sum of measure widths in a system may not equal the system width specified by the layout elements due to roundoff or other errors. The behavior when reading MusicXML files in these cases is application-dependent. For instance, applications may find that the system layout data is more reliable than the sum of the measure widths, and adjust the measure widths accordingly.
    /// </para>
    /// <para>
    /// Regular expression: (systemmargins?, systemdistance?, topsystemdistance?, systemdividers?)
    /// </para>
    /// </summary>
    public systemlayout() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (systemmargins?, systemdistance?, topsystemdistance?, systemdividers?)
    /// </para>
    /// </summary>
    public systemmargins systemmargins {
        get {
            XElement x = this.GetElement(XName.Get("system-margins", ""));
            return ((systemmargins)(x));
        }
        set {
            this.SetElement(XName.Get("system-margins", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (systemmargins?, systemdistance?, topsystemdistance?, systemdividers?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> systemdistance {
        get {
            XElement x = this.GetElement(XName.Get("system-distance", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("system-distance", ""), value, "systemdistance", global::tenths.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (systemmargins?, systemdistance?, topsystemdistance?, systemdividers?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> topsystemdistance {
        get {
            XElement x = this.GetElement(XName.Get("top-system-distance", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("top-system-distance", ""), value, "topsystemdistance", global::tenths.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (systemmargins?, systemdistance?, topsystemdistance?, systemdividers?)
    /// </para>
    /// </summary>
    public systemdividers systemdividers {
        get {
            XElement x = this.GetElement(XName.Get("system-dividers", ""));
            return ((systemdividers)(x));
        }
        set {
            this.SetElement(XName.Get("system-dividers", ""), value);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("system-layout", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<systemlayout>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("system-margins", ""), typeof(systemmargins));
        localElementDictionary.Add(XName.Get("system-distance", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("top-system-distance", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("system-dividers", ""), typeof(systemdividers));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// System margins are relative to the page margins. Positive values indent and negative values reduce the margin size.
/// </para>
/// <para>
/// Regular expression: (leftmargin, rightmargin)
/// </para>
/// </summary>
public partial class systemmargins : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator systemmargins(XElement xe) { return XTypedServices.ToXTypedElement<systemmargins>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static systemmargins() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("left-margin", "")), new NamedContentModelEntity(XName.Get("right-margin", "")));
    }
    
    /// <summary>
    /// <para>
    /// System margins are relative to the page margins. Positive values indent and negative values reduce the margin size.
    /// </para>
    /// <para>
    /// Regular expression: (leftmargin, rightmargin)
    /// </para>
    /// </summary>
    public systemmargins() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (leftmargin, rightmargin)
    /// </para>
    /// </summary>
    public decimal leftmargin {
        get {
            XElement x = this.GetElement(XName.Get("left-margin", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("left-margin", ""), value, "leftmargin", global::tenths.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (leftmargin, rightmargin)
    /// </para>
    /// </summary>
    public decimal rightmargin {
        get {
            XElement x = this.GetElement(XName.Get("right-margin", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("right-margin", ""), value, "rightmargin", global::tenths.TypeDefinition);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("system-margins", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<systemmargins>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("left-margin", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("right-margin", ""), typeof(decimal));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The bookmark type serves as a well-defined target for an incoming simple XLink.
/// </para>
/// </summary>
public partial class bookmark : XTypedElement, IXMetaData {
    
         public static explicit operator bookmark(XElement xe) { return XTypedServices.ToXTypedElement<bookmark>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The bookmark type serves as a well-defined target for an incoming simple XLink.
    /// </para>
    /// </summary>
    public bookmark() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string id {
        get {
            XAttribute x = this.Attribute(XName.Get("id", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("id", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string name {
        get {
            XAttribute x = this.Attribute(XName.Get("name", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string element {
        get {
            XAttribute x = this.Attribute(XName.Get("element", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("element", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> position {
        get {
            XAttribute x = this.Attribute(XName.Get("position", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("position", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("bookmark", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<bookmark>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The link type serves as an outgoing simple XLink. It is also used to connect a MusicXML score with a MusicXML opus. If a relative link is used within a document that is part of a compressed MusicXML file, the link is relative to the  root folder of the zip file.
/// </para>
/// </summary>
public partial class link : XTypedElement, IXMetaData {
    
         public static explicit operator link(XElement xe) { return XTypedServices.ToXTypedElement<link>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The link type serves as an outgoing simple XLink. It is also used to connect a MusicXML score with a MusicXML opus. If a relative link is used within a document that is part of a compressed MusicXML file, the link is relative to the  root folder of the zip file.
    /// </para>
    /// </summary>
    public link() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public System.Uri href {
        get {
            XAttribute x = this.Attribute(XName.Get("href", "http://www.w3.org/1999/xlink"));
            return XTypedServices.ParseValue<System.Uri>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("href", "http://www.w3.org/1999/xlink"), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", "http://www.w3.org/1999/xlink"));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", "http://www.w3.org/1999/xlink"), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string role {
        get {
            XAttribute x = this.Attribute(XName.Get("role", "http://www.w3.org/1999/xlink"));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("role", "http://www.w3.org/1999/xlink"), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string title {
        get {
            XAttribute x = this.Attribute(XName.Get("title", "http://www.w3.org/1999/xlink"));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("title", "http://www.w3.org/1999/xlink"), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string show {
        get {
            XAttribute x = this.Attribute(XName.Get("show", "http://www.w3.org/1999/xlink"));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("show", "http://www.w3.org/1999/xlink"), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string actuate {
        get {
            XAttribute x = this.Attribute(XName.Get("actuate", "http://www.w3.org/1999/xlink"));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("actuate", "http://www.w3.org/1999/xlink"), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string name {
        get {
            XAttribute x = this.Attribute(XName.Get("name", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string element {
        get {
            XAttribute x = this.Attribute(XName.Get("element", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("element", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> position {
        get {
            XAttribute x = this.Attribute(XName.Get("position", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("position", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("link", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<link>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The accidental type represents actual notated accidentals. Editorial and cautionary indications are indicated by attributes. Values for these attributes are "no" if not present. Specific graphic display such as parentheses, brackets, and size are controlled by the level-display attribute group.
/// </para>
/// </summary>
public partial class accidental : XTypedElement, IXMetaData {
    
         public static explicit operator accidental(XElement xe) { return XTypedServices.ToXTypedElement<accidental>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The accidental type represents actual notated accidentals. Editorial and cautionary indications are indicated by attributes. Values for these attributes are "no" if not present. Specific graphic display such as parentheses, brackets, and size are controlled by the level-display attribute group.
    /// </para>
    /// </summary>
    public accidental() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::accidentalvalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string cautionary {
        get {
            XAttribute x = this.Attribute(XName.Get("cautionary", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("cautionary", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string editorial {
        get {
            XAttribute x = this.Attribute(XName.Get("editorial", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("editorial", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string parentheses {
        get {
            XAttribute x = this.Attribute(XName.Get("parentheses", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("parentheses", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string bracket {
        get {
            XAttribute x = this.Attribute(XName.Get("bracket", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bracket", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string size {
        get {
            XAttribute x = this.Attribute(XName.Get("size", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("size", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("accidental", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<accidental>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// An accidental-mark can be used as a separate notation or as part of an ornament. When used in an ornament, position and placement are relative to the ornament, not relative to the note.
/// </para>
/// </summary>
public partial class accidentalmark : XTypedElement, IXMetaData {
    
         public static explicit operator accidentalmark(XElement xe) { return XTypedServices.ToXTypedElement<accidentalmark>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// An accidental-mark can be used as a separate notation or as part of an ornament. When used in an ornament, position and placement are relative to the ornament, not relative to the note.
    /// </para>
    /// </summary>
    public accidentalmark() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::accidentalvalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("accidental-mark", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<accidentalmark>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The arpeggiate type indicates that this note is part of an arpeggiated chord. The number attribute can be used to distinguish between two simultaneous chords arpeggiated separately (different numbers) or together (same number). The up-down attribute is used if there is an arrow on the arpeggio sign. By default, arpeggios go from the lowest to highest note.
/// </para>
/// </summary>
public partial class arpeggiate : XTypedElement, IXMetaData {
    
         public static explicit operator arpeggiate(XElement xe) { return XTypedServices.ToXTypedElement<arpeggiate>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The arpeggiate type indicates that this note is part of an arpeggiated chord. The number attribute can be used to distinguish between two simultaneous chords arpeggiated separately (different numbers) or together (same number). The up-down attribute is used if there is an arrow on the arpeggio sign. By default, arpeggios go from the lowest to highest note.
    /// </para>
    /// </summary>
    public arpeggiate() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string direction {
        get {
            XAttribute x = this.Attribute(XName.Get("direction", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("direction", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("arpeggiate", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<arpeggiate>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Articulations and accents are grouped together here.
/// </para>
/// <para>
/// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
/// </para>
/// </summary>
public partial class articulations : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> accentField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<strongaccent> strongaccentField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> staccatoField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> tenutoField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> detachedlegatoField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> staccatissimoField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> spiccatoField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyline> scoopField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyline> plopField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyline> doitField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyline> falloffField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<breathmark> breathmarkField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> caesuraField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> stressField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> unstressField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<placementtext> otherarticulationField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator articulations(XElement xe) { return XTypedServices.ToXTypedElement<articulations>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static articulations() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// Articulations and accents are grouped together here.
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public articulations() {
    }
    
    /// <summary>
    /// <para>
    /// The accent element indicates a regular horizontal accent mark.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> accent {
        get {
            if ((this.accentField == null)) {
                this.accentField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("accent", ""));
            }
            return this.accentField;
        }
        set {
            if ((value == null)) {
                this.accentField = null;
            }
            else {
                if ((this.accentField == null)) {
                    this.accentField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("accent", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.accentField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The strong-accent element indicates a vertical accent mark.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public IList<strongaccent> strongaccent {
        get {
            if ((this.strongaccentField == null)) {
                this.strongaccentField = new XTypedList<strongaccent>(this, LinqToXsdTypeManager.Instance, XName.Get("strong-accent", ""));
            }
            return this.strongaccentField;
        }
        set {
            if ((value == null)) {
                this.strongaccentField = null;
            }
            else {
                if ((this.strongaccentField == null)) {
                    this.strongaccentField = XTypedList<strongaccent>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("strong-accent", ""));
                }
                else {
                    XTypedServices.SetList<strongaccent>(this.strongaccentField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The staccato element is used for a dot articulation, as opposed to a stroke or a wedge.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> staccato {
        get {
            if ((this.staccatoField == null)) {
                this.staccatoField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("staccato", ""));
            }
            return this.staccatoField;
        }
        set {
            if ((value == null)) {
                this.staccatoField = null;
            }
            else {
                if ((this.staccatoField == null)) {
                    this.staccatoField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("staccato", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.staccatoField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The tenuto element indicates a tenuto line symbol.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> tenuto {
        get {
            if ((this.tenutoField == null)) {
                this.tenutoField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("tenuto", ""));
            }
            return this.tenutoField;
        }
        set {
            if ((value == null)) {
                this.tenutoField = null;
            }
            else {
                if ((this.tenutoField == null)) {
                    this.tenutoField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("tenuto", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.tenutoField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The detached-legato element indicates the combination of a tenuto line and staccato dot symbol.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> detachedlegato {
        get {
            if ((this.detachedlegatoField == null)) {
                this.detachedlegatoField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("detached-legato", ""));
            }
            return this.detachedlegatoField;
        }
        set {
            if ((value == null)) {
                this.detachedlegatoField = null;
            }
            else {
                if ((this.detachedlegatoField == null)) {
                    this.detachedlegatoField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("detached-legato", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.detachedlegatoField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The staccatissimo element is used for a wedge articulation, as opposed to a dot or a stroke.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> staccatissimo {
        get {
            if ((this.staccatissimoField == null)) {
                this.staccatissimoField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("staccatissimo", ""));
            }
            return this.staccatissimoField;
        }
        set {
            if ((value == null)) {
                this.staccatissimoField = null;
            }
            else {
                if ((this.staccatissimoField == null)) {
                    this.staccatissimoField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("staccatissimo", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.staccatissimoField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The spiccato element is used for a stroke articulation, as opposed to a dot or a wedge.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> spiccato {
        get {
            if ((this.spiccatoField == null)) {
                this.spiccatoField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("spiccato", ""));
            }
            return this.spiccatoField;
        }
        set {
            if ((value == null)) {
                this.spiccatoField = null;
            }
            else {
                if ((this.spiccatoField == null)) {
                    this.spiccatoField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("spiccato", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.spiccatoField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The scoop element is an indeterminate slide attached to a single note. The scoop element appears before the main note and comes from below the main pitch.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public IList<emptyline> scoop {
        get {
            if ((this.scoopField == null)) {
                this.scoopField = new XTypedList<emptyline>(this, LinqToXsdTypeManager.Instance, XName.Get("scoop", ""));
            }
            return this.scoopField;
        }
        set {
            if ((value == null)) {
                this.scoopField = null;
            }
            else {
                if ((this.scoopField == null)) {
                    this.scoopField = XTypedList<emptyline>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("scoop", ""));
                }
                else {
                    XTypedServices.SetList<emptyline>(this.scoopField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The plop element is an indeterminate slide attached to a single note. The plop element appears before the main note and comes from above the main pitch.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public IList<emptyline> plop {
        get {
            if ((this.plopField == null)) {
                this.plopField = new XTypedList<emptyline>(this, LinqToXsdTypeManager.Instance, XName.Get("plop", ""));
            }
            return this.plopField;
        }
        set {
            if ((value == null)) {
                this.plopField = null;
            }
            else {
                if ((this.plopField == null)) {
                    this.plopField = XTypedList<emptyline>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("plop", ""));
                }
                else {
                    XTypedServices.SetList<emptyline>(this.plopField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The doit element is an indeterminate slide attached to a single note. The doit element appears after the main note and goes above the main pitch.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public IList<emptyline> doit {
        get {
            if ((this.doitField == null)) {
                this.doitField = new XTypedList<emptyline>(this, LinqToXsdTypeManager.Instance, XName.Get("doit", ""));
            }
            return this.doitField;
        }
        set {
            if ((value == null)) {
                this.doitField = null;
            }
            else {
                if ((this.doitField == null)) {
                    this.doitField = XTypedList<emptyline>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("doit", ""));
                }
                else {
                    XTypedServices.SetList<emptyline>(this.doitField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The falloff element is an indeterminate slide attached to a single note. The falloff element appears before the main note and goes below the main pitch.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public IList<emptyline> falloff {
        get {
            if ((this.falloffField == null)) {
                this.falloffField = new XTypedList<emptyline>(this, LinqToXsdTypeManager.Instance, XName.Get("falloff", ""));
            }
            return this.falloffField;
        }
        set {
            if ((value == null)) {
                this.falloffField = null;
            }
            else {
                if ((this.falloffField == null)) {
                    this.falloffField = XTypedList<emptyline>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("falloff", ""));
                }
                else {
                    XTypedServices.SetList<emptyline>(this.falloffField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public IList<breathmark> breathmark {
        get {
            if ((this.breathmarkField == null)) {
                this.breathmarkField = new XTypedList<breathmark>(this, LinqToXsdTypeManager.Instance, XName.Get("breath-mark", ""));
            }
            return this.breathmarkField;
        }
        set {
            if ((value == null)) {
                this.breathmarkField = null;
            }
            else {
                if ((this.breathmarkField == null)) {
                    this.breathmarkField = XTypedList<breathmark>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("breath-mark", ""));
                }
                else {
                    XTypedServices.SetList<breathmark>(this.breathmarkField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The caesura element indicates a slight pause. It is notated using a "railroad tracks" symbol.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> caesura {
        get {
            if ((this.caesuraField == null)) {
                this.caesuraField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("caesura", ""));
            }
            return this.caesuraField;
        }
        set {
            if ((value == null)) {
                this.caesuraField = null;
            }
            else {
                if ((this.caesuraField == null)) {
                    this.caesuraField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("caesura", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.caesuraField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The stress element indicates a stressed note.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> stress {
        get {
            if ((this.stressField == null)) {
                this.stressField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("stress", ""));
            }
            return this.stressField;
        }
        set {
            if ((value == null)) {
                this.stressField = null;
            }
            else {
                if ((this.stressField == null)) {
                    this.stressField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("stress", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.stressField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The unstress element indicates an unstressed note. It is often notated using a u-shaped symbol.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> unstress {
        get {
            if ((this.unstressField == null)) {
                this.unstressField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("unstress", ""));
            }
            return this.unstressField;
        }
        set {
            if ((value == null)) {
                this.unstressField = null;
            }
            else {
                if ((this.unstressField == null)) {
                    this.unstressField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("unstress", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.unstressField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The other-articulation element is used to define any articulations not yet in the MusicXML format. This allows extended representation, though without application interoperability.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (accent | strongaccent | staccato | tenuto | detachedlegato | staccatissimo | spiccato | scoop | plop | doit | falloff | breathmark | caesura | stress | unstress | otherarticulation)*
    /// </para>
    /// </summary>
    public IList<placementtext> otherarticulation {
        get {
            if ((this.otherarticulationField == null)) {
                this.otherarticulationField = new XTypedList<placementtext>(this, LinqToXsdTypeManager.Instance, XName.Get("other-articulation", ""));
            }
            return this.otherarticulationField;
        }
        set {
            if ((value == null)) {
                this.otherarticulationField = null;
            }
            else {
                if ((this.otherarticulationField == null)) {
                    this.otherarticulationField = XTypedList<placementtext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("other-articulation", ""));
                }
                else {
                    XTypedServices.SetList<placementtext>(this.otherarticulationField, value);
                }
            }
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("articulations", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<articulations>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("accent", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("strong-accent", ""), typeof(strongaccent));
        localElementDictionary.Add(XName.Get("staccato", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("tenuto", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("detached-legato", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("staccatissimo", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("spiccato", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("scoop", ""), typeof(emptyline));
        localElementDictionary.Add(XName.Get("plop", ""), typeof(emptyline));
        localElementDictionary.Add(XName.Get("doit", ""), typeof(emptyline));
        localElementDictionary.Add(XName.Get("falloff", ""), typeof(emptyline));
        localElementDictionary.Add(XName.Get("breath-mark", ""), typeof(breathmark));
        localElementDictionary.Add(XName.Get("caesura", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("stress", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("unstress", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("other-articulation", ""), typeof(placementtext));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The arrow element represents an arrow used for a musical technical indication..
/// </para>
/// <para>
/// Regular expression: ((arrowdirection, arrowstyle?)|circulararrow)
/// </para>
/// </summary>
public partial class arrow : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator arrow(XElement xe) { return XTypedServices.ToXTypedElement<arrow>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static arrow() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The arrow element represents an arrow used for a musical technical indication..
    /// </para>
    /// <para>
    /// Regular expression: ((arrowdirection, arrowstyle?)|circulararrow)
    /// </para>
    /// </summary>
    public arrow() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((arrowdirection, arrowstyle?)|circulararrow)
    /// </para>
    /// </summary>
    public string arrowdirection {
        get {
            XElement x = this.GetElement(XName.Get("arrow-direction", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("arrow-direction", ""), value, "arrowdirection", global::arrowdirection.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((arrowdirection, arrowstyle?)|circulararrow)
    /// </para>
    /// </summary>
    public string arrowstyle {
        get {
            XElement x = this.GetElement(XName.Get("arrow-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("arrow-style", ""), value, "arrowstyle", global::arrowstyle.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: ((arrowdirection, arrowstyle?)|circulararrow)
    /// </para>
    /// </summary>
    public string circulararrow {
        get {
            XElement x = this.GetElement(XName.Get("circular-arrow", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("circular-arrow", ""), value, "circulararrow", global::circulararrow.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("arrow", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<arrow>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("arrow-direction", ""), typeof(string));
        localElementDictionary.Add(XName.Get("arrow-style", ""), typeof(string));
        localElementDictionary.Add(XName.Get("circular-arrow", ""), typeof(string));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The backup and forward elements are required to coordinate multiple voices in one part, including music on multiple staves. The backup type is generally used to move between voices and staves. Thus the backup element does not include voice or staff elements. Duration values should always be positive, and should not cross measure boundaries or mid-measure changes in the divisions value.
/// </para>
/// <para>
/// Regular expression: (duration, (footnote)?, (level)?)
/// </para>
/// </summary>
public partial class backup : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator backup(XElement xe) { return XTypedServices.ToXTypedElement<backup>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static backup() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The backup and forward elements are required to coordinate multiple voices in one part, including music on multiple staves. The backup type is generally used to move between voices and staves. Thus the backup element does not include voice or staff elements. Duration values should always be positive, and should not cross measure boundaries or mid-measure changes in the divisions value.
    /// </para>
    /// <para>
    /// Regular expression: (duration, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public backup() {
    }
    
    /// <summary>
    /// <para>
    /// Duration is a positive number specified in division units. This is the intended duration vs. notated duration (for instance, swing eighths vs. even eighths, or differences in dotted notes in Baroque-era music). Differences in duration specific to an interpretation or performance should use the note element's attack and release attributes.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (duration, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public decimal duration {
        get {
            XElement x = this.GetElement(XName.Get("duration", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("duration", ""), value, "duration", global::positivedivisions.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (duration, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public formattedtext footnote {
        get {
            XElement x = this.GetElement(XName.Get("footnote", ""));
            return ((formattedtext)(x));
        }
        set {
            this.SetElement(XName.Get("footnote", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (duration, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public level level {
        get {
            XElement x = this.GetElement(XName.Get("level", ""));
            return ((level)(x));
        }
        set {
            this.SetElement(XName.Get("level", ""), value);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("backup", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<backup>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("duration", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("footnote", ""), typeof(formattedtext));
        localElementDictionary.Add(XName.Get("level", ""), typeof(level));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Beam values include begin, continue, end, forward hook, and backward hook. Up to eight concurrent beams are available to cover up to 1024th notes. Each beam in a note is represented with a separate beam element, starting with the eighth note beam using a number attribute of 1.
///
///Note that the beam number does not distinguish sets of beams that overlap, as it does for slur and other elements. Beaming groups are distinguished by being in different voices and/or the presence or absence of grace and cue elements.
///
///Beams that have a begin value can also have a fan attribute to indicate accelerandos and ritardandos using fanned beams. The fan attribute may also be used with a continue value if the fanning direction changes on that note. The value is "none" if not specified.
///	
///The repeater attribute has been deprecated in MusicXML 3.0. Formerly used for tremolos, it needs to be specified with a "yes" value for each beam using it.
/// </para>
/// </summary>
public partial class beam : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static decimal numberDefaultValue = System.Xml.XmlConvert.ToDecimal("1");
    
         public static explicit operator beam(XElement xe) { return XTypedServices.ToXTypedElement<beam>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// Beam values include begin, continue, end, forward hook, and backward hook. Up to eight concurrent beams are available to cover up to 1024th notes. Each beam in a note is represented with a separate beam element, starting with the eighth note beam using a number attribute of 1.
    ///
    ///Note that the beam number does not distinguish sets of beams that overlap, as it does for slur and other elements. Beaming groups are distinguished by being in different voices and/or the presence or absence of grace and cue elements.
    ///
    ///Beams that have a begin value can also have a fan attribute to indicate accelerandos and ritardandos using fanned beams. The fan attribute may also be used with a continue value if the fanning direction changes on that note. The value is "none" if not specified.
    ///	
    ///The repeater attribute has been deprecated in MusicXML 3.0. Formerly used for tremolos, it needs to be specified with a "yes" value for each beam using it.
    /// </para>
    /// </summary>
    public beam() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::beamvalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public decimal number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype, numberDefaultValue);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string repeater {
        get {
            XAttribute x = this.Attribute(XName.Get("repeater", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("repeater", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fan {
        get {
            XAttribute x = this.Attribute(XName.Get("fan", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("fan", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("beam", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<beam>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The bend type is used in guitar and tablature. The bend-alter element indicates the number of steps in the bend, similar to the alter element. As with the alter element, numbers like 0.5 can be used to indicate microtones. Negative numbers indicate pre-bends or releases; the pre-bend and release elements are used to distinguish what is intended. A with-bar element indicates that the bend is to be done at the bridge with a whammy or vibrato bar. The content of the element indicates how this should be notated.
/// </para>
/// <para>
/// Regular expression: (bendalter, (prebend | release)?, withbar?)
/// </para>
/// </summary>
public partial class bend : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator bend(XElement xe) { return XTypedServices.ToXTypedElement<bend>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static bend() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The bend type is used in guitar and tablature. The bend-alter element indicates the number of steps in the bend, similar to the alter element. As with the alter element, numbers like 0.5 can be used to indicate microtones. Negative numbers indicate pre-bends or releases; the pre-bend and release elements are used to distinguish what is intended. A with-bar element indicates that the bend is to be done at the bridge with a whammy or vibrato bar. The content of the element indicates how this should be notated.
    /// </para>
    /// <para>
    /// Regular expression: (bendalter, (prebend | release)?, withbar?)
    /// </para>
    /// </summary>
    public bend() {
    }
    
    /// <summary>
    /// <para>
    /// The bend-alter element indicates the number of steps in the bend, similar to the alter element. As with the alter element, numbers like 0.5 can be used to indicate microtones. Negative numbers indicate pre-bends or releases; the pre-bend and release elements are used to distinguish what is intended.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (bendalter, (prebend | release)?, withbar?)
    /// </para>
    /// </summary>
    public decimal bendalter {
        get {
            XElement x = this.GetElement(XName.Get("bend-alter", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("bend-alter", ""), value, "bendalter", global::semitones.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The pre-bend element indicates that this is a pre-bend rather than a normal bend or a release.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (bendalter, (prebend | release)?, withbar?)
    /// </para>
    /// </summary>
    public empty prebend {
        get {
            XElement x = this.GetElement(XName.Get("pre-bend", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("pre-bend", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The release element indicates that this is a release rather than a normal bend or pre-bend.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (bendalter, (prebend | release)?, withbar?)
    /// </para>
    /// </summary>
    public empty release {
        get {
            XElement x = this.GetElement(XName.Get("release", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("release", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The with-bar element indicates that the bend is to be done at the bridge with a whammy or vibrato bar. The content of the element indicates how this should be notated.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (bendalter, (prebend | release)?, withbar?)
    /// </para>
    /// </summary>
    public placementtext withbar {
        get {
            XElement x = this.GetElement(XName.Get("with-bar", ""));
            return ((placementtext)(x));
        }
        set {
            this.SetElement(XName.Get("with-bar", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string accelerate {
        get {
            XAttribute x = this.Attribute(XName.Get("accelerate", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("accelerate", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> beats {
        get {
            XAttribute x = this.Attribute(XName.Get("beats", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("beats", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> firstbeat {
        get {
            XAttribute x = this.Attribute(XName.Get("first-beat", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("first-beat", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> lastbeat {
        get {
            XAttribute x = this.Attribute(XName.Get("last-beat", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("last-beat", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("bend", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<bend>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("bend-alter", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("pre-bend", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("release", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("with-bar", ""), typeof(placementtext));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The breath-mark element indicates a place to take a breath.
/// </para>
/// </summary>
public partial class breathmark : XTypedElement, IXMetaData {
    
         public static explicit operator breathmark(XElement xe) { return XTypedServices.ToXTypedElement<breathmark>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The breath-mark element indicates a place to take a breath.
    /// </para>
    /// </summary>
    public breathmark() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::breathmarkvalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("breath-mark", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<breathmark>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The empty-line type represents an empty element with line-shape, line-type, dashed-formatting, print-style and placement attributes.
/// </para>
/// </summary>
public partial class emptyline : XTypedElement, IXMetaData {
    
         public static explicit operator emptyline(XElement xe) { return XTypedServices.ToXTypedElement<emptyline>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The empty-line type represents an empty element with line-shape, line-type, dashed-formatting, print-style and placement attributes.
    /// </para>
    /// </summary>
    public emptyline() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string lineshape {
        get {
            XAttribute x = this.Attribute(XName.Get("line-shape", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line-shape", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string linetype {
        get {
            XAttribute x = this.Attribute(XName.Get("line-type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line-type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> dashlength {
        get {
            XAttribute x = this.Attribute(XName.Get("dash-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dash-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> spacelength {
        get {
            XAttribute x = this.Attribute(XName.Get("space-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("space-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("empty-line", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<emptyline>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The extend type represents lyric word extension / melisma lines as well as figured bass extensions. The optional type and position attributes are added in Version 3.0 to provide better formatting control.
/// </para>
/// </summary>
public partial class extend : XTypedElement, IXMetaData {
    
         public static explicit operator extend(XElement xe) { return XTypedServices.ToXTypedElement<extend>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The extend type represents lyric word extension / melisma lines as well as figured bass extensions. The optional type and position attributes are added in Version 3.0 to provide better formatting control.
    /// </para>
    /// </summary>
    public extend() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("extend", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<extend>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The figure type represents a single figure within a figured-bass element.
/// </para>
/// <para>
/// Regular expression: (prefix?, figurenumber?, suffix?, extend?)
/// </para>
/// </summary>
public partial class figure : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator figure(XElement xe) { return XTypedServices.ToXTypedElement<figure>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static figure() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("prefix", "")), new NamedContentModelEntity(XName.Get("figure-number", "")), new NamedContentModelEntity(XName.Get("suffix", "")), new NamedContentModelEntity(XName.Get("extend", "")));
    }
    
    /// <summary>
    /// <para>
    /// The figure type represents a single figure within a figured-bass element.
    /// </para>
    /// <para>
    /// Regular expression: (prefix?, figurenumber?, suffix?, extend?)
    /// </para>
    /// </summary>
    public figure() {
    }
    
    /// <summary>
    /// <para>
    /// Values for the prefix element include the accidental values sharp, flat, natural, double-sharp, flat-flat, and sharp-sharp. The prefix element may contain additional values for symbols specific to particular figured bass styles.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (prefix?, figurenumber?, suffix?, extend?)
    /// </para>
    /// </summary>
    public styletext prefix {
        get {
            XElement x = this.GetElement(XName.Get("prefix", ""));
            return ((styletext)(x));
        }
        set {
            this.SetElement(XName.Get("prefix", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// A figure-number is a number. Overstrikes of the figure number are represented in the suffix element.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (prefix?, figurenumber?, suffix?, extend?)
    /// </para>
    /// </summary>
    public styletext figurenumber {
        get {
            XElement x = this.GetElement(XName.Get("figure-number", ""));
            return ((styletext)(x));
        }
        set {
            this.SetElement(XName.Get("figure-number", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Values for the suffix element include the accidental values sharp, flat, natural, double-sharp, flat-flat, and sharp-sharp. Suffixes include both symbols that come after the figure number and those that overstrike the figure number. The suffix value slash is used for slashed numbers indicating chromatic alteration. The orientation and display of the slash usually depends on the figure number. The suffix element may contain additional values for symbols specific to particular figured bass styles.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (prefix?, figurenumber?, suffix?, extend?)
    /// </para>
    /// </summary>
    public styletext suffix {
        get {
            XElement x = this.GetElement(XName.Get("suffix", ""));
            return ((styletext)(x));
        }
        set {
            this.SetElement(XName.Get("suffix", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (prefix?, figurenumber?, suffix?, extend?)
    /// </para>
    /// </summary>
    public extend extend {
        get {
            XElement x = this.GetElement(XName.Get("extend", ""));
            return ((extend)(x));
        }
        set {
            this.SetElement(XName.Get("extend", ""), value);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("figure", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<figure>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("prefix", ""), typeof(styletext));
        localElementDictionary.Add(XName.Get("figure-number", ""), typeof(styletext));
        localElementDictionary.Add(XName.Get("suffix", ""), typeof(styletext));
        localElementDictionary.Add(XName.Get("extend", ""), typeof(extend));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The figured-bass element represents figured bass notation. Figured bass elements take their position from the first regular note (not a grace note or chord note) that follows in score order. The optional duration element is used to indicate changes of figures under a note.
///	
///Figures are ordered from top to bottom. The value of parentheses is "no" if not present.
/// </para>
/// <para>
/// Regular expression: (figure+, (duration)?, (footnote)?, (level)?)
/// </para>
/// </summary>
public partial class figuredbass : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<figure> figureField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator figuredbass(XElement xe) { return XTypedServices.ToXTypedElement<figuredbass>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static figuredbass() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The figured-bass element represents figured bass notation. Figured bass elements take their position from the first regular note (not a grace note or chord note) that follows in score order. The optional duration element is used to indicate changes of figures under a note.
    ///	
    ///Figures are ordered from top to bottom. The value of parentheses is "no" if not present.
    /// </para>
    /// <para>
    /// Regular expression: (figure+, (duration)?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public figuredbass() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, repeating
    /// </para>
    /// <para>
    /// Regular expression: (figure+, (duration)?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public IList<figure> figure {
        get {
            if ((this.figureField == null)) {
                this.figureField = new XTypedList<figure>(this, LinqToXsdTypeManager.Instance, XName.Get("figure", ""));
            }
            return this.figureField;
        }
        set {
            if ((value == null)) {
                this.figureField = null;
            }
            else {
                if ((this.figureField == null)) {
                    this.figureField = XTypedList<figure>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("figure", ""));
                }
                else {
                    XTypedServices.SetList<figure>(this.figureField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Duration is a positive number specified in division units. This is the intended duration vs. notated duration (for instance, swing eighths vs. even eighths, or differences in dotted notes in Baroque-era music). Differences in duration specific to an interpretation or performance should use the note element's attack and release attributes.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (figure+, (duration)?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> duration {
        get {
            XElement x = this.GetElement(XName.Get("duration", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("duration", ""), value, "duration", global::positivedivisions.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (figure+, (duration)?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public formattedtext footnote {
        get {
            XElement x = this.GetElement(XName.Get("footnote", ""));
            return ((formattedtext)(x));
        }
        set {
            this.SetElement(XName.Get("footnote", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (figure+, (duration)?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public level level {
        get {
            XElement x = this.GetElement(XName.Get("level", ""));
            return ((level)(x));
        }
        set {
            this.SetElement(XName.Get("level", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printdot {
        get {
            XAttribute x = this.Attribute(XName.Get("print-dot", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-dot", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printspacing {
        get {
            XAttribute x = this.Attribute(XName.Get("print-spacing", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-spacing", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printlyric {
        get {
            XAttribute x = this.Attribute(XName.Get("print-lyric", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-lyric", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string parentheses {
        get {
            XAttribute x = this.Attribute(XName.Get("parentheses", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("parentheses", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("figured-bass", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<figuredbass>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("figure", ""), typeof(figure));
        localElementDictionary.Add(XName.Get("duration", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("footnote", ""), typeof(formattedtext));
        localElementDictionary.Add(XName.Get("level", ""), typeof(level));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The backup and forward elements are required to coordinate multiple voices in one part, including music on multiple staves. The forward element is generally used within voices and staves. Duration values should always be positive, and should not cross measure boundaries or mid-measure changes in the divisions value.
/// </para>
/// <para>
/// Regular expression: (duration, (footnote)?, (level)?, (voice)?, (staff)?)
/// </para>
/// </summary>
public partial class forward : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator forward(XElement xe) { return XTypedServices.ToXTypedElement<forward>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static forward() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The backup and forward elements are required to coordinate multiple voices in one part, including music on multiple staves. The forward element is generally used within voices and staves. Duration values should always be positive, and should not cross measure boundaries or mid-measure changes in the divisions value.
    /// </para>
    /// <para>
    /// Regular expression: (duration, (footnote)?, (level)?, (voice)?, (staff)?)
    /// </para>
    /// </summary>
    public forward() {
    }
    
    /// <summary>
    /// <para>
    /// Duration is a positive number specified in division units. This is the intended duration vs. notated duration (for instance, swing eighths vs. even eighths, or differences in dotted notes in Baroque-era music). Differences in duration specific to an interpretation or performance should use the note element's attack and release attributes.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (duration, (footnote)?, (level)?, (voice)?, (staff)?)
    /// </para>
    /// </summary>
    public decimal duration {
        get {
            XElement x = this.GetElement(XName.Get("duration", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("duration", ""), value, "duration", global::positivedivisions.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (duration, (footnote)?, (level)?, (voice)?, (staff)?)
    /// </para>
    /// </summary>
    public formattedtext footnote {
        get {
            XElement x = this.GetElement(XName.Get("footnote", ""));
            return ((formattedtext)(x));
        }
        set {
            this.SetElement(XName.Get("footnote", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (duration, (footnote)?, (level)?, (voice)?, (staff)?)
    /// </para>
    /// </summary>
    public level level {
        get {
            XElement x = this.GetElement(XName.Get("level", ""));
            return ((level)(x));
        }
        set {
            this.SetElement(XName.Get("level", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (duration, (footnote)?, (level)?, (voice)?, (staff)?)
    /// </para>
    /// </summary>
    public string voice {
        get {
            XElement x = this.GetElement(XName.Get("voice", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("voice", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Staff assignment is only needed for music notated on multiple staves. Used by both notes and directions. Staff values are numbers, with 1 referring to the top-most staff in a part.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (duration, (footnote)?, (level)?, (voice)?, (staff)?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> staff {
        get {
            XElement x = this.GetElement(XName.Get("staff", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetElement(XName.Get("staff", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("forward", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<forward>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("duration", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("footnote", ""), typeof(formattedtext));
        localElementDictionary.Add(XName.Get("level", ""), typeof(level));
        localElementDictionary.Add(XName.Get("voice", ""), typeof(string));
        localElementDictionary.Add(XName.Get("staff", ""), typeof(decimal));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Glissando and slide types both indicate rapidly moving from one pitch to the other so that individual notes are not discerned. The distinction is similar to that between NIFF's glissando and portamento elements. A glissando sounds the half notes in between the slide and defaults to a wavy line. The optional text is printed alongside the line.
/// </para>
/// </summary>
public partial class glissando : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static decimal numberDefaultValue = System.Xml.XmlConvert.ToDecimal("1");
    
         public static explicit operator glissando(XElement xe) { return XTypedServices.ToXTypedElement<glissando>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// Glissando and slide types both indicate rapidly moving from one pitch to the other so that individual notes are not discerned. The distinction is similar to that between NIFF's glissando and portamento elements. A glissando sounds the half notes in between the slide and defaults to a wavy line. The optional text is printed alongside the line.
    /// </para>
    /// </summary>
    public glissando() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public decimal number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype, numberDefaultValue);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string linetype {
        get {
            XAttribute x = this.Attribute(XName.Get("line-type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line-type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> dashlength {
        get {
            XAttribute x = this.Attribute(XName.Get("dash-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dash-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> spacelength {
        get {
            XAttribute x = this.Attribute(XName.Get("space-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("space-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("glissando", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<glissando>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The grace type indicates the presence of a grace note. The slash attribute for a grace note is yes for slashed eighth notes. The other grace note attributes come from MuseData sound suggestions. The steal-time-previous attribute indicates the percentage of time to steal from the previous note for the grace note. The steal-time-following attribute indicates the percentage of time to steal from the following note for the grace note, as for appoggiaturas. The make-time attribute indicates to make time, not steal time; the units are in real-time divisions for the grace note.
/// </para>
/// </summary>
public partial class grace : XTypedElement, IXMetaData {
    
         public static explicit operator grace(XElement xe) { return XTypedServices.ToXTypedElement<grace>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The grace type indicates the presence of a grace note. The slash attribute for a grace note is yes for slashed eighth notes. The other grace note attributes come from MuseData sound suggestions. The steal-time-previous attribute indicates the percentage of time to steal from the previous note for the grace note. The steal-time-following attribute indicates the percentage of time to steal from the following note for the grace note, as for appoggiaturas. The make-time attribute indicates to make time, not steal time; the units are in real-time divisions for the grace note.
    /// </para>
    /// </summary>
    public grace() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> stealtimeprevious {
        get {
            XAttribute x = this.Attribute(XName.Get("steal-time-previous", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("steal-time-previous", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> stealtimefollowing {
        get {
            XAttribute x = this.Attribute(XName.Get("steal-time-following", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("steal-time-following", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> maketime {
        get {
            XAttribute x = this.Attribute(XName.Get("make-time", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("make-time", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string slash {
        get {
            XAttribute x = this.Attribute(XName.Get("slash", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("slash", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("grace", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<grace>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The hammer-on and pull-off elements are used in guitar and fretted instrument notation. Since a single slur can be marked over many notes, the hammer-on and pull-off elements are separate so the individual pair of notes can be specified. The element content can be used to specify how the hammer-on or pull-off should be notated. An empty element leaves this choice up to the application.
/// </para>
/// </summary>
public partial class hammeronpulloff : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static decimal numberDefaultValue = System.Xml.XmlConvert.ToDecimal("1");
    
         public static explicit operator hammeronpulloff(XElement xe) { return XTypedServices.ToXTypedElement<hammeronpulloff>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The hammer-on and pull-off elements are used in guitar and fretted instrument notation. Since a single slur can be marked over many notes, the hammer-on and pull-off elements are separate so the individual pair of notes can be specified. The element content can be used to specify how the hammer-on or pull-off should be notated. An empty element leaves this choice up to the application.
    /// </para>
    /// </summary>
    public hammeronpulloff() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public decimal number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype, numberDefaultValue);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("hammer-on-pull-off", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<hammeronpulloff>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The handbell element represents notation for various techniques used in handbell and handchime music.
/// </para>
/// </summary>
public partial class handbell : XTypedElement, IXMetaData {
    
         public static explicit operator handbell(XElement xe) { return XTypedServices.ToXTypedElement<handbell>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The handbell element represents notation for various techniques used in handbell and handchime music.
    /// </para>
    /// </summary>
    public handbell() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::handbellvalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("handbell", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<handbell>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The harmonic type indicates natural and artificial harmonics. Allowing the type of pitch to be specified, combined with controls for appearance/playback differences, allows both the notation and the sound to be represented. Artificial harmonics can add a notated touching-pitch; artificial pinch harmonics will usually not notate a touching pitch. The attributes for the harmonic element refer to the use of the circular harmonic symbol, typically but not always used with natural harmonics.
/// </para>
/// <para>
/// Regular expression: ((natural | artificial)?, (basepitch | touchingpitch | soundingpitch)?)
/// </para>
/// </summary>
public partial class harmonic : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator harmonic(XElement xe) { return XTypedServices.ToXTypedElement<harmonic>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static harmonic() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The harmonic type indicates natural and artificial harmonics. Allowing the type of pitch to be specified, combined with controls for appearance/playback differences, allows both the notation and the sound to be represented. Artificial harmonics can add a notated touching-pitch; artificial pinch harmonics will usually not notate a touching pitch. The attributes for the harmonic element refer to the use of the circular harmonic symbol, typically but not always used with natural harmonics.
    /// </para>
    /// <para>
    /// Regular expression: ((natural | artificial)?, (basepitch | touchingpitch | soundingpitch)?)
    /// </para>
    /// </summary>
    public harmonic() {
    }
    
    /// <summary>
    /// <para>
    /// The natural element indicates that this is a natural harmonic. These are usually notated at base pitch rather than sounding pitch.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((natural | artificial)?, (basepitch | touchingpitch | soundingpitch)?)
    /// </para>
    /// </summary>
    public empty natural {
        get {
            XElement x = this.GetElement(XName.Get("natural", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("natural", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The artificial element indicates that this is an artificial harmonic.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((natural | artificial)?, (basepitch | touchingpitch | soundingpitch)?)
    /// </para>
    /// </summary>
    public empty artificial {
        get {
            XElement x = this.GetElement(XName.Get("artificial", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("artificial", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The base pitch is the pitch at which the string is played before touching to create the harmonic.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((natural | artificial)?, (basepitch | touchingpitch | soundingpitch)?)
    /// </para>
    /// </summary>
    public empty basepitch {
        get {
            XElement x = this.GetElement(XName.Get("base-pitch", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("base-pitch", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The touching-pitch is the pitch at which the string is touched lightly to produce the harmonic.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((natural | artificial)?, (basepitch | touchingpitch | soundingpitch)?)
    /// </para>
    /// </summary>
    public empty touchingpitch {
        get {
            XElement x = this.GetElement(XName.Get("touching-pitch", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("touching-pitch", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The sounding-pitch is the pitch which is heard when playing the harmonic.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((natural | artificial)?, (basepitch | touchingpitch | soundingpitch)?)
    /// </para>
    /// </summary>
    public empty soundingpitch {
        get {
            XElement x = this.GetElement(XName.Get("sounding-pitch", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("sounding-pitch", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("harmonic", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<harmonic>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("natural", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("artificial", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("base-pitch", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("touching-pitch", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("sounding-pitch", ""), typeof(empty));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The heel and toe elements are used with organ pedals. The substitution value is "no" if the attribute is not present.
/// </para>
/// </summary>
public partial class heeltoe : global::emptyplacement, IXMetaData {
    
         public static explicit operator heeltoe(XElement xe) { return XTypedServices.ToXTypedElement<heeltoe>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The heel and toe elements are used with organ pedals. The substitution value is "no" if the attribute is not present.
    /// </para>
    /// </summary>
    public heeltoe() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string substitution {
        get {
            XAttribute x = this.Attribute(XName.Get("substitution", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("substitution", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("heel-toe", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<heeltoe>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The hole type represents the symbols used for woodwind and brass fingerings as well as other notations.
/// </para>
/// <para>
/// Regular expression: (holetype?, holeclosed, holeshape?)
/// </para>
/// </summary>
public partial class hole : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator hole(XElement xe) { return XTypedServices.ToXTypedElement<hole>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static hole() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("hole-type", "")), new NamedContentModelEntity(XName.Get("hole-closed", "")), new NamedContentModelEntity(XName.Get("hole-shape", "")));
    }
    
    /// <summary>
    /// <para>
    /// The hole type represents the symbols used for woodwind and brass fingerings as well as other notations.
    /// </para>
    /// <para>
    /// Regular expression: (holetype?, holeclosed, holeshape?)
    /// </para>
    /// </summary>
    public hole() {
    }
    
    /// <summary>
    /// <para>
    /// The content of the optional hole-type element indicates what the hole symbol represents in terms of instrument fingering or other techniques.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (holetype?, holeclosed, holeshape?)
    /// </para>
    /// </summary>
    public string holetype {
        get {
            XElement x = this.GetElement(XName.Get("hole-type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("hole-type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (holetype?, holeclosed, holeshape?)
    /// </para>
    /// </summary>
    public holeclosed holeclosed {
        get {
            XElement x = this.GetElement(XName.Get("hole-closed", ""));
            return ((holeclosed)(x));
        }
        set {
            this.SetElement(XName.Get("hole-closed", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The optional hole-shape element indicates the shape of the hole symbol; the default is a circle.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (holetype?, holeclosed, holeshape?)
    /// </para>
    /// </summary>
    public string holeshape {
        get {
            XElement x = this.GetElement(XName.Get("hole-shape", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("hole-shape", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("hole", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<hole>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("hole-type", ""), typeof(string));
        localElementDictionary.Add(XName.Get("hole-closed", ""), typeof(holeclosed));
        localElementDictionary.Add(XName.Get("hole-shape", ""), typeof(string));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The hole-closed type represents whether the hole is closed, open, or half-open. The optional location attribute indicates which portion of the hole is filled in when the element value is half.
/// </para>
/// </summary>
public partial class holeclosed : XTypedElement, IXMetaData {
    
         public static explicit operator holeclosed(XElement xe) { return XTypedServices.ToXTypedElement<holeclosed>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The hole-closed type represents whether the hole is closed, open, or half-open. The optional location attribute indicates which portion of the hole is filled in when the element value is half.
    /// </para>
    /// </summary>
    public holeclosed() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::holeclosedvalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string location {
        get {
            XAttribute x = this.Attribute(XName.Get("location", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("location", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("hole-closed", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<holeclosed>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The instrument type distinguishes between score-instrument elements in a score-part. The id attribute is an IDREF back to the score-instrument ID. If multiple score-instruments are specified on a score-part, there should be an instrument element for each note in the part.
/// </para>
/// </summary>
public partial class instrument : XTypedElement, IXMetaData {
    
         public static explicit operator instrument(XElement xe) { return XTypedServices.ToXTypedElement<instrument>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The instrument type distinguishes between score-instrument elements in a score-part. The id attribute is an IDREF back to the score-instrument ID. If multiple score-instruments are specified on a score-part, there should be an instrument element for each note in the part.
    /// </para>
    /// </summary>
    public instrument() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string id {
        get {
            XAttribute x = this.Attribute(XName.Get("id", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("id", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Idref).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("instrument", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<instrument>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The lyric type represents text underlays for lyrics, based on Humdrum with support for other formats. Two text elements that are not separated by an elision element are part of the same syllable, but may have different text formatting. The MusicXML 2.0 XSD is more strict than the 2.0 DTD in enforcing this by disallowing a second syllabic element unless preceded by an elision element. The lyric number indicates multiple lines, though a name can be used as well (as in Finale's verse / chorus / section specification). Justification is center by default; placement is below by default. The content of the elision type is used to specify the symbol used to display the elision. Common values are a no-break space (Unicode 00A0), an underscore (Unicode 005F), or an undertie (Unicode 203F).
/// </para>
/// <para>
/// Regular expression: (((syllabic?, text, ((elision, syllabic?)?, text)*, extend?)|extend | laughing | humming), endline?, endparagraph?, (footnote)?, (level)?)
/// </para>
/// </summary>
public partial class lyric : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<string> syllabicField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<textelementdata> textField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<textfontcolor> elisionField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<extend> extendField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator lyric(XElement xe) { return XTypedServices.ToXTypedElement<lyric>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static lyric() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The lyric type represents text underlays for lyrics, based on Humdrum with support for other formats. Two text elements that are not separated by an elision element are part of the same syllable, but may have different text formatting. The MusicXML 2.0 XSD is more strict than the 2.0 DTD in enforcing this by disallowing a second syllabic element unless preceded by an elision element. The lyric number indicates multiple lines, though a name can be used as well (as in Finale's verse / chorus / section specification). Justification is center by default; placement is below by default. The content of the elision type is used to specify the symbol used to display the elision. Common values are a no-break space (Unicode 00A0), an underscore (Unicode 005F), or an undertie (Unicode 203F).
    /// </para>
    /// <para>
    /// Regular expression: (((syllabic?, text, ((elision, syllabic?)?, text)*, extend?)|extend | laughing | humming), endline?, endparagraph?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public lyric() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((syllabic?, text, ((elision, syllabic?)?, text)*, extend?)|extend | laughing | humming), endline?, endparagraph?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public IList<string> syllabic {
        get {
            if ((this.syllabicField == null)) {
                this.syllabicField = new XSimpleList<string>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, XName.Get("syllabic", ""));
            }
            return this.syllabicField;
        }
        set {
            if ((value == null)) {
                this.syllabicField = null;
            }
            else {
                if ((this.syllabicField == null)) {
                    this.syllabicField = XSimpleList<string>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, value, XName.Get("syllabic", ""));
                }
                else {
                    XTypedServices.SetList<System.String>(this.syllabicField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((syllabic?, text, ((elision, syllabic?)?, text)*, extend?)|extend | laughing | humming), endline?, endparagraph?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public IList<textelementdata> text {
        get {
            if ((this.textField == null)) {
                this.textField = new XTypedList<textelementdata>(this, LinqToXsdTypeManager.Instance, XName.Get("text", ""));
            }
            return this.textField;
        }
        set {
            if ((value == null)) {
                this.textField = null;
            }
            else {
                if ((this.textField == null)) {
                    this.textField = XTypedList<textelementdata>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("text", ""));
                }
                else {
                    XTypedServices.SetList<textelementdata>(this.textField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((syllabic?, text, ((elision, syllabic?)?, text)*, extend?)|extend | laughing | humming), endline?, endparagraph?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public IList<textfontcolor> elision {
        get {
            if ((this.elisionField == null)) {
                this.elisionField = new XTypedList<textfontcolor>(this, LinqToXsdTypeManager.Instance, XName.Get("elision", ""));
            }
            return this.elisionField;
        }
        set {
            if ((value == null)) {
                this.elisionField = null;
            }
            else {
                if ((this.elisionField == null)) {
                    this.elisionField = XTypedList<textfontcolor>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("elision", ""));
                }
                else {
                    XTypedServices.SetList<textfontcolor>(this.elisionField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((syllabic?, text, ((elision, syllabic?)?, text)*, extend?)|extend | laughing | humming), endline?, endparagraph?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public IList<extend> extend {
        get {
            if ((this.extendField == null)) {
                this.extendField = new XTypedList<extend>(this, LinqToXsdTypeManager.Instance, XName.Get("extend", ""));
            }
            return this.extendField;
        }
        set {
            if ((value == null)) {
                this.extendField = null;
            }
            else {
                if ((this.extendField == null)) {
                    this.extendField = XTypedList<extend>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("extend", ""));
                }
                else {
                    XTypedServices.SetList<extend>(this.extendField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The laughing element is taken from Humdrum.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((syllabic?, text, ((elision, syllabic?)?, text)*, extend?)|extend | laughing | humming), endline?, endparagraph?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public empty laughing {
        get {
            XElement x = this.GetElement(XName.Get("laughing", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("laughing", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The humming element is taken from Humdrum.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((syllabic?, text, ((elision, syllabic?)?, text)*, extend?)|extend | laughing | humming), endline?, endparagraph?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public empty humming {
        get {
            XElement x = this.GetElement(XName.Get("humming", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("humming", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The end-line element comes from RP-017 for Standard MIDI File Lyric meta-events. It facilitates lyric display for Karaoke and similar applications.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (((syllabic?, text, ((elision, syllabic?)?, text)*, extend?)|extend | laughing | humming), endline?, endparagraph?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public empty endline {
        get {
            XElement x = this.GetElement(XName.Get("end-line", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("end-line", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The end-paragraph element comes from RP-017 for Standard MIDI File Lyric meta-events. It facilitates lyric display for Karaoke and similar applications.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (((syllabic?, text, ((elision, syllabic?)?, text)*, extend?)|extend | laughing | humming), endline?, endparagraph?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public empty endparagraph {
        get {
            XElement x = this.GetElement(XName.Get("end-paragraph", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("end-paragraph", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((syllabic?, text, ((elision, syllabic?)?, text)*, extend?)|extend | laughing | humming), endline?, endparagraph?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public formattedtext footnote {
        get {
            XElement x = this.GetElement(XName.Get("footnote", ""));
            return ((formattedtext)(x));
        }
        set {
            this.SetElement(XName.Get("footnote", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((syllabic?, text, ((elision, syllabic?)?, text)*, extend?)|extend | laughing | humming), endline?, endparagraph?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public level level {
        get {
            XElement x = this.GetElement(XName.Get("level", ""));
            return ((level)(x));
        }
        set {
            this.SetElement(XName.Get("level", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string name {
        get {
            XAttribute x = this.Attribute(XName.Get("name", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string justify {
        get {
            XAttribute x = this.Attribute(XName.Get("justify", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("justify", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("lyric", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<lyric>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("syllabic", ""), typeof(string));
        localElementDictionary.Add(XName.Get("text", ""), typeof(textelementdata));
        localElementDictionary.Add(XName.Get("elision", ""), typeof(textfontcolor));
        localElementDictionary.Add(XName.Get("extend", ""), typeof(extend));
        localElementDictionary.Add(XName.Get("laughing", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("humming", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("end-line", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("end-paragraph", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("footnote", ""), typeof(formattedtext));
        localElementDictionary.Add(XName.Get("level", ""), typeof(level));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The mordent type is used for both represents the mordent sign with the vertical line and the inverted-mordent sign without the line. The long attribute is "no" by default. The approach and departure attributes are used for compound ornaments, indicating how the beginning and ending of the ornament look relative to the main part of the mordent.
/// </para>
/// </summary>
public partial class mordent : global::emptytrillsound, IXMetaData {
    
         public static explicit operator mordent(XElement xe) { return XTypedServices.ToXTypedElement<mordent>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The mordent type is used for both represents the mordent sign with the vertical line and the inverted-mordent sign without the line. The long attribute is "no" by default. The approach and departure attributes are used for compound ornaments, indicating how the beginning and ending of the ornament look relative to the main part of the mordent.
    /// </para>
    /// </summary>
    public mordent() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string @long {
        get {
            XAttribute x = this.Attribute(XName.Get("long", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("long", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string approach {
        get {
            XAttribute x = this.Attribute(XName.Get("approach", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("approach", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string departure {
        get {
            XAttribute x = this.Attribute(XName.Get("departure", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("departure", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("mordent", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<mordent>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The non-arpeggiate type indicates that this note is at the top or bottom of a bracket indicating to not arpeggiate these notes. Since this does not involve playback, it is only used on the top or bottom notes, not on each note as for the arpeggiate type.
/// </para>
/// </summary>
public partial class nonarpeggiate : XTypedElement, IXMetaData {
    
         public static explicit operator nonarpeggiate(XElement xe) { return XTypedServices.ToXTypedElement<nonarpeggiate>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The non-arpeggiate type indicates that this note is at the top or bottom of a bracket indicating to not arpeggiate these notes. Since this does not involve playback, it is only used on the top or bottom notes, not on each note as for the arpeggiate type.
    /// </para>
    /// </summary>
    public nonarpeggiate() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("non-arpeggiate", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<nonarpeggiate>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Notations refer to musical notations, not XML notations. Multiple notations are allowed in order to represent multiple editorial levels. The print-object attribute, added in Version 3.0, allows notations to represent details of performance technique, such as fingerings, without having them appear in the score.
/// </para>
/// <para>
/// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
/// </para>
/// </summary>
public partial class notations : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<tied> tiedField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<slur> slurField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<tuplet> tupletField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<glissando> glissandoField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<slide> slideField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<ornaments> ornamentsField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<technical> technicalField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<articulations> articulationsField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<dynamics> dynamicsField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<fermata> fermataField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<arpeggiate> arpeggiateField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<nonarpeggiate> nonarpeggiateField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<accidentalmark> accidentalmarkField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<othernotation> othernotationField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator notations(XElement xe) { return XTypedServices.ToXTypedElement<notations>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static notations() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// Notations refer to musical notations, not XML notations. Multiple notations are allowed in order to represent multiple editorial levels. The print-object attribute, added in Version 3.0, allows notations to represent details of performance technique, such as fingerings, without having them appear in the score.
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public notations() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public formattedtext footnote {
        get {
            XElement x = this.GetElement(XName.Get("footnote", ""));
            return ((formattedtext)(x));
        }
        set {
            this.SetElement(XName.Get("footnote", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public level level {
        get {
            XElement x = this.GetElement(XName.Get("level", ""));
            return ((level)(x));
        }
        set {
            this.SetElement(XName.Get("level", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public IList<tied> tied {
        get {
            if ((this.tiedField == null)) {
                this.tiedField = new XTypedList<tied>(this, LinqToXsdTypeManager.Instance, XName.Get("tied", ""));
            }
            return this.tiedField;
        }
        set {
            if ((value == null)) {
                this.tiedField = null;
            }
            else {
                if ((this.tiedField == null)) {
                    this.tiedField = XTypedList<tied>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("tied", ""));
                }
                else {
                    XTypedServices.SetList<tied>(this.tiedField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public IList<slur> slur {
        get {
            if ((this.slurField == null)) {
                this.slurField = new XTypedList<slur>(this, LinqToXsdTypeManager.Instance, XName.Get("slur", ""));
            }
            return this.slurField;
        }
        set {
            if ((value == null)) {
                this.slurField = null;
            }
            else {
                if ((this.slurField == null)) {
                    this.slurField = XTypedList<slur>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("slur", ""));
                }
                else {
                    XTypedServices.SetList<slur>(this.slurField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public IList<tuplet> tuplet {
        get {
            if ((this.tupletField == null)) {
                this.tupletField = new XTypedList<tuplet>(this, LinqToXsdTypeManager.Instance, XName.Get("tuplet", ""));
            }
            return this.tupletField;
        }
        set {
            if ((value == null)) {
                this.tupletField = null;
            }
            else {
                if ((this.tupletField == null)) {
                    this.tupletField = XTypedList<tuplet>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("tuplet", ""));
                }
                else {
                    XTypedServices.SetList<tuplet>(this.tupletField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public IList<glissando> glissando {
        get {
            if ((this.glissandoField == null)) {
                this.glissandoField = new XTypedList<glissando>(this, LinqToXsdTypeManager.Instance, XName.Get("glissando", ""));
            }
            return this.glissandoField;
        }
        set {
            if ((value == null)) {
                this.glissandoField = null;
            }
            else {
                if ((this.glissandoField == null)) {
                    this.glissandoField = XTypedList<glissando>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("glissando", ""));
                }
                else {
                    XTypedServices.SetList<glissando>(this.glissandoField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public IList<slide> slide {
        get {
            if ((this.slideField == null)) {
                this.slideField = new XTypedList<slide>(this, LinqToXsdTypeManager.Instance, XName.Get("slide", ""));
            }
            return this.slideField;
        }
        set {
            if ((value == null)) {
                this.slideField = null;
            }
            else {
                if ((this.slideField == null)) {
                    this.slideField = XTypedList<slide>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("slide", ""));
                }
                else {
                    XTypedServices.SetList<slide>(this.slideField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public IList<ornaments> ornaments {
        get {
            if ((this.ornamentsField == null)) {
                this.ornamentsField = new XTypedList<ornaments>(this, LinqToXsdTypeManager.Instance, XName.Get("ornaments", ""));
            }
            return this.ornamentsField;
        }
        set {
            if ((value == null)) {
                this.ornamentsField = null;
            }
            else {
                if ((this.ornamentsField == null)) {
                    this.ornamentsField = XTypedList<ornaments>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("ornaments", ""));
                }
                else {
                    XTypedServices.SetList<ornaments>(this.ornamentsField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public IList<technical> technical {
        get {
            if ((this.technicalField == null)) {
                this.technicalField = new XTypedList<technical>(this, LinqToXsdTypeManager.Instance, XName.Get("technical", ""));
            }
            return this.technicalField;
        }
        set {
            if ((value == null)) {
                this.technicalField = null;
            }
            else {
                if ((this.technicalField == null)) {
                    this.technicalField = XTypedList<technical>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("technical", ""));
                }
                else {
                    XTypedServices.SetList<technical>(this.technicalField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public IList<articulations> articulations {
        get {
            if ((this.articulationsField == null)) {
                this.articulationsField = new XTypedList<articulations>(this, LinqToXsdTypeManager.Instance, XName.Get("articulations", ""));
            }
            return this.articulationsField;
        }
        set {
            if ((value == null)) {
                this.articulationsField = null;
            }
            else {
                if ((this.articulationsField == null)) {
                    this.articulationsField = XTypedList<articulations>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("articulations", ""));
                }
                else {
                    XTypedServices.SetList<articulations>(this.articulationsField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public IList<dynamics> dynamics {
        get {
            if ((this.dynamicsField == null)) {
                this.dynamicsField = new XTypedList<dynamics>(this, LinqToXsdTypeManager.Instance, XName.Get("dynamics", ""));
            }
            return this.dynamicsField;
        }
        set {
            if ((value == null)) {
                this.dynamicsField = null;
            }
            else {
                if ((this.dynamicsField == null)) {
                    this.dynamicsField = XTypedList<dynamics>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("dynamics", ""));
                }
                else {
                    XTypedServices.SetList<dynamics>(this.dynamicsField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public IList<fermata> fermata {
        get {
            if ((this.fermataField == null)) {
                this.fermataField = new XTypedList<fermata>(this, LinqToXsdTypeManager.Instance, XName.Get("fermata", ""));
            }
            return this.fermataField;
        }
        set {
            if ((value == null)) {
                this.fermataField = null;
            }
            else {
                if ((this.fermataField == null)) {
                    this.fermataField = XTypedList<fermata>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("fermata", ""));
                }
                else {
                    XTypedServices.SetList<fermata>(this.fermataField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public IList<arpeggiate> arpeggiate {
        get {
            if ((this.arpeggiateField == null)) {
                this.arpeggiateField = new XTypedList<arpeggiate>(this, LinqToXsdTypeManager.Instance, XName.Get("arpeggiate", ""));
            }
            return this.arpeggiateField;
        }
        set {
            if ((value == null)) {
                this.arpeggiateField = null;
            }
            else {
                if ((this.arpeggiateField == null)) {
                    this.arpeggiateField = XTypedList<arpeggiate>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("arpeggiate", ""));
                }
                else {
                    XTypedServices.SetList<arpeggiate>(this.arpeggiateField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public IList<nonarpeggiate> nonarpeggiate {
        get {
            if ((this.nonarpeggiateField == null)) {
                this.nonarpeggiateField = new XTypedList<nonarpeggiate>(this, LinqToXsdTypeManager.Instance, XName.Get("non-arpeggiate", ""));
            }
            return this.nonarpeggiateField;
        }
        set {
            if ((value == null)) {
                this.nonarpeggiateField = null;
            }
            else {
                if ((this.nonarpeggiateField == null)) {
                    this.nonarpeggiateField = XTypedList<nonarpeggiate>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("non-arpeggiate", ""));
                }
                else {
                    XTypedServices.SetList<nonarpeggiate>(this.nonarpeggiateField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public IList<accidentalmark> accidentalmark {
        get {
            if ((this.accidentalmarkField == null)) {
                this.accidentalmarkField = new XTypedList<accidentalmark>(this, LinqToXsdTypeManager.Instance, XName.Get("accidental-mark", ""));
            }
            return this.accidentalmarkField;
        }
        set {
            if ((value == null)) {
                this.accidentalmarkField = null;
            }
            else {
                if ((this.accidentalmarkField == null)) {
                    this.accidentalmarkField = XTypedList<accidentalmark>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("accidental-mark", ""));
                }
                else {
                    XTypedServices.SetList<accidentalmark>(this.accidentalmarkField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((footnote)?, (level)?, (tied | slur | tuplet | glissando | slide | ornaments | technical | articulations | dynamics | fermata | arpeggiate | nonarpeggiate | accidentalmark | othernotation)*)
    /// </para>
    /// </summary>
    public IList<othernotation> othernotation {
        get {
            if ((this.othernotationField == null)) {
                this.othernotationField = new XTypedList<othernotation>(this, LinqToXsdTypeManager.Instance, XName.Get("other-notation", ""));
            }
            return this.othernotationField;
        }
        set {
            if ((value == null)) {
                this.othernotationField = null;
            }
            else {
                if ((this.othernotationField == null)) {
                    this.othernotationField = XTypedList<othernotation>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("other-notation", ""));
                }
                else {
                    XTypedServices.SetList<othernotation>(this.othernotationField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("notations", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<notations>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("footnote", ""), typeof(formattedtext));
        localElementDictionary.Add(XName.Get("level", ""), typeof(level));
        localElementDictionary.Add(XName.Get("tied", ""), typeof(tied));
        localElementDictionary.Add(XName.Get("slur", ""), typeof(slur));
        localElementDictionary.Add(XName.Get("tuplet", ""), typeof(tuplet));
        localElementDictionary.Add(XName.Get("glissando", ""), typeof(glissando));
        localElementDictionary.Add(XName.Get("slide", ""), typeof(slide));
        localElementDictionary.Add(XName.Get("ornaments", ""), typeof(ornaments));
        localElementDictionary.Add(XName.Get("technical", ""), typeof(technical));
        localElementDictionary.Add(XName.Get("articulations", ""), typeof(articulations));
        localElementDictionary.Add(XName.Get("dynamics", ""), typeof(dynamics));
        localElementDictionary.Add(XName.Get("fermata", ""), typeof(fermata));
        localElementDictionary.Add(XName.Get("arpeggiate", ""), typeof(arpeggiate));
        localElementDictionary.Add(XName.Get("non-arpeggiate", ""), typeof(nonarpeggiate));
        localElementDictionary.Add(XName.Get("accidental-mark", ""), typeof(accidentalmark));
        localElementDictionary.Add(XName.Get("other-notation", ""), typeof(othernotation));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Notes are the most common type of MusicXML data. The MusicXML format keeps the MuseData distinction between elements used for sound information and elements used for notation information (e.g., tie is used for sound, tied for notation). Thus grace notes do not have a duration element. Cue notes have a duration element, as do forward elements, but no tie elements. Having these two types of information available can make interchange considerably easier, as some programs handle one type of information much more readily than the other. 
///	
///The dynamics and end-dynamics attributes correspond to MIDI 1.0's Note On and Note Off velocities, respectively. They are expressed in terms of percentages of the default forte value (90 for MIDI 1.0). The attack and release attributes are used to alter the starting and stopping time of the note from when it would otherwise occur based on the flow of durations - information that is specific to a performance. They are expressed in terms of divisions, either positive or negative. A note that starts a tie should not have a release attribute, and a note that stops a tie should not have an attack attribute. If a note is played only particular times through a repeat, the time-only attribute shows which times to play the note. The pizzicato attribute is used when just this note is sounded pizzicato, vs. the pizzicato element which changes overall playback between pizzicato and arco.
/// </para>
/// <para>
/// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
/// </para>
/// </summary>
public partial class note : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> chordField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<pitch> pitchField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<unpitched> unpitchedField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<rest> restField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<tie> tieField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<decimal> durationField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> dotField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<beam> beamField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<notations> notationsField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<lyric> lyricField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator note(XElement xe) { return XTypedServices.ToXTypedElement<note>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static note() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// Notes are the most common type of MusicXML data. The MusicXML format keeps the MuseData distinction between elements used for sound information and elements used for notation information (e.g., tie is used for sound, tied for notation). Thus grace notes do not have a duration element. Cue notes have a duration element, as do forward elements, but no tie elements. Having these two types of information available can make interchange considerably easier, as some programs handle one type of information much more readily than the other. 
    ///	
    ///The dynamics and end-dynamics attributes correspond to MIDI 1.0's Note On and Note Off velocities, respectively. They are expressed in terms of percentages of the default forte value (90 for MIDI 1.0). The attack and release attributes are used to alter the starting and stopping time of the note from when it would otherwise occur based on the flow of durations - information that is specific to a performance. They are expressed in terms of divisions, either positive or negative. A note that starts a tie should not have a release attribute, and a note that stops a tie should not have an attack attribute. If a note is played only particular times through a repeat, the time-only attribute shows which times to play the note. The pizzicato attribute is used when just this note is sounded pizzicato, vs. the pizzicato element which changes overall playback between pizzicato and arco.
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public note() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public grace grace {
        get {
            XElement x = this.GetElement(XName.Get("grace", ""));
            return ((grace)(x));
        }
        set {
            this.SetElement(XName.Get("grace", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The chord element indicates that this note is an additional chord tone with the preceding note. The duration of this note can be no longer than the preceding note. In MuseData, a missing duration indicates the same length as the previous note, but the MusicXML format requires a duration for chord notes too.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public IList<empty> chord {
        get {
            if ((this.chordField == null)) {
                this.chordField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("chord", ""));
            }
            return this.chordField;
        }
        set {
            if ((value == null)) {
                this.chordField = null;
            }
            else {
                if ((this.chordField == null)) {
                    this.chordField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("chord", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.chordField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public IList<pitch> pitch {
        get {
            if ((this.pitchField == null)) {
                this.pitchField = new XTypedList<pitch>(this, LinqToXsdTypeManager.Instance, XName.Get("pitch", ""));
            }
            return this.pitchField;
        }
        set {
            if ((value == null)) {
                this.pitchField = null;
            }
            else {
                if ((this.pitchField == null)) {
                    this.pitchField = XTypedList<pitch>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("pitch", ""));
                }
                else {
                    XTypedServices.SetList<pitch>(this.pitchField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public IList<unpitched> unpitched {
        get {
            if ((this.unpitchedField == null)) {
                this.unpitchedField = new XTypedList<unpitched>(this, LinqToXsdTypeManager.Instance, XName.Get("unpitched", ""));
            }
            return this.unpitchedField;
        }
        set {
            if ((value == null)) {
                this.unpitchedField = null;
            }
            else {
                if ((this.unpitchedField == null)) {
                    this.unpitchedField = XTypedList<unpitched>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("unpitched", ""));
                }
                else {
                    XTypedServices.SetList<unpitched>(this.unpitchedField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public IList<rest> rest {
        get {
            if ((this.restField == null)) {
                this.restField = new XTypedList<rest>(this, LinqToXsdTypeManager.Instance, XName.Get("rest", ""));
            }
            return this.restField;
        }
        set {
            if ((value == null)) {
                this.restField = null;
            }
            else {
                if ((this.restField == null)) {
                    this.restField = XTypedList<rest>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("rest", ""));
                }
                else {
                    XTypedServices.SetList<rest>(this.restField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public IList<tie> tie {
        get {
            if ((this.tieField == null)) {
                this.tieField = new XTypedList<tie>(this, LinqToXsdTypeManager.Instance, XName.Get("tie", ""));
            }
            return this.tieField;
        }
        set {
            if ((value == null)) {
                this.tieField = null;
            }
            else {
                if ((this.tieField == null)) {
                    this.tieField = XTypedList<tie>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("tie", ""));
                }
                else {
                    XTypedServices.SetList<tie>(this.tieField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The cue element indicates the presence of a cue note.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public empty cue {
        get {
            XElement x = this.GetElement(XName.Get("cue", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("cue", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Duration is a positive number specified in division units. This is the intended duration vs. notated duration (for instance, swing eighths vs. even eighths, or differences in dotted notes in Baroque-era music). Differences in duration specific to an interpretation or performance should use the note element's attack and release attributes.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public IList<decimal> duration {
        get {
            if ((this.durationField == null)) {
                this.durationField = new XSimpleList<decimal>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype, XName.Get("duration", ""));
            }
            return this.durationField;
        }
        set {
            if ((value == null)) {
                this.durationField = null;
            }
            else {
                if ((this.durationField == null)) {
                    this.durationField = XSimpleList<decimal>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype, value, XName.Get("duration", ""));
                }
                else {
                    XTypedServices.SetList<System.Decimal>(this.durationField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public instrument instrument {
        get {
            XElement x = this.GetElement(XName.Get("instrument", ""));
            return ((instrument)(x));
        }
        set {
            this.SetElement(XName.Get("instrument", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public formattedtext footnote {
        get {
            XElement x = this.GetElement(XName.Get("footnote", ""));
            return ((formattedtext)(x));
        }
        set {
            this.SetElement(XName.Get("footnote", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public level level {
        get {
            XElement x = this.GetElement(XName.Get("level", ""));
            return ((level)(x));
        }
        set {
            this.SetElement(XName.Get("level", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public string voice {
        get {
            XElement x = this.GetElement(XName.Get("voice", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("voice", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public notetype type {
        get {
            XElement x = this.GetElement(XName.Get("type", ""));
            return ((notetype)(x));
        }
        set {
            this.SetElement(XName.Get("type", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// One dot element is used for each dot of prolongation. The placement element is used to specify whether the dot should appear above or below the staff line. It is ignored for notes that appear on a staff space.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public IList<emptyplacement> dot {
        get {
            if ((this.dotField == null)) {
                this.dotField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("dot", ""));
            }
            return this.dotField;
        }
        set {
            if ((value == null)) {
                this.dotField = null;
            }
            else {
                if ((this.dotField == null)) {
                    this.dotField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("dot", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.dotField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public accidental accidental {
        get {
            XElement x = this.GetElement(XName.Get("accidental", ""));
            return ((accidental)(x));
        }
        set {
            this.SetElement(XName.Get("accidental", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public timemodification timemodification {
        get {
            XElement x = this.GetElement(XName.Get("time-modification", ""));
            return ((timemodification)(x));
        }
        set {
            this.SetElement(XName.Get("time-modification", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public stem stem {
        get {
            XElement x = this.GetElement(XName.Get("stem", ""));
            return ((stem)(x));
        }
        set {
            this.SetElement(XName.Get("stem", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public notehead notehead {
        get {
            XElement x = this.GetElement(XName.Get("notehead", ""));
            return ((notehead)(x));
        }
        set {
            this.SetElement(XName.Get("notehead", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public noteheadtext noteheadtext {
        get {
            XElement x = this.GetElement(XName.Get("notehead-text", ""));
            return ((noteheadtext)(x));
        }
        set {
            this.SetElement(XName.Get("notehead-text", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Staff assignment is only needed for music notated on multiple staves. Used by both notes and directions. Staff values are numbers, with 1 referring to the top-most staff in a part.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> staff {
        get {
            XElement x = this.GetElement(XName.Get("staff", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetElement(XName.Get("staff", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public IList<beam> beam {
        get {
            if ((this.beamField == null)) {
                this.beamField = new XTypedList<beam>(this, LinqToXsdTypeManager.Instance, XName.Get("beam", ""));
            }
            return this.beamField;
        }
        set {
            if ((value == null)) {
                this.beamField = null;
            }
            else {
                if ((this.beamField == null)) {
                    this.beamField = XTypedList<beam>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("beam", ""));
                }
                else {
                    XTypedServices.SetList<beam>(this.beamField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public IList<notations> notations {
        get {
            if ((this.notationsField == null)) {
                this.notationsField = new XTypedList<notations>(this, LinqToXsdTypeManager.Instance, XName.Get("notations", ""));
            }
            return this.notationsField;
        }
        set {
            if ((value == null)) {
                this.notationsField = null;
            }
            else {
                if ((this.notationsField == null)) {
                    this.notationsField = XTypedList<notations>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("notations", ""));
                }
                else {
                    XTypedServices.SetList<notations>(this.notationsField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public IList<lyric> lyric {
        get {
            if ((this.lyricField == null)) {
                this.lyricField = new XTypedList<lyric>(this, LinqToXsdTypeManager.Instance, XName.Get("lyric", ""));
            }
            return this.lyricField;
        }
        set {
            if ((value == null)) {
                this.lyricField = null;
            }
            else {
                if ((this.lyricField == null)) {
                    this.lyricField = XTypedList<lyric>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("lyric", ""));
                }
                else {
                    XTypedServices.SetList<lyric>(this.lyricField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (((grace, chord?, (pitch | unpitched | rest), tie*)|(cue, chord?, (pitch | unpitched | rest), duration)|(chord?, (pitch | unpitched | rest), duration, tie*)), instrument?, (footnote)?, (level)?, (voice)?, type?, dot*, accidental?, timemodification?, stem?, notehead?, noteheadtext?, (staff)?, beam*, notations*, lyric*, play?)
    /// </para>
    /// </summary>
    public play play {
        get {
            XElement x = this.GetElement(XName.Get("play", ""));
            return ((play)(x));
        }
        set {
            this.SetElement(XName.Get("play", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printdot {
        get {
            XAttribute x = this.Attribute(XName.Get("print-dot", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-dot", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printspacing {
        get {
            XAttribute x = this.Attribute(XName.Get("print-spacing", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-spacing", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printlyric {
        get {
            XAttribute x = this.Attribute(XName.Get("print-lyric", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-lyric", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> dynamics {
        get {
            XAttribute x = this.Attribute(XName.Get("dynamics", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dynamics", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> enddynamics {
        get {
            XAttribute x = this.Attribute(XName.Get("end-dynamics", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("end-dynamics", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> attack {
        get {
            XAttribute x = this.Attribute(XName.Get("attack", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("attack", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> release {
        get {
            XAttribute x = this.Attribute(XName.Get("release", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("release", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string timeonly {
        get {
            XAttribute x = this.Attribute(XName.Get("time-only", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("time-only", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string pizzicato {
        get {
            XAttribute x = this.Attribute(XName.Get("pizzicato", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("pizzicato", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("note", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<note>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("grace", ""), typeof(grace));
        localElementDictionary.Add(XName.Get("chord", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("pitch", ""), typeof(pitch));
        localElementDictionary.Add(XName.Get("unpitched", ""), typeof(unpitched));
        localElementDictionary.Add(XName.Get("rest", ""), typeof(rest));
        localElementDictionary.Add(XName.Get("tie", ""), typeof(tie));
        localElementDictionary.Add(XName.Get("cue", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("duration", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("instrument", ""), typeof(instrument));
        localElementDictionary.Add(XName.Get("footnote", ""), typeof(formattedtext));
        localElementDictionary.Add(XName.Get("level", ""), typeof(level));
        localElementDictionary.Add(XName.Get("voice", ""), typeof(string));
        localElementDictionary.Add(XName.Get("type", ""), typeof(notetype));
        localElementDictionary.Add(XName.Get("dot", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("accidental", ""), typeof(accidental));
        localElementDictionary.Add(XName.Get("time-modification", ""), typeof(timemodification));
        localElementDictionary.Add(XName.Get("stem", ""), typeof(stem));
        localElementDictionary.Add(XName.Get("notehead", ""), typeof(notehead));
        localElementDictionary.Add(XName.Get("notehead-text", ""), typeof(noteheadtext));
        localElementDictionary.Add(XName.Get("staff", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("beam", ""), typeof(beam));
        localElementDictionary.Add(XName.Get("notations", ""), typeof(notations));
        localElementDictionary.Add(XName.Get("lyric", ""), typeof(lyric));
        localElementDictionary.Add(XName.Get("play", ""), typeof(play));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The note-type type indicates the graphic note type. Values range from 256th to long. The size attribute indicates full, cue, or large size, with full the default for regular notes and cue the default for cue and grace notes.
/// </para>
/// </summary>
public partial class notetype : XTypedElement, IXMetaData {
    
         public static explicit operator notetype(XElement xe) { return XTypedServices.ToXTypedElement<notetype>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The note-type type indicates the graphic note type. Values range from 256th to long. The size attribute indicates full, cue, or large size, with full the default for regular notes and cue the default for cue and grace notes.
    /// </para>
    /// </summary>
    public notetype() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::notetypevalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string size {
        get {
            XAttribute x = this.Attribute(XName.Get("size", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("size", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("note-type", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<notetype>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The notehead element indicates shapes other than the open and closed ovals associated with note durations.
///	
///For the enclosed shapes, the default is to be hollow for half notes and longer, and filled otherwise. The filled attribute can be set to change this if needed.
///	
///If the parentheses attribute is set to yes, the notehead is parenthesized. It is no by default.
/// </para>
/// </summary>
public partial class notehead : XTypedElement, IXMetaData {
    
         public static explicit operator notehead(XElement xe) { return XTypedServices.ToXTypedElement<notehead>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The notehead element indicates shapes other than the open and closed ovals associated with note durations.
    ///	
    ///For the enclosed shapes, the default is to be hollow for half notes and longer, and filled otherwise. The filled attribute can be set to change this if needed.
    ///	
    ///If the parentheses attribute is set to yes, the notehead is parenthesized. It is no by default.
    /// </para>
    /// </summary>
    public notehead() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::noteheadvalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string filled {
        get {
            XAttribute x = this.Attribute(XName.Get("filled", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("filled", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string parentheses {
        get {
            XAttribute x = this.Attribute(XName.Get("parentheses", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("parentheses", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("notehead", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<notehead>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The notehead-text type represents text that is displayed inside a notehead, as is done in some educational music. It is not needed for the numbers used in tablature or jianpu notation. The presence of a TAB or jianpu clefs is sufficient to indicate that numbers are used. The display-text and accidental-text elements allow display of fully formatted text and accidentals.
/// </para>
/// <para>
/// Regular expression: ((displaytext | accidentaltext)+)
/// </para>
/// </summary>
public partial class noteheadtext : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<formattedtext> displaytextField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<accidentaltext> accidentaltextField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator noteheadtext(XElement xe) { return XTypedServices.ToXTypedElement<noteheadtext>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static noteheadtext() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The notehead-text type represents text that is displayed inside a notehead, as is done in some educational music. It is not needed for the numbers used in tablature or jianpu notation. The presence of a TAB or jianpu clefs is sufficient to indicate that numbers are used. The display-text and accidental-text elements allow display of fully formatted text and accidentals.
    /// </para>
    /// <para>
    /// Regular expression: ((displaytext | accidentaltext)+)
    /// </para>
    /// </summary>
    public noteheadtext() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((displaytext | accidentaltext)+)
    /// </para>
    /// </summary>
    public IList<formattedtext> displaytext {
        get {
            if ((this.displaytextField == null)) {
                this.displaytextField = new XTypedList<formattedtext>(this, LinqToXsdTypeManager.Instance, XName.Get("display-text", ""));
            }
            return this.displaytextField;
        }
        set {
            if ((value == null)) {
                this.displaytextField = null;
            }
            else {
                if ((this.displaytextField == null)) {
                    this.displaytextField = XTypedList<formattedtext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("display-text", ""));
                }
                else {
                    XTypedServices.SetList<formattedtext>(this.displaytextField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((displaytext | accidentaltext)+)
    /// </para>
    /// </summary>
    public IList<accidentaltext> accidentaltext {
        get {
            if ((this.accidentaltextField == null)) {
                this.accidentaltextField = new XTypedList<accidentaltext>(this, LinqToXsdTypeManager.Instance, XName.Get("accidental-text", ""));
            }
            return this.accidentaltextField;
        }
        set {
            if ((value == null)) {
                this.accidentaltextField = null;
            }
            else {
                if ((this.accidentaltextField == null)) {
                    this.accidentaltextField = XTypedList<accidentaltext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("accidental-text", ""));
                }
                else {
                    XTypedServices.SetList<accidentaltext>(this.accidentaltextField, value);
                }
            }
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("notehead-text", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<noteheadtext>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("display-text", ""), typeof(formattedtext));
        localElementDictionary.Add(XName.Get("accidental-text", ""), typeof(accidentaltext));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Ornaments can be any of several types, followed optionally by accidentals. The accidental-mark element's content is represented the same as an accidental element, but with a different name to reflect the different musical meaning.
/// </para>
/// <para>
/// Regular expression: ((trillmark | turn | delayedturn | invertedturn | delayedinvertedturn | verticalturn | shake | wavyline | mordent | invertedmordent | schleifer | tremolo | otherornament), accidentalmark*)*
/// </para>
/// </summary>
public partial class ornaments : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptytrillsound> trillmarkField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<horizontalturn> turnField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<horizontalturn> delayedturnField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<horizontalturn> invertedturnField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<horizontalturn> delayedinvertedturnField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptytrillsound> verticalturnField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptytrillsound> shakeField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<wavyline> wavylineField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<mordent> mordentField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<mordent> invertedmordentField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> schleiferField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<tremolo> tremoloField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<placementtext> otherornamentField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<accidentalmark> accidentalmarkField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator ornaments(XElement xe) { return XTypedServices.ToXTypedElement<ornaments>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static ornaments() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// Ornaments can be any of several types, followed optionally by accidentals. The accidental-mark element's content is represented the same as an accidental element, but with a different name to reflect the different musical meaning.
    /// </para>
    /// <para>
    /// Regular expression: ((trillmark | turn | delayedturn | invertedturn | delayedinvertedturn | verticalturn | shake | wavyline | mordent | invertedmordent | schleifer | tremolo | otherornament), accidentalmark*)*
    /// </para>
    /// </summary>
    public ornaments() {
    }
    
    /// <summary>
    /// <para>
    /// The trill-mark element represents the trill-mark symbol.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((trillmark | turn | delayedturn | invertedturn | delayedinvertedturn | verticalturn | shake | wavyline | mordent | invertedmordent | schleifer | tremolo | otherornament), accidentalmark*)*
    /// </para>
    /// </summary>
    public IList<emptytrillsound> trillmark {
        get {
            if ((this.trillmarkField == null)) {
                this.trillmarkField = new XTypedList<emptytrillsound>(this, LinqToXsdTypeManager.Instance, XName.Get("trill-mark", ""));
            }
            return this.trillmarkField;
        }
        set {
            if ((value == null)) {
                this.trillmarkField = null;
            }
            else {
                if ((this.trillmarkField == null)) {
                    this.trillmarkField = XTypedList<emptytrillsound>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("trill-mark", ""));
                }
                else {
                    XTypedServices.SetList<emptytrillsound>(this.trillmarkField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The turn element is the normal turn shape which goes up then down.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((trillmark | turn | delayedturn | invertedturn | delayedinvertedturn | verticalturn | shake | wavyline | mordent | invertedmordent | schleifer | tremolo | otherornament), accidentalmark*)*
    /// </para>
    /// </summary>
    public IList<horizontalturn> turn {
        get {
            if ((this.turnField == null)) {
                this.turnField = new XTypedList<horizontalturn>(this, LinqToXsdTypeManager.Instance, XName.Get("turn", ""));
            }
            return this.turnField;
        }
        set {
            if ((value == null)) {
                this.turnField = null;
            }
            else {
                if ((this.turnField == null)) {
                    this.turnField = XTypedList<horizontalturn>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("turn", ""));
                }
                else {
                    XTypedServices.SetList<horizontalturn>(this.turnField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The delayed-turn element indicates a normal turn that is delayed until the end of the current note.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((trillmark | turn | delayedturn | invertedturn | delayedinvertedturn | verticalturn | shake | wavyline | mordent | invertedmordent | schleifer | tremolo | otherornament), accidentalmark*)*
    /// </para>
    /// </summary>
    public IList<horizontalturn> delayedturn {
        get {
            if ((this.delayedturnField == null)) {
                this.delayedturnField = new XTypedList<horizontalturn>(this, LinqToXsdTypeManager.Instance, XName.Get("delayed-turn", ""));
            }
            return this.delayedturnField;
        }
        set {
            if ((value == null)) {
                this.delayedturnField = null;
            }
            else {
                if ((this.delayedturnField == null)) {
                    this.delayedturnField = XTypedList<horizontalturn>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("delayed-turn", ""));
                }
                else {
                    XTypedServices.SetList<horizontalturn>(this.delayedturnField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The inverted-turn element has the shape which goes down and then up.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((trillmark | turn | delayedturn | invertedturn | delayedinvertedturn | verticalturn | shake | wavyline | mordent | invertedmordent | schleifer | tremolo | otherornament), accidentalmark*)*
    /// </para>
    /// </summary>
    public IList<horizontalturn> invertedturn {
        get {
            if ((this.invertedturnField == null)) {
                this.invertedturnField = new XTypedList<horizontalturn>(this, LinqToXsdTypeManager.Instance, XName.Get("inverted-turn", ""));
            }
            return this.invertedturnField;
        }
        set {
            if ((value == null)) {
                this.invertedturnField = null;
            }
            else {
                if ((this.invertedturnField == null)) {
                    this.invertedturnField = XTypedList<horizontalturn>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("inverted-turn", ""));
                }
                else {
                    XTypedServices.SetList<horizontalturn>(this.invertedturnField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The delayed-inverted-turn element indicates an inverted turn that is delayed until the end of the current note.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((trillmark | turn | delayedturn | invertedturn | delayedinvertedturn | verticalturn | shake | wavyline | mordent | invertedmordent | schleifer | tremolo | otherornament), accidentalmark*)*
    /// </para>
    /// </summary>
    public IList<horizontalturn> delayedinvertedturn {
        get {
            if ((this.delayedinvertedturnField == null)) {
                this.delayedinvertedturnField = new XTypedList<horizontalturn>(this, LinqToXsdTypeManager.Instance, XName.Get("delayed-inverted-turn", ""));
            }
            return this.delayedinvertedturnField;
        }
        set {
            if ((value == null)) {
                this.delayedinvertedturnField = null;
            }
            else {
                if ((this.delayedinvertedturnField == null)) {
                    this.delayedinvertedturnField = XTypedList<horizontalturn>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("delayed-inverted-turn", ""));
                }
                else {
                    XTypedServices.SetList<horizontalturn>(this.delayedinvertedturnField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The vertical-turn element has the turn symbol shape arranged vertically going from upper left to lower right.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((trillmark | turn | delayedturn | invertedturn | delayedinvertedturn | verticalturn | shake | wavyline | mordent | invertedmordent | schleifer | tremolo | otherornament), accidentalmark*)*
    /// </para>
    /// </summary>
    public IList<emptytrillsound> verticalturn {
        get {
            if ((this.verticalturnField == null)) {
                this.verticalturnField = new XTypedList<emptytrillsound>(this, LinqToXsdTypeManager.Instance, XName.Get("vertical-turn", ""));
            }
            return this.verticalturnField;
        }
        set {
            if ((value == null)) {
                this.verticalturnField = null;
            }
            else {
                if ((this.verticalturnField == null)) {
                    this.verticalturnField = XTypedList<emptytrillsound>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("vertical-turn", ""));
                }
                else {
                    XTypedServices.SetList<emptytrillsound>(this.verticalturnField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The shake element has a similar appearance to an inverted-mordent element.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((trillmark | turn | delayedturn | invertedturn | delayedinvertedturn | verticalturn | shake | wavyline | mordent | invertedmordent | schleifer | tremolo | otherornament), accidentalmark*)*
    /// </para>
    /// </summary>
    public IList<emptytrillsound> shake {
        get {
            if ((this.shakeField == null)) {
                this.shakeField = new XTypedList<emptytrillsound>(this, LinqToXsdTypeManager.Instance, XName.Get("shake", ""));
            }
            return this.shakeField;
        }
        set {
            if ((value == null)) {
                this.shakeField = null;
            }
            else {
                if ((this.shakeField == null)) {
                    this.shakeField = XTypedList<emptytrillsound>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("shake", ""));
                }
                else {
                    XTypedServices.SetList<emptytrillsound>(this.shakeField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((trillmark | turn | delayedturn | invertedturn | delayedinvertedturn | verticalturn | shake | wavyline | mordent | invertedmordent | schleifer | tremolo | otherornament), accidentalmark*)*
    /// </para>
    /// </summary>
    public IList<wavyline> wavyline {
        get {
            if ((this.wavylineField == null)) {
                this.wavylineField = new XTypedList<wavyline>(this, LinqToXsdTypeManager.Instance, XName.Get("wavy-line", ""));
            }
            return this.wavylineField;
        }
        set {
            if ((value == null)) {
                this.wavylineField = null;
            }
            else {
                if ((this.wavylineField == null)) {
                    this.wavylineField = XTypedList<wavyline>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("wavy-line", ""));
                }
                else {
                    XTypedServices.SetList<wavyline>(this.wavylineField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The mordent element represents the sign with the vertical line. The long attribute is "no" by default.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((trillmark | turn | delayedturn | invertedturn | delayedinvertedturn | verticalturn | shake | wavyline | mordent | invertedmordent | schleifer | tremolo | otherornament), accidentalmark*)*
    /// </para>
    /// </summary>
    public IList<mordent> mordent {
        get {
            if ((this.mordentField == null)) {
                this.mordentField = new XTypedList<mordent>(this, LinqToXsdTypeManager.Instance, XName.Get("mordent", ""));
            }
            return this.mordentField;
        }
        set {
            if ((value == null)) {
                this.mordentField = null;
            }
            else {
                if ((this.mordentField == null)) {
                    this.mordentField = XTypedList<mordent>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("mordent", ""));
                }
                else {
                    XTypedServices.SetList<mordent>(this.mordentField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The inverted-mordent element represents the sign without the vertical line. The long attribute is "no" by default.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((trillmark | turn | delayedturn | invertedturn | delayedinvertedturn | verticalturn | shake | wavyline | mordent | invertedmordent | schleifer | tremolo | otherornament), accidentalmark*)*
    /// </para>
    /// </summary>
    public IList<mordent> invertedmordent {
        get {
            if ((this.invertedmordentField == null)) {
                this.invertedmordentField = new XTypedList<mordent>(this, LinqToXsdTypeManager.Instance, XName.Get("inverted-mordent", ""));
            }
            return this.invertedmordentField;
        }
        set {
            if ((value == null)) {
                this.invertedmordentField = null;
            }
            else {
                if ((this.invertedmordentField == null)) {
                    this.invertedmordentField = XTypedList<mordent>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("inverted-mordent", ""));
                }
                else {
                    XTypedServices.SetList<mordent>(this.invertedmordentField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The name for this ornament is based on the German, to avoid confusion with the more common slide element defined earlier.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((trillmark | turn | delayedturn | invertedturn | delayedinvertedturn | verticalturn | shake | wavyline | mordent | invertedmordent | schleifer | tremolo | otherornament), accidentalmark*)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> schleifer {
        get {
            if ((this.schleiferField == null)) {
                this.schleiferField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("schleifer", ""));
            }
            return this.schleiferField;
        }
        set {
            if ((value == null)) {
                this.schleiferField = null;
            }
            else {
                if ((this.schleiferField == null)) {
                    this.schleiferField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("schleifer", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.schleiferField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((trillmark | turn | delayedturn | invertedturn | delayedinvertedturn | verticalturn | shake | wavyline | mordent | invertedmordent | schleifer | tremolo | otherornament), accidentalmark*)*
    /// </para>
    /// </summary>
    public IList<tremolo> tremolo {
        get {
            if ((this.tremoloField == null)) {
                this.tremoloField = new XTypedList<tremolo>(this, LinqToXsdTypeManager.Instance, XName.Get("tremolo", ""));
            }
            return this.tremoloField;
        }
        set {
            if ((value == null)) {
                this.tremoloField = null;
            }
            else {
                if ((this.tremoloField == null)) {
                    this.tremoloField = XTypedList<tremolo>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("tremolo", ""));
                }
                else {
                    XTypedServices.SetList<tremolo>(this.tremoloField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The other-ornament element is used to define any ornaments not yet in the MusicXML format. This allows extended representation, though without application interoperability.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((trillmark | turn | delayedturn | invertedturn | delayedinvertedturn | verticalturn | shake | wavyline | mordent | invertedmordent | schleifer | tremolo | otherornament), accidentalmark*)*
    /// </para>
    /// </summary>
    public IList<placementtext> otherornament {
        get {
            if ((this.otherornamentField == null)) {
                this.otherornamentField = new XTypedList<placementtext>(this, LinqToXsdTypeManager.Instance, XName.Get("other-ornament", ""));
            }
            return this.otherornamentField;
        }
        set {
            if ((value == null)) {
                this.otherornamentField = null;
            }
            else {
                if ((this.otherornamentField == null)) {
                    this.otherornamentField = XTypedList<placementtext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("other-ornament", ""));
                }
                else {
                    XTypedServices.SetList<placementtext>(this.otherornamentField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: ((trillmark | turn | delayedturn | invertedturn | delayedinvertedturn | verticalturn | shake | wavyline | mordent | invertedmordent | schleifer | tremolo | otherornament), accidentalmark*)*
    /// </para>
    /// </summary>
    public IList<accidentalmark> accidentalmark {
        get {
            if ((this.accidentalmarkField == null)) {
                this.accidentalmarkField = new XTypedList<accidentalmark>(this, LinqToXsdTypeManager.Instance, XName.Get("accidental-mark", ""));
            }
            return this.accidentalmarkField;
        }
        set {
            if ((value == null)) {
                this.accidentalmarkField = null;
            }
            else {
                if ((this.accidentalmarkField == null)) {
                    this.accidentalmarkField = XTypedList<accidentalmark>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("accidental-mark", ""));
                }
                else {
                    XTypedServices.SetList<accidentalmark>(this.accidentalmarkField, value);
                }
            }
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("ornaments", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<ornaments>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("trill-mark", ""), typeof(emptytrillsound));
        localElementDictionary.Add(XName.Get("turn", ""), typeof(horizontalturn));
        localElementDictionary.Add(XName.Get("delayed-turn", ""), typeof(horizontalturn));
        localElementDictionary.Add(XName.Get("inverted-turn", ""), typeof(horizontalturn));
        localElementDictionary.Add(XName.Get("delayed-inverted-turn", ""), typeof(horizontalturn));
        localElementDictionary.Add(XName.Get("vertical-turn", ""), typeof(emptytrillsound));
        localElementDictionary.Add(XName.Get("shake", ""), typeof(emptytrillsound));
        localElementDictionary.Add(XName.Get("wavy-line", ""), typeof(wavyline));
        localElementDictionary.Add(XName.Get("mordent", ""), typeof(mordent));
        localElementDictionary.Add(XName.Get("inverted-mordent", ""), typeof(mordent));
        localElementDictionary.Add(XName.Get("schleifer", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("tremolo", ""), typeof(tremolo));
        localElementDictionary.Add(XName.Get("other-ornament", ""), typeof(placementtext));
        localElementDictionary.Add(XName.Get("accidental-mark", ""), typeof(accidentalmark));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The other-notation type is used to define any notations not yet in the MusicXML format. This allows extended representation, though without application interoperability. It handles notations where more specific extension elements such as other-dynamics and other-technical are not appropriate.
/// </para>
/// </summary>
public partial class othernotation : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static decimal numberDefaultValue = System.Xml.XmlConvert.ToDecimal("1");
    
         public static explicit operator othernotation(XElement xe) { return XTypedServices.ToXTypedElement<othernotation>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The other-notation type is used to define any notations not yet in the MusicXML format. This allows extended representation, though without application interoperability. It handles notations where more specific extension elements such as other-dynamics and other-technical are not appropriate.
    /// </para>
    /// </summary>
    public othernotation() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public decimal number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype, numberDefaultValue);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("other-notation", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<othernotation>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Pitch is represented as a combination of the step of the diatonic scale, the chromatic alteration, and the octave.
/// </para>
/// <para>
/// Regular expression: (step, alter?, octave)
/// </para>
/// </summary>
public partial class pitch : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator pitch(XElement xe) { return XTypedServices.ToXTypedElement<pitch>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static pitch() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("step", "")), new NamedContentModelEntity(XName.Get("alter", "")), new NamedContentModelEntity(XName.Get("octave", "")));
    }
    
    /// <summary>
    /// <para>
    /// Pitch is represented as a combination of the step of the diatonic scale, the chromatic alteration, and the octave.
    /// </para>
    /// <para>
    /// Regular expression: (step, alter?, octave)
    /// </para>
    /// </summary>
    public pitch() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (step, alter?, octave)
    /// </para>
    /// </summary>
    public string step {
        get {
            XElement x = this.GetElement(XName.Get("step", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("step", ""), value, "step", global::step.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (step, alter?, octave)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> alter {
        get {
            XElement x = this.GetElement(XName.Get("alter", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("alter", ""), value, "alter", global::semitones.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (step, alter?, octave)
    /// </para>
    /// </summary>
    public decimal octave {
        get {
            XElement x = this.GetElement(XName.Get("octave", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("octave", ""), value, "octave", global::octave.TypeDefinition);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("pitch", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<pitch>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("step", ""), typeof(string));
        localElementDictionary.Add(XName.Get("alter", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("octave", ""), typeof(decimal));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The placement-text type represents a text element with print-style and placement attribute groups.
/// </para>
/// </summary>
public partial class placementtext : XTypedElement, IXMetaData {
    
         public static explicit operator placementtext(XElement xe) { return XTypedServices.ToXTypedElement<placementtext>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The placement-text type represents a text element with print-style and placement attribute groups.
    /// </para>
    /// </summary>
    public placementtext() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("placement-text", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<placementtext>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The rest element indicates notated rests or silences. Rest elements are usually empty, but placement on the staff can be specified using display-step and display-octave elements. If the measure attribute is set to yes, this indicates this is a complete measure rest.
/// </para>
/// <para>
/// Regular expression: ((displaystep, displayoctave)?)
/// </para>
/// </summary>
public partial class rest : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator rest(XElement xe) { return XTypedServices.ToXTypedElement<rest>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static rest() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The rest element indicates notated rests or silences. Rest elements are usually empty, but placement on the staff can be specified using display-step and display-octave elements. If the measure attribute is set to yes, this indicates this is a complete measure rest.
    /// </para>
    /// <para>
    /// Regular expression: ((displaystep, displayoctave)?)
    /// </para>
    /// </summary>
    public rest() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((displaystep, displayoctave)?)
    /// </para>
    /// </summary>
    public string displaystep {
        get {
            XElement x = this.GetElement(XName.Get("display-step", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("display-step", ""), value, "displaystep", global::step.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((displaystep, displayoctave)?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> displayoctave {
        get {
            XElement x = this.GetElement(XName.Get("display-octave", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("display-octave", ""), value, "displayoctave", global::octave.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string measure {
        get {
            XAttribute x = this.Attribute(XName.Get("measure", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("measure", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("rest", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<rest>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("display-step", ""), typeof(string));
        localElementDictionary.Add(XName.Get("display-octave", ""), typeof(decimal));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Glissando and slide types both indicate rapidly moving from one pitch to the other so that individual notes are not discerned. The distinction is similar to that between NIFF's glissando and portamento elements. A slide is continuous between two notes and defaults to a solid line. The optional text for a is printed alongside the line.
/// </para>
/// </summary>
public partial class slide : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static decimal numberDefaultValue = System.Xml.XmlConvert.ToDecimal("1");
    
         public static explicit operator slide(XElement xe) { return XTypedServices.ToXTypedElement<slide>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// Glissando and slide types both indicate rapidly moving from one pitch to the other so that individual notes are not discerned. The distinction is similar to that between NIFF's glissando and portamento elements. A slide is continuous between two notes and defaults to a solid line. The optional text for a is printed alongside the line.
    /// </para>
    /// </summary>
    public slide() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public decimal number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype, numberDefaultValue);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string linetype {
        get {
            XAttribute x = this.Attribute(XName.Get("line-type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line-type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> dashlength {
        get {
            XAttribute x = this.Attribute(XName.Get("dash-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dash-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> spacelength {
        get {
            XAttribute x = this.Attribute(XName.Get("space-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("space-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string accelerate {
        get {
            XAttribute x = this.Attribute(XName.Get("accelerate", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("accelerate", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> beats {
        get {
            XAttribute x = this.Attribute(XName.Get("beats", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("beats", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> firstbeat {
        get {
            XAttribute x = this.Attribute(XName.Get("first-beat", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("first-beat", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> lastbeat {
        get {
            XAttribute x = this.Attribute(XName.Get("last-beat", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("last-beat", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("slide", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<slide>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Slur types are empty. Most slurs are represented with two elements: one with a start type, and one with a stop type. Slurs can add more elements using a continue type. This is typically used to specify the formatting of cross-system slurs, or to specify the shape of very complex slurs.
/// </para>
/// </summary>
public partial class slur : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static decimal numberDefaultValue = System.Xml.XmlConvert.ToDecimal("1");
    
         public static explicit operator slur(XElement xe) { return XTypedServices.ToXTypedElement<slur>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// Slur types are empty. Most slurs are represented with two elements: one with a start type, and one with a stop type. Slurs can add more elements using a continue type. This is typically used to specify the formatting of cross-system slurs, or to specify the shape of very complex slurs.
    /// </para>
    /// </summary>
    public slur() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public decimal number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype, numberDefaultValue);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string linetype {
        get {
            XAttribute x = this.Attribute(XName.Get("line-type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line-type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> dashlength {
        get {
            XAttribute x = this.Attribute(XName.Get("dash-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dash-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> spacelength {
        get {
            XAttribute x = this.Attribute(XName.Get("space-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("space-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string orientation {
        get {
            XAttribute x = this.Attribute(XName.Get("orientation", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("orientation", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> bezieroffset {
        get {
            XAttribute x = this.Attribute(XName.Get("bezier-offset", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bezier-offset", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> bezieroffset2 {
        get {
            XAttribute x = this.Attribute(XName.Get("bezier-offset2", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bezier-offset2", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> bezierx {
        get {
            XAttribute x = this.Attribute(XName.Get("bezier-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bezier-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> beziery {
        get {
            XAttribute x = this.Attribute(XName.Get("bezier-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bezier-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> bezierx2 {
        get {
            XAttribute x = this.Attribute(XName.Get("bezier-x2", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bezier-x2", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> beziery2 {
        get {
            XAttribute x = this.Attribute(XName.Get("bezier-y2", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bezier-y2", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("slur", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<slur>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Stems can be down, up, none, or double. For down and up stems, the position attributes can be used to specify stem length. The relative values specify the end of the stem relative to the program default. Default values specify an absolute end stem position. Negative values of relative-y that would flip a stem instead of shortening it are ignored. A stem element associated with a rest refers to a stemlet.
/// </para>
/// </summary>
public partial class stem : XTypedElement, IXMetaData {
    
         public static explicit operator stem(XElement xe) { return XTypedServices.ToXTypedElement<stem>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// Stems can be down, up, none, or double. For down and up stems, the position attributes can be used to specify stem length. The relative values specify the end of the stem relative to the program default. Default values specify an absolute end stem position. Negative values of relative-y that would flip a stem instead of shortening it are ignored. A stem element associated with a rest refers to a stemlet.
    /// </para>
    /// </summary>
    public stem() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::stemvalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("stem", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<stem>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The strong-accent type indicates a vertical accent mark. The type attribute indicates if the point of the accent is down or up.
/// </para>
/// </summary>
public partial class strongaccent : global::emptyplacement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static string typeDefaultValue = "up";
    
         public static explicit operator strongaccent(XElement xe) { return XTypedServices.ToXTypedElement<strongaccent>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The strong-accent type indicates a vertical accent mark. The type attribute indicates if the point of the accent is down or up.
    /// </para>
    /// </summary>
    public strongaccent() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype, typeDefaultValue);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("strong-accent", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<strongaccent>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The style-text type represents a text element with a print-style attribute group.
/// </para>
/// </summary>
public partial class styletext : XTypedElement, IXMetaData {
    
         public static explicit operator styletext(XElement xe) { return XTypedServices.ToXTypedElement<styletext>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The style-text type represents a text element with a print-style attribute group.
    /// </para>
    /// </summary>
    public styletext() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("style-text", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<styletext>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Technical indications give performance information for individual instruments.
/// </para>
/// <para>
/// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
/// </para>
/// </summary>
public partial class technical : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> upbowField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> downbowField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<harmonic> harmonicField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> openstringField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> thumbpositionField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<fingering> fingeringField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<placementtext> pluckField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> doubletongueField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> tripletongueField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> stoppedField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> snappizzicatoField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<fret> fretField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<@string> @stringField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<hammeronpulloff> hammeronField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<hammeronpulloff> pulloffField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<bend> bendField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<placementtext> tapField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<heeltoe> heelField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<heeltoe> toeField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<emptyplacement> fingernailsField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<hole> holeField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<arrow> arrowField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<handbell> handbellField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<placementtext> othertechnicalField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator technical(XElement xe) { return XTypedServices.ToXTypedElement<technical>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static technical() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// Technical indications give performance information for individual instruments.
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public technical() {
    }
    
    /// <summary>
    /// <para>
    /// The up-bow element represents the symbol that is used both for up-bowing on bowed instruments, and up-stroke on plucked instruments.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> upbow {
        get {
            if ((this.upbowField == null)) {
                this.upbowField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("up-bow", ""));
            }
            return this.upbowField;
        }
        set {
            if ((value == null)) {
                this.upbowField = null;
            }
            else {
                if ((this.upbowField == null)) {
                    this.upbowField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("up-bow", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.upbowField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The down-bow element represents the symbol that is used both for down-bowing on bowed instruments, and down-stroke on plucked instruments.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> downbow {
        get {
            if ((this.downbowField == null)) {
                this.downbowField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("down-bow", ""));
            }
            return this.downbowField;
        }
        set {
            if ((value == null)) {
                this.downbowField = null;
            }
            else {
                if ((this.downbowField == null)) {
                    this.downbowField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("down-bow", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.downbowField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<harmonic> harmonic {
        get {
            if ((this.harmonicField == null)) {
                this.harmonicField = new XTypedList<harmonic>(this, LinqToXsdTypeManager.Instance, XName.Get("harmonic", ""));
            }
            return this.harmonicField;
        }
        set {
            if ((value == null)) {
                this.harmonicField = null;
            }
            else {
                if ((this.harmonicField == null)) {
                    this.harmonicField = XTypedList<harmonic>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("harmonic", ""));
                }
                else {
                    XTypedServices.SetList<harmonic>(this.harmonicField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The open-string element represents the zero-shaped open string symbol.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> openstring {
        get {
            if ((this.openstringField == null)) {
                this.openstringField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("open-string", ""));
            }
            return this.openstringField;
        }
        set {
            if ((value == null)) {
                this.openstringField = null;
            }
            else {
                if ((this.openstringField == null)) {
                    this.openstringField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("open-string", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.openstringField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The thumb-position element represents the thumb position symbol. This is a circle with a line, where the line does not come within the circle. It is distinct from the snap pizzicato symbol, where the line comes inside the circle.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> thumbposition {
        get {
            if ((this.thumbpositionField == null)) {
                this.thumbpositionField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("thumb-position", ""));
            }
            return this.thumbpositionField;
        }
        set {
            if ((value == null)) {
                this.thumbpositionField = null;
            }
            else {
                if ((this.thumbpositionField == null)) {
                    this.thumbpositionField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("thumb-position", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.thumbpositionField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<fingering> fingering {
        get {
            if ((this.fingeringField == null)) {
                this.fingeringField = new XTypedList<fingering>(this, LinqToXsdTypeManager.Instance, XName.Get("fingering", ""));
            }
            return this.fingeringField;
        }
        set {
            if ((value == null)) {
                this.fingeringField = null;
            }
            else {
                if ((this.fingeringField == null)) {
                    this.fingeringField = XTypedList<fingering>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("fingering", ""));
                }
                else {
                    XTypedServices.SetList<fingering>(this.fingeringField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The pluck element is used to specify the plucking fingering on a fretted instrument, where the fingering element refers to the fretting fingering. Typical values are p, i, m, a for pulgar/thumb, indicio/index, medio/middle, and anular/ring fingers.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<placementtext> pluck {
        get {
            if ((this.pluckField == null)) {
                this.pluckField = new XTypedList<placementtext>(this, LinqToXsdTypeManager.Instance, XName.Get("pluck", ""));
            }
            return this.pluckField;
        }
        set {
            if ((value == null)) {
                this.pluckField = null;
            }
            else {
                if ((this.pluckField == null)) {
                    this.pluckField = XTypedList<placementtext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("pluck", ""));
                }
                else {
                    XTypedServices.SetList<placementtext>(this.pluckField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The double-tongue element represents the double tongue symbol (two dots arranged horizontally).
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> doubletongue {
        get {
            if ((this.doubletongueField == null)) {
                this.doubletongueField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("double-tongue", ""));
            }
            return this.doubletongueField;
        }
        set {
            if ((value == null)) {
                this.doubletongueField = null;
            }
            else {
                if ((this.doubletongueField == null)) {
                    this.doubletongueField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("double-tongue", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.doubletongueField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The triple-tongue element represents the triple tongue symbol (three dots arranged horizontally).
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> tripletongue {
        get {
            if ((this.tripletongueField == null)) {
                this.tripletongueField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("triple-tongue", ""));
            }
            return this.tripletongueField;
        }
        set {
            if ((value == null)) {
                this.tripletongueField = null;
            }
            else {
                if ((this.tripletongueField == null)) {
                    this.tripletongueField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("triple-tongue", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.tripletongueField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The stopped element represents the stopped symbol, which looks like a plus sign.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> stopped {
        get {
            if ((this.stoppedField == null)) {
                this.stoppedField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("stopped", ""));
            }
            return this.stoppedField;
        }
        set {
            if ((value == null)) {
                this.stoppedField = null;
            }
            else {
                if ((this.stoppedField == null)) {
                    this.stoppedField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("stopped", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.stoppedField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// 	The snap-pizzicato element represents the snap pizzicato symbol. This is a circle with a line, where the line comes inside the circle. It is distinct from the thumb-position symbol, where the line does not come inside the circle.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> snappizzicato {
        get {
            if ((this.snappizzicatoField == null)) {
                this.snappizzicatoField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("snap-pizzicato", ""));
            }
            return this.snappizzicatoField;
        }
        set {
            if ((value == null)) {
                this.snappizzicatoField = null;
            }
            else {
                if ((this.snappizzicatoField == null)) {
                    this.snappizzicatoField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("snap-pizzicato", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.snappizzicatoField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<fret> fret {
        get {
            if ((this.fretField == null)) {
                this.fretField = new XTypedList<fret>(this, LinqToXsdTypeManager.Instance, XName.Get("fret", ""));
            }
            return this.fretField;
        }
        set {
            if ((value == null)) {
                this.fretField = null;
            }
            else {
                if ((this.fretField == null)) {
                    this.fretField = XTypedList<fret>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("fret", ""));
                }
                else {
                    XTypedServices.SetList<fret>(this.fretField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<@string> @string {
        get {
            if ((this.@stringField == null)) {
                this.@stringField = new XTypedList<@string>(this, LinqToXsdTypeManager.Instance, XName.Get("string", ""));
            }
            return this.@stringField;
        }
        set {
            if ((value == null)) {
                this.@stringField = null;
            }
            else {
                if ((this.@stringField == null)) {
                    this.@stringField = XTypedList<@string>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("string", ""));
                }
                else {
                    XTypedServices.SetList<@string>(this.@stringField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<hammeronpulloff> hammeron {
        get {
            if ((this.hammeronField == null)) {
                this.hammeronField = new XTypedList<hammeronpulloff>(this, LinqToXsdTypeManager.Instance, XName.Get("hammer-on", ""));
            }
            return this.hammeronField;
        }
        set {
            if ((value == null)) {
                this.hammeronField = null;
            }
            else {
                if ((this.hammeronField == null)) {
                    this.hammeronField = XTypedList<hammeronpulloff>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("hammer-on", ""));
                }
                else {
                    XTypedServices.SetList<hammeronpulloff>(this.hammeronField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<hammeronpulloff> pulloff {
        get {
            if ((this.pulloffField == null)) {
                this.pulloffField = new XTypedList<hammeronpulloff>(this, LinqToXsdTypeManager.Instance, XName.Get("pull-off", ""));
            }
            return this.pulloffField;
        }
        set {
            if ((value == null)) {
                this.pulloffField = null;
            }
            else {
                if ((this.pulloffField == null)) {
                    this.pulloffField = XTypedList<hammeronpulloff>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("pull-off", ""));
                }
                else {
                    XTypedServices.SetList<hammeronpulloff>(this.pulloffField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<bend> bend {
        get {
            if ((this.bendField == null)) {
                this.bendField = new XTypedList<bend>(this, LinqToXsdTypeManager.Instance, XName.Get("bend", ""));
            }
            return this.bendField;
        }
        set {
            if ((value == null)) {
                this.bendField = null;
            }
            else {
                if ((this.bendField == null)) {
                    this.bendField = XTypedList<bend>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("bend", ""));
                }
                else {
                    XTypedServices.SetList<bend>(this.bendField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The tap element indicates a tap on the fretboard. The element content allows specification of the notation; + and T are common choices. If empty, the display is application-specific.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<placementtext> tap {
        get {
            if ((this.tapField == null)) {
                this.tapField = new XTypedList<placementtext>(this, LinqToXsdTypeManager.Instance, XName.Get("tap", ""));
            }
            return this.tapField;
        }
        set {
            if ((value == null)) {
                this.tapField = null;
            }
            else {
                if ((this.tapField == null)) {
                    this.tapField = XTypedList<placementtext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("tap", ""));
                }
                else {
                    XTypedServices.SetList<placementtext>(this.tapField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<heeltoe> heel {
        get {
            if ((this.heelField == null)) {
                this.heelField = new XTypedList<heeltoe>(this, LinqToXsdTypeManager.Instance, XName.Get("heel", ""));
            }
            return this.heelField;
        }
        set {
            if ((value == null)) {
                this.heelField = null;
            }
            else {
                if ((this.heelField == null)) {
                    this.heelField = XTypedList<heeltoe>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("heel", ""));
                }
                else {
                    XTypedServices.SetList<heeltoe>(this.heelField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<heeltoe> toe {
        get {
            if ((this.toeField == null)) {
                this.toeField = new XTypedList<heeltoe>(this, LinqToXsdTypeManager.Instance, XName.Get("toe", ""));
            }
            return this.toeField;
        }
        set {
            if ((value == null)) {
                this.toeField = null;
            }
            else {
                if ((this.toeField == null)) {
                    this.toeField = XTypedList<heeltoe>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("toe", ""));
                }
                else {
                    XTypedServices.SetList<heeltoe>(this.toeField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The fingernails element is used in notation for harp and other plucked string instruments.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<emptyplacement> fingernails {
        get {
            if ((this.fingernailsField == null)) {
                this.fingernailsField = new XTypedList<emptyplacement>(this, LinqToXsdTypeManager.Instance, XName.Get("fingernails", ""));
            }
            return this.fingernailsField;
        }
        set {
            if ((value == null)) {
                this.fingernailsField = null;
            }
            else {
                if ((this.fingernailsField == null)) {
                    this.fingernailsField = XTypedList<emptyplacement>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("fingernails", ""));
                }
                else {
                    XTypedServices.SetList<emptyplacement>(this.fingernailsField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<hole> hole {
        get {
            if ((this.holeField == null)) {
                this.holeField = new XTypedList<hole>(this, LinqToXsdTypeManager.Instance, XName.Get("hole", ""));
            }
            return this.holeField;
        }
        set {
            if ((value == null)) {
                this.holeField = null;
            }
            else {
                if ((this.holeField == null)) {
                    this.holeField = XTypedList<hole>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("hole", ""));
                }
                else {
                    XTypedServices.SetList<hole>(this.holeField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<arrow> arrow {
        get {
            if ((this.arrowField == null)) {
                this.arrowField = new XTypedList<arrow>(this, LinqToXsdTypeManager.Instance, XName.Get("arrow", ""));
            }
            return this.arrowField;
        }
        set {
            if ((value == null)) {
                this.arrowField = null;
            }
            else {
                if ((this.arrowField == null)) {
                    this.arrowField = XTypedList<arrow>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("arrow", ""));
                }
                else {
                    XTypedServices.SetList<arrow>(this.arrowField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<handbell> handbell {
        get {
            if ((this.handbellField == null)) {
                this.handbellField = new XTypedList<handbell>(this, LinqToXsdTypeManager.Instance, XName.Get("handbell", ""));
            }
            return this.handbellField;
        }
        set {
            if ((value == null)) {
                this.handbellField = null;
            }
            else {
                if ((this.handbellField == null)) {
                    this.handbellField = XTypedList<handbell>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("handbell", ""));
                }
                else {
                    XTypedServices.SetList<handbell>(this.handbellField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// The other-technical element is used to define any technical indications not yet in the MusicXML format. This allows extended representation, though without application interoperability.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Regular expression: (upbow | downbow | harmonic | openstring | thumbposition | fingering | pluck | doubletongue | tripletongue | stopped | snappizzicato | fret | @string | hammeron | pulloff | bend | tap | heel | toe | fingernails | hole | arrow | handbell | othertechnical)*
    /// </para>
    /// </summary>
    public IList<placementtext> othertechnical {
        get {
            if ((this.othertechnicalField == null)) {
                this.othertechnicalField = new XTypedList<placementtext>(this, LinqToXsdTypeManager.Instance, XName.Get("other-technical", ""));
            }
            return this.othertechnicalField;
        }
        set {
            if ((value == null)) {
                this.othertechnicalField = null;
            }
            else {
                if ((this.othertechnicalField == null)) {
                    this.othertechnicalField = XTypedList<placementtext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("other-technical", ""));
                }
                else {
                    XTypedServices.SetList<placementtext>(this.othertechnicalField, value);
                }
            }
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("technical", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<technical>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("up-bow", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("down-bow", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("harmonic", ""), typeof(harmonic));
        localElementDictionary.Add(XName.Get("open-string", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("thumb-position", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("fingering", ""), typeof(fingering));
        localElementDictionary.Add(XName.Get("pluck", ""), typeof(placementtext));
        localElementDictionary.Add(XName.Get("double-tongue", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("triple-tongue", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("stopped", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("snap-pizzicato", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("fret", ""), typeof(fret));
        localElementDictionary.Add(XName.Get("string", ""), typeof(@string));
        localElementDictionary.Add(XName.Get("hammer-on", ""), typeof(hammeronpulloff));
        localElementDictionary.Add(XName.Get("pull-off", ""), typeof(hammeronpulloff));
        localElementDictionary.Add(XName.Get("bend", ""), typeof(bend));
        localElementDictionary.Add(XName.Get("tap", ""), typeof(placementtext));
        localElementDictionary.Add(XName.Get("heel", ""), typeof(heeltoe));
        localElementDictionary.Add(XName.Get("toe", ""), typeof(heeltoe));
        localElementDictionary.Add(XName.Get("fingernails", ""), typeof(emptyplacement));
        localElementDictionary.Add(XName.Get("hole", ""), typeof(hole));
        localElementDictionary.Add(XName.Get("arrow", ""), typeof(arrow));
        localElementDictionary.Add(XName.Get("handbell", ""), typeof(handbell));
        localElementDictionary.Add(XName.Get("other-technical", ""), typeof(placementtext));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The text-element-data type represents a syllable or portion of a syllable for lyric text underlay. A hyphen in the string content should only be used for an actual hyphenated word. Language names for text elements come from ISO 639, with optional country subcodes from ISO 3166.
/// </para>
/// </summary>
public partial class textelementdata : XTypedElement, IXMetaData {
    
         public static explicit operator textelementdata(XElement xe) { return XTypedServices.ToXTypedElement<textelementdata>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The text-element-data type represents a syllable or portion of a syllable for lyric text underlay. A hyphen in the string content should only be used for an actual hyphenated word. Language names for text elements come from ISO 639, with optional country subcodes from ISO 3166.
    /// </para>
    /// </summary>
    public textelementdata() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> underline {
        get {
            XAttribute x = this.Attribute(XName.Get("underline", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("underline", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> overline {
        get {
            XAttribute x = this.Attribute(XName.Get("overline", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("overline", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> linethrough {
        get {
            XAttribute x = this.Attribute(XName.Get("line-through", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line-through", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> rotation {
        get {
            XAttribute x = this.Attribute(XName.Get("rotation", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("rotation", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object letterspacing {
        get {
            XAttribute x = this.Attribute(XName.Get("letter-spacing", ""));
            return XTypedServices.ParseUnionValue(x, global::numberornormal.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "letterspacing", this, XName.Get("letter-spacing", ""), global::numberornormal.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object lang {
        get {
            XAttribute x = this.Attribute(XName.Get("lang", "http://www.w3.org/XML/1998/namespace"));
            return XTypedServices.ParseUnionValue(x, global::www.w3.org.XML.Item1998.@namespace.lang.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "lang", this, XName.Get("lang", "http://www.w3.org/XML/1998/namespace"), global::www.w3.org.XML.Item1998.@namespace.lang.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string dir {
        get {
            XAttribute x = this.Attribute(XName.Get("dir", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dir", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("text-element-data", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<textelementdata>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The text-font-color type represents text with optional font and color information. It is used for the elision element.
/// </para>
/// </summary>
public partial class textfontcolor : XTypedElement, IXMetaData {
    
         public static explicit operator textfontcolor(XElement xe) { return XTypedServices.ToXTypedElement<textfontcolor>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The text-font-color type represents text with optional font and color information. It is used for the elision element.
    /// </para>
    /// </summary>
    public textfontcolor() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> underline {
        get {
            XAttribute x = this.Attribute(XName.Get("underline", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("underline", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> overline {
        get {
            XAttribute x = this.Attribute(XName.Get("overline", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("overline", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> linethrough {
        get {
            XAttribute x = this.Attribute(XName.Get("line-through", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line-through", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> rotation {
        get {
            XAttribute x = this.Attribute(XName.Get("rotation", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("rotation", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object letterspacing {
        get {
            XAttribute x = this.Attribute(XName.Get("letter-spacing", ""));
            return XTypedServices.ParseUnionValue(x, global::numberornormal.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "letterspacing", this, XName.Get("letter-spacing", ""), global::numberornormal.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object lang {
        get {
            XAttribute x = this.Attribute(XName.Get("lang", "http://www.w3.org/XML/1998/namespace"));
            return XTypedServices.ParseUnionValue(x, global::www.w3.org.XML.Item1998.@namespace.lang.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "lang", this, XName.Get("lang", "http://www.w3.org/XML/1998/namespace"), global::www.w3.org.XML.Item1998.@namespace.lang.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string dir {
        get {
            XAttribute x = this.Attribute(XName.Get("dir", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dir", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("text-font-color", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<textfontcolor>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The tie element indicates that a tie begins or ends with this note. If the tie element applies only particular times through a repeat, the time-only attribute indicates which times to apply it. The tie element indicates sound; the tied element indicates notation.
/// </para>
/// </summary>
public partial class tie : XTypedElement, IXMetaData {
    
         public static explicit operator tie(XElement xe) { return XTypedServices.ToXTypedElement<tie>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The tie element indicates that a tie begins or ends with this note. If the tie element applies only particular times through a repeat, the time-only attribute indicates which times to apply it. The tie element indicates sound; the tied element indicates notation.
    /// </para>
    /// </summary>
    public tie() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string timeonly {
        get {
            XAttribute x = this.Attribute(XName.Get("time-only", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("time-only", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("tie", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<tie>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The tied type represents the notated tie. The tie element represents the tie sound.
///
///The number attribute is rarely needed to disambiguate ties, since note pitches will usually suffice. The attribute is implied rather than defaulting to 1 as with most elements. It is available for use in more complex tied notation situations.
/// </para>
/// </summary>
public partial class tied : XTypedElement, IXMetaData {
    
         public static explicit operator tied(XElement xe) { return XTypedServices.ToXTypedElement<tied>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The tied type represents the notated tie. The tie element represents the tie sound.
    ///
    ///The number attribute is rarely needed to disambiguate ties, since note pitches will usually suffice. The attribute is implied rather than defaulting to 1 as with most elements. It is available for use in more complex tied notation situations.
    /// </para>
    /// </summary>
    public tied() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string linetype {
        get {
            XAttribute x = this.Attribute(XName.Get("line-type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line-type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> dashlength {
        get {
            XAttribute x = this.Attribute(XName.Get("dash-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("dash-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> spacelength {
        get {
            XAttribute x = this.Attribute(XName.Get("space-length", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("space-length", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string orientation {
        get {
            XAttribute x = this.Attribute(XName.Get("orientation", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("orientation", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> bezieroffset {
        get {
            XAttribute x = this.Attribute(XName.Get("bezier-offset", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bezier-offset", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> bezieroffset2 {
        get {
            XAttribute x = this.Attribute(XName.Get("bezier-offset2", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bezier-offset2", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> bezierx {
        get {
            XAttribute x = this.Attribute(XName.Get("bezier-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bezier-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> beziery {
        get {
            XAttribute x = this.Attribute(XName.Get("bezier-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bezier-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> bezierx2 {
        get {
            XAttribute x = this.Attribute(XName.Get("bezier-x2", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bezier-x2", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> beziery2 {
        get {
            XAttribute x = this.Attribute(XName.Get("bezier-y2", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bezier-y2", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("tied", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<tied>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Time modification indicates tuplets, double-note tremolos, and other durational changes. A time-modification element shows how the cumulative, sounding effect of tuplets and double-note tremolos compare to the written note type represented by the type and dot elements. Nested tuplets and other notations that use more detailed information need both the time-modification and tuplet elements to be represented accurately.
/// </para>
/// <para>
/// Regular expression: (actualnotes, normalnotes, (normaltype, normaldot*)?)
/// </para>
/// </summary>
public partial class timemodification : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<empty> normaldotField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator timemodification(XElement xe) { return XTypedServices.ToXTypedElement<timemodification>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static timemodification() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// Time modification indicates tuplets, double-note tremolos, and other durational changes. A time-modification element shows how the cumulative, sounding effect of tuplets and double-note tremolos compare to the written note type represented by the type and dot elements. Nested tuplets and other notations that use more detailed information need both the time-modification and tuplet elements to be represented accurately.
    /// </para>
    /// <para>
    /// Regular expression: (actualnotes, normalnotes, (normaltype, normaldot*)?)
    /// </para>
    /// </summary>
    public timemodification() {
    }
    
    /// <summary>
    /// <para>
    /// The actual-notes element describes how many notes are played in the time usually occupied by the number in the normal-notes element.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (actualnotes, normalnotes, (normaltype, normaldot*)?)
    /// </para>
    /// </summary>
    public decimal actualnotes {
        get {
            XElement x = this.GetElement(XName.Get("actual-notes", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetElement(XName.Get("actual-notes", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// The normal-notes element describes how many notes are usually played in the time occupied by the number in the actual-notes element.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (actualnotes, normalnotes, (normaltype, normaldot*)?)
    /// </para>
    /// </summary>
    public decimal normalnotes {
        get {
            XElement x = this.GetElement(XName.Get("normal-notes", ""));
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetElement(XName.Get("normal-notes", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// If the type associated with the number in the normal-notes element is different than the current note type (e.g., a quarter note within an eighth note triplet), then the normal-notes type (e.g. eighth) is specified in the normal-type and normal-dot elements.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (actualnotes, normalnotes, (normaltype, normaldot*)?)
    /// </para>
    /// </summary>
    public string normaltype {
        get {
            XElement x = this.GetElement(XName.Get("normal-type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("normal-type", ""), value, "normaltype", global::notetypevalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// The normal-dot element is used to specify dotted normal tuplet types.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (actualnotes, normalnotes, (normaltype, normaldot*)?)
    /// </para>
    /// </summary>
    public IList<empty> normaldot {
        get {
            if ((this.normaldotField == null)) {
                this.normaldotField = new XTypedList<empty>(this, LinqToXsdTypeManager.Instance, XName.Get("normal-dot", ""));
            }
            return this.normaldotField;
        }
        set {
            if ((value == null)) {
                this.normaldotField = null;
            }
            else {
                if ((this.normaldotField == null)) {
                    this.normaldotField = XTypedList<empty>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("normal-dot", ""));
                }
                else {
                    XTypedServices.SetList<empty>(this.normaldotField, value);
                }
            }
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("time-modification", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<timemodification>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("actual-notes", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("normal-notes", ""), typeof(decimal));
        localElementDictionary.Add(XName.Get("normal-type", ""), typeof(string));
        localElementDictionary.Add(XName.Get("normal-dot", ""), typeof(empty));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// 	The tremolo ornament can be used to indicate either single-note or double-note tremolos. Single-note tremolos use the single type, while double-note tremolos use the start and stop types. The default is "single" for compatibility with Version 1.1. The text of the element indicates the number of tremolo marks and is an integer from 0 to 8. Note that the number of attached beams is not included in this value, but is represented separately using the beam element.
///
///When using double-note tremolos, the duration of each note in the tremolo should correspond to half of the notated type value. A time-modification element should also be added with an actual-notes value of 2 and a normal-notes value of 1. If used within a tuplet, this 2/1 ratio should be multiplied by the existing tuplet ratio.
///
///Using repeater beams for indicating tremolos is deprecated as of MusicXML 3.0.
/// </para>
/// </summary>
public partial class tremolo : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static string typeDefaultValue = "single";
    
         public static explicit operator tremolo(XElement xe) { return XTypedServices.ToXTypedElement<tremolo>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// 	The tremolo ornament can be used to indicate either single-note or double-note tremolos. Single-note tremolos use the single type, while double-note tremolos use the start and stop types. The default is "single" for compatibility with Version 1.1. The text of the element indicates the number of tremolo marks and is an integer from 0 to 8. Note that the number of attached beams is not included in this value, but is represented separately using the beam element.
    ///
    ///When using double-note tremolos, the duration of each note in the tremolo should correspond to half of the notated type value. A time-modification element should also be added with an actual-notes value of 2 and a normal-notes value of 1. If used within a tuplet, this 2/1 ratio should be multiplied by the existing tuplet ratio.
    ///
    ///Using repeater beams for indicating tremolos is deprecated as of MusicXML 3.0.
    /// </para>
    /// </summary>
    public tremolo() {
    }
    
    public decimal TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::tremolomarks.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype, typeDefaultValue);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("tremolo", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<tremolo>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// A tuplet element is present when a tuplet is to be displayed graphically, in addition to the sound data provided by the time-modification elements. The number attribute is used to distinguish nested tuplets. The bracket attribute is used to indicate the presence of a bracket. If unspecified, the results are implementation-dependent. The line-shape attribute is used to specify whether the bracket is straight or in the older curved or slurred style. It is straight by default.
///	
///Whereas a time-modification element shows how the cumulative, sounding effect of tuplets and double-note tremolos compare to the written note type, the tuplet element describes how this is displayed. The tuplet element also provides more detailed representation information than the time-modification element, and is needed to represent nested tuplets and other complex tuplets accurately. 
///	
///The show-number attribute is used to display either the number of actual notes, the number of both actual and normal notes, or neither. It is actual by default. The show-type attribute is used to display either the actual type, both the actual and normal types, or neither. It is none by default.
/// </para>
/// <para>
/// Regular expression: (tupletactual?, tupletnormal?)
/// </para>
/// </summary>
public partial class tuplet : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator tuplet(XElement xe) { return XTypedServices.ToXTypedElement<tuplet>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static tuplet() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("tuplet-actual", "")), new NamedContentModelEntity(XName.Get("tuplet-normal", "")));
    }
    
    /// <summary>
    /// <para>
    /// A tuplet element is present when a tuplet is to be displayed graphically, in addition to the sound data provided by the time-modification elements. The number attribute is used to distinguish nested tuplets. The bracket attribute is used to indicate the presence of a bracket. If unspecified, the results are implementation-dependent. The line-shape attribute is used to specify whether the bracket is straight or in the older curved or slurred style. It is straight by default.
    ///	
    ///Whereas a time-modification element shows how the cumulative, sounding effect of tuplets and double-note tremolos compare to the written note type, the tuplet element describes how this is displayed. The tuplet element also provides more detailed representation information than the time-modification element, and is needed to represent nested tuplets and other complex tuplets accurately. 
    ///	
    ///The show-number attribute is used to display either the number of actual notes, the number of both actual and normal notes, or neither. It is actual by default. The show-type attribute is used to display either the actual type, both the actual and normal types, or neither. It is none by default.
    /// </para>
    /// <para>
    /// Regular expression: (tupletactual?, tupletnormal?)
    /// </para>
    /// </summary>
    public tuplet() {
    }
    
    /// <summary>
    /// <para>
    /// The tuplet-actual element provide optional full control over how the actual part of the tuplet is displayed, including number and note type (with dots). If any of these elements are absent, their values are based on the time-modification element.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (tupletactual?, tupletnormal?)
    /// </para>
    /// </summary>
    public tupletportion tupletactual {
        get {
            XElement x = this.GetElement(XName.Get("tuplet-actual", ""));
            return ((tupletportion)(x));
        }
        set {
            this.SetElement(XName.Get("tuplet-actual", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The tuplet-normal element provide optional full control over how the normal part of the tuplet is displayed, including number and note type (with dots). If any of these elements are absent, their values are based on the time-modification element.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (tupletactual?, tupletnormal?)
    /// </para>
    /// </summary>
    public tupletportion tupletnormal {
        get {
            XElement x = this.GetElement(XName.Get("tuplet-normal", ""));
            return ((tupletportion)(x));
        }
        set {
            this.SetElement(XName.Get("tuplet-normal", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string bracket {
        get {
            XAttribute x = this.Attribute(XName.Get("bracket", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("bracket", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string shownumber {
        get {
            XAttribute x = this.Attribute(XName.Get("show-number", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("show-number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string showtype {
        get {
            XAttribute x = this.Attribute(XName.Get("show-type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("show-type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string lineshape {
        get {
            XAttribute x = this.Attribute(XName.Get("line-shape", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("line-shape", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string placement {
        get {
            XAttribute x = this.Attribute(XName.Get("placement", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("placement", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("tuplet", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<tuplet>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("tuplet-actual", ""), typeof(tupletportion));
        localElementDictionary.Add(XName.Get("tuplet-normal", ""), typeof(tupletportion));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The tuplet-dot type is used to specify dotted normal tuplet types.
/// </para>
/// </summary>
public partial class tupletdot : XTypedElement, IXMetaData {
    
         public static explicit operator tupletdot(XElement xe) { return XTypedServices.ToXTypedElement<tupletdot>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The tuplet-dot type is used to specify dotted normal tuplet types.
    /// </para>
    /// </summary>
    public tupletdot() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("tuplet-dot", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<tupletdot>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The tuplet-number type indicates the number of notes for this portion of the tuplet.
/// </para>
/// </summary>
public partial class tupletnumber : XTypedElement, IXMetaData {
    
         public static explicit operator tupletnumber(XElement xe) { return XTypedServices.ToXTypedElement<tupletnumber>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The tuplet-number type indicates the number of notes for this portion of the tuplet.
    /// </para>
    /// </summary>
    public tupletnumber() {
    }
    
    public decimal TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NonNegativeInteger).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("tuplet-number", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<tupletnumber>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The tuplet-portion type provides optional full control over tuplet specifications. It allows the number and note type (including dots) to be set for the actual and normal portions of a single tuplet. If any of these elements are absent, their values are based on the time-modification element.
/// </para>
/// <para>
/// Regular expression: (tupletnumber?, tuplettype?, tupletdot*)
/// </para>
/// </summary>
public partial class tupletportion : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<tupletdot> tupletdotField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator tupletportion(XElement xe) { return XTypedServices.ToXTypedElement<tupletportion>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static tupletportion() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("tuplet-number", "")), new NamedContentModelEntity(XName.Get("tuplet-type", "")), new NamedContentModelEntity(XName.Get("tuplet-dot", "")));
    }
    
    /// <summary>
    /// <para>
    /// The tuplet-portion type provides optional full control over tuplet specifications. It allows the number and note type (including dots) to be set for the actual and normal portions of a single tuplet. If any of these elements are absent, their values are based on the time-modification element.
    /// </para>
    /// <para>
    /// Regular expression: (tupletnumber?, tuplettype?, tupletdot*)
    /// </para>
    /// </summary>
    public tupletportion() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (tupletnumber?, tuplettype?, tupletdot*)
    /// </para>
    /// </summary>
    public tupletnumber tupletnumber {
        get {
            XElement x = this.GetElement(XName.Get("tuplet-number", ""));
            return ((tupletnumber)(x));
        }
        set {
            this.SetElement(XName.Get("tuplet-number", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (tupletnumber?, tuplettype?, tupletdot*)
    /// </para>
    /// </summary>
    public tuplettype tuplettype {
        get {
            XElement x = this.GetElement(XName.Get("tuplet-type", ""));
            return ((tuplettype)(x));
        }
        set {
            this.SetElement(XName.Get("tuplet-type", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (tupletnumber?, tuplettype?, tupletdot*)
    /// </para>
    /// </summary>
    public IList<tupletdot> tupletdot {
        get {
            if ((this.tupletdotField == null)) {
                this.tupletdotField = new XTypedList<tupletdot>(this, LinqToXsdTypeManager.Instance, XName.Get("tuplet-dot", ""));
            }
            return this.tupletdotField;
        }
        set {
            if ((value == null)) {
                this.tupletdotField = null;
            }
            else {
                if ((this.tupletdotField == null)) {
                    this.tupletdotField = XTypedList<tupletdot>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("tuplet-dot", ""));
                }
                else {
                    XTypedServices.SetList<tupletdot>(this.tupletdotField, value);
                }
            }
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("tuplet-portion", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<tupletportion>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("tuplet-number", ""), typeof(tupletnumber));
        localElementDictionary.Add(XName.Get("tuplet-type", ""), typeof(tuplettype));
        localElementDictionary.Add(XName.Get("tuplet-dot", ""), typeof(tupletdot));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The tuplet-type type indicates the graphical note type of the notes for this portion of the tuplet.
/// </para>
/// </summary>
public partial class tuplettype : XTypedElement, IXMetaData {
    
         public static explicit operator tuplettype(XElement xe) { return XTypedServices.ToXTypedElement<tuplettype>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The tuplet-type type indicates the graphical note type of the notes for this portion of the tuplet.
    /// </para>
    /// </summary>
    public tuplettype() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::notetypevalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("tuplet-type", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<tuplettype>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The unpitched type represents musical elements that are notated on the staff but lack definite pitch, such as unpitched percussion and speaking voice.
/// </para>
/// <para>
/// Regular expression: ((displaystep, displayoctave)?)
/// </para>
/// </summary>
public partial class unpitched : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator unpitched(XElement xe) { return XTypedServices.ToXTypedElement<unpitched>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static unpitched() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The unpitched type represents musical elements that are notated on the staff but lack definite pitch, such as unpitched percussion and speaking voice.
    /// </para>
    /// <para>
    /// Regular expression: ((displaystep, displayoctave)?)
    /// </para>
    /// </summary>
    public unpitched() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((displaystep, displayoctave)?)
    /// </para>
    /// </summary>
    public string displaystep {
        get {
            XElement x = this.GetElement(XName.Get("display-step", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("display-step", ""), value, "displaystep", global::step.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((displaystep, displayoctave)?)
    /// </para>
    /// </summary>
    public System.Nullable<decimal> displayoctave {
        get {
            XElement x = this.GetElement(XName.Get("display-octave", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Integer).Datatype);
        }
        set {
            this.SetElementWithValidation(XName.Get("display-octave", ""), value, "displayoctave", global::octave.TypeDefinition);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("unpitched", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<unpitched>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("display-step", ""), typeof(string));
        localElementDictionary.Add(XName.Get("display-octave", ""), typeof(decimal));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The credit type represents the appearance of the title, composer, arranger, lyricist, copyright, dedication, and other text and graphics that commonly appears on the first page of a score. The credit-words and credit-image elements are similar to the words and image elements for directions. However, since the credit is not part of a measure, the default-x and default-y attributes adjust the origin relative to the bottom left-hand corner of the first page. The enclosure for credit-words is none by default.
///	
///By default, a series of credit-words elements within a single credit element follow one another in sequence visually. Non-positional formatting attributes are carried over from the previous element by default.
///	
///The page attribute for the credit element, new in Version 2.0, specifies the page number where the credit should appear. This is an integer value that starts with 1 for the first page. Its value is 1 by default. Since credits occur before the music, these page numbers do not refer to the page numbering specified by the print element's page-number attribute.
///
///The credit-type element, new in Version 3.0, indicates the purpose behind a credit. Multiple types of data may be combined in a single credit, so multiple elements may be used. Standard values include page number, title, subtitle, composer, arranger, lyricist, and rights.
///
/// </para>
/// <para>
/// Regular expression: (credittype*, link*, bookmark*, (creditimage | (creditwords, (link*, bookmark*, creditwords)*)))
/// </para>
/// </summary>
public partial class credit : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<string> credittypeField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<link> linkField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<bookmark> bookmarkField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<formattedtext> creditwordsField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator credit(XElement xe) { return XTypedServices.ToXTypedElement<credit>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static credit() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The credit type represents the appearance of the title, composer, arranger, lyricist, copyright, dedication, and other text and graphics that commonly appears on the first page of a score. The credit-words and credit-image elements are similar to the words and image elements for directions. However, since the credit is not part of a measure, the default-x and default-y attributes adjust the origin relative to the bottom left-hand corner of the first page. The enclosure for credit-words is none by default.
    ///	
    ///By default, a series of credit-words elements within a single credit element follow one another in sequence visually. Non-positional formatting attributes are carried over from the previous element by default.
    ///	
    ///The page attribute for the credit element, new in Version 2.0, specifies the page number where the credit should appear. This is an integer value that starts with 1 for the first page. Its value is 1 by default. Since credits occur before the music, these page numbers do not refer to the page numbering specified by the print element's page-number attribute.
    ///
    ///The credit-type element, new in Version 3.0, indicates the purpose behind a credit. Multiple types of data may be combined in a single credit, so multiple elements may be used. Standard values include page number, title, subtitle, composer, arranger, lyricist, and rights.
    ///
    /// </para>
    /// <para>
    /// Regular expression: (credittype*, link*, bookmark*, (creditimage | (creditwords, (link*, bookmark*, creditwords)*)))
    /// </para>
    /// </summary>
    public credit() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (credittype*, link*, bookmark*, (creditimage | (creditwords, (link*, bookmark*, creditwords)*)))
    /// </para>
    /// </summary>
    public IList<string> credittype {
        get {
            if ((this.credittypeField == null)) {
                this.credittypeField = new XSimpleList<string>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, XName.Get("credit-type", ""));
            }
            return this.credittypeField;
        }
        set {
            if ((value == null)) {
                this.credittypeField = null;
            }
            else {
                if ((this.credittypeField == null)) {
                    this.credittypeField = XSimpleList<string>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, value, XName.Get("credit-type", ""));
                }
                else {
                    XTypedServices.SetList<System.String>(this.credittypeField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (credittype*, link*, bookmark*, (creditimage | (creditwords, (link*, bookmark*, creditwords)*)))
    /// </para>
    /// </summary>
    public IList<link> link {
        get {
            if ((this.linkField == null)) {
                this.linkField = new XTypedList<link>(this, LinqToXsdTypeManager.Instance, XName.Get("link", ""));
            }
            return this.linkField;
        }
        set {
            if ((value == null)) {
                this.linkField = null;
            }
            else {
                if ((this.linkField == null)) {
                    this.linkField = XTypedList<link>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("link", ""));
                }
                else {
                    XTypedServices.SetList<link>(this.linkField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (credittype*, link*, bookmark*, (creditimage | (creditwords, (link*, bookmark*, creditwords)*)))
    /// </para>
    /// </summary>
    public IList<bookmark> bookmark {
        get {
            if ((this.bookmarkField == null)) {
                this.bookmarkField = new XTypedList<bookmark>(this, LinqToXsdTypeManager.Instance, XName.Get("bookmark", ""));
            }
            return this.bookmarkField;
        }
        set {
            if ((value == null)) {
                this.bookmarkField = null;
            }
            else {
                if ((this.bookmarkField == null)) {
                    this.bookmarkField = XTypedList<bookmark>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("bookmark", ""));
                }
                else {
                    XTypedServices.SetList<bookmark>(this.bookmarkField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (credittype*, link*, bookmark*, (creditimage | (creditwords, (link*, bookmark*, creditwords)*)))
    /// </para>
    /// </summary>
    public image creditimage {
        get {
            XElement x = this.GetElement(XName.Get("credit-image", ""));
            return ((image)(x));
        }
        set {
            this.SetElement(XName.Get("credit-image", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (credittype*, link*, bookmark*, (creditimage | (creditwords, (link*, bookmark*, creditwords)*)))
    /// </para>
    /// </summary>
    public IList<formattedtext> creditwords {
        get {
            if ((this.creditwordsField == null)) {
                this.creditwordsField = new XTypedList<formattedtext>(this, LinqToXsdTypeManager.Instance, XName.Get("credit-words", ""));
            }
            return this.creditwordsField;
        }
        set {
            if ((value == null)) {
                this.creditwordsField = null;
            }
            else {
                if ((this.creditwordsField == null)) {
                    this.creditwordsField = XTypedList<formattedtext>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("credit-words", ""));
                }
                else {
                    XTypedServices.SetList<formattedtext>(this.creditwordsField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> page {
        get {
            XAttribute x = this.Attribute(XName.Get("page", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("page", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.PositiveInteger).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("credit", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<credit>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("credit-type", ""), typeof(string));
        localElementDictionary.Add(XName.Get("link", ""), typeof(link));
        localElementDictionary.Add(XName.Get("bookmark", ""), typeof(bookmark));
        localElementDictionary.Add(XName.Get("credit-image", ""), typeof(image));
        localElementDictionary.Add(XName.Get("credit-words", ""), typeof(formattedtext));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The defaults type specifies score-wide defaults for scaling, layout, and appearance.
/// </para>
/// <para>
/// Regular expression: (scaling?, pagelayout?, systemlayout?, stafflayout*, appearance?, musicfont?, wordfont?, lyricfont*, lyriclanguage*)
/// </para>
/// </summary>
public partial class defaults : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<stafflayout> stafflayoutField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<lyricfont> lyricfontField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<lyriclanguage> lyriclanguageField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator defaults(XElement xe) { return XTypedServices.ToXTypedElement<defaults>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static defaults() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("scaling", "")), new NamedContentModelEntity(XName.Get("page-layout", "")), new NamedContentModelEntity(XName.Get("system-layout", "")), new NamedContentModelEntity(XName.Get("staff-layout", "")), new NamedContentModelEntity(XName.Get("appearance", "")), new NamedContentModelEntity(XName.Get("music-font", "")), new NamedContentModelEntity(XName.Get("word-font", "")), new NamedContentModelEntity(XName.Get("lyric-font", "")), new NamedContentModelEntity(XName.Get("lyric-language", "")));
    }
    
    /// <summary>
    /// <para>
    /// The defaults type specifies score-wide defaults for scaling, layout, and appearance.
    /// </para>
    /// <para>
    /// Regular expression: (scaling?, pagelayout?, systemlayout?, stafflayout*, appearance?, musicfont?, wordfont?, lyricfont*, lyriclanguage*)
    /// </para>
    /// </summary>
    public defaults() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (scaling?, pagelayout?, systemlayout?, stafflayout*, appearance?, musicfont?, wordfont?, lyricfont*, lyriclanguage*)
    /// </para>
    /// </summary>
    public scaling scaling {
        get {
            XElement x = this.GetElement(XName.Get("scaling", ""));
            return ((scaling)(x));
        }
        set {
            this.SetElement(XName.Get("scaling", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (scaling?, pagelayout?, systemlayout?, stafflayout*, appearance?, musicfont?, wordfont?, lyricfont*, lyriclanguage*)
    /// </para>
    /// </summary>
    public pagelayout pagelayout {
        get {
            XElement x = this.GetElement(XName.Get("page-layout", ""));
            return ((pagelayout)(x));
        }
        set {
            this.SetElement(XName.Get("page-layout", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (scaling?, pagelayout?, systemlayout?, stafflayout*, appearance?, musicfont?, wordfont?, lyricfont*, lyriclanguage*)
    /// </para>
    /// </summary>
    public systemlayout systemlayout {
        get {
            XElement x = this.GetElement(XName.Get("system-layout", ""));
            return ((systemlayout)(x));
        }
        set {
            this.SetElement(XName.Get("system-layout", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (scaling?, pagelayout?, systemlayout?, stafflayout*, appearance?, musicfont?, wordfont?, lyricfont*, lyriclanguage*)
    /// </para>
    /// </summary>
    public IList<stafflayout> stafflayout {
        get {
            if ((this.stafflayoutField == null)) {
                this.stafflayoutField = new XTypedList<stafflayout>(this, LinqToXsdTypeManager.Instance, XName.Get("staff-layout", ""));
            }
            return this.stafflayoutField;
        }
        set {
            if ((value == null)) {
                this.stafflayoutField = null;
            }
            else {
                if ((this.stafflayoutField == null)) {
                    this.stafflayoutField = XTypedList<stafflayout>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("staff-layout", ""));
                }
                else {
                    XTypedServices.SetList<stafflayout>(this.stafflayoutField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (scaling?, pagelayout?, systemlayout?, stafflayout*, appearance?, musicfont?, wordfont?, lyricfont*, lyriclanguage*)
    /// </para>
    /// </summary>
    public appearance appearance {
        get {
            XElement x = this.GetElement(XName.Get("appearance", ""));
            return ((appearance)(x));
        }
        set {
            this.SetElement(XName.Get("appearance", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (scaling?, pagelayout?, systemlayout?, stafflayout*, appearance?, musicfont?, wordfont?, lyricfont*, lyriclanguage*)
    /// </para>
    /// </summary>
    public emptyfont musicfont {
        get {
            XElement x = this.GetElement(XName.Get("music-font", ""));
            return ((emptyfont)(x));
        }
        set {
            this.SetElement(XName.Get("music-font", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (scaling?, pagelayout?, systemlayout?, stafflayout*, appearance?, musicfont?, wordfont?, lyricfont*, lyriclanguage*)
    /// </para>
    /// </summary>
    public emptyfont wordfont {
        get {
            XElement x = this.GetElement(XName.Get("word-font", ""));
            return ((emptyfont)(x));
        }
        set {
            this.SetElement(XName.Get("word-font", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (scaling?, pagelayout?, systemlayout?, stafflayout*, appearance?, musicfont?, wordfont?, lyricfont*, lyriclanguage*)
    /// </para>
    /// </summary>
    public IList<lyricfont> lyricfont {
        get {
            if ((this.lyricfontField == null)) {
                this.lyricfontField = new XTypedList<lyricfont>(this, LinqToXsdTypeManager.Instance, XName.Get("lyric-font", ""));
            }
            return this.lyricfontField;
        }
        set {
            if ((value == null)) {
                this.lyricfontField = null;
            }
            else {
                if ((this.lyricfontField == null)) {
                    this.lyricfontField = XTypedList<lyricfont>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("lyric-font", ""));
                }
                else {
                    XTypedServices.SetList<lyricfont>(this.lyricfontField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (scaling?, pagelayout?, systemlayout?, stafflayout*, appearance?, musicfont?, wordfont?, lyricfont*, lyriclanguage*)
    /// </para>
    /// </summary>
    public IList<lyriclanguage> lyriclanguage {
        get {
            if ((this.lyriclanguageField == null)) {
                this.lyriclanguageField = new XTypedList<lyriclanguage>(this, LinqToXsdTypeManager.Instance, XName.Get("lyric-language", ""));
            }
            return this.lyriclanguageField;
        }
        set {
            if ((value == null)) {
                this.lyriclanguageField = null;
            }
            else {
                if ((this.lyriclanguageField == null)) {
                    this.lyriclanguageField = XTypedList<lyriclanguage>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("lyric-language", ""));
                }
                else {
                    XTypedServices.SetList<lyriclanguage>(this.lyriclanguageField, value);
                }
            }
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("defaults", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<defaults>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("scaling", ""), typeof(scaling));
        localElementDictionary.Add(XName.Get("page-layout", ""), typeof(pagelayout));
        localElementDictionary.Add(XName.Get("system-layout", ""), typeof(systemlayout));
        localElementDictionary.Add(XName.Get("staff-layout", ""), typeof(stafflayout));
        localElementDictionary.Add(XName.Get("appearance", ""), typeof(appearance));
        localElementDictionary.Add(XName.Get("music-font", ""), typeof(emptyfont));
        localElementDictionary.Add(XName.Get("word-font", ""), typeof(emptyfont));
        localElementDictionary.Add(XName.Get("lyric-font", ""), typeof(lyricfont));
        localElementDictionary.Add(XName.Get("lyric-language", ""), typeof(lyriclanguage));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// The empty-font type represents an empty element with font attributes.
/// </para>
/// </summary>
public partial class emptyfont : XTypedElement, IXMetaData {
    
         public static explicit operator emptyfont(XElement xe) { return XTypedServices.ToXTypedElement<emptyfont>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The empty-font type represents an empty element with font attributes.
    /// </para>
    /// </summary>
    public emptyfont() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("empty-font", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<emptyfont>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The group-barline type indicates if the group should have common barlines.
/// </para>
/// </summary>
public partial class groupbarline : XTypedElement, IXMetaData {
    
         public static explicit operator groupbarline(XElement xe) { return XTypedServices.ToXTypedElement<groupbarline>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The group-barline type indicates if the group should have common barlines.
    /// </para>
    /// </summary>
    public groupbarline() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::groupbarlinevalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("group-barline", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<groupbarline>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The group-name type describes the name or abbreviation of a part-group element. Formatting attributes in the group-name type are deprecated in Version 2.0 in favor of the new group-name-display and group-abbreviation-display elements.
/// </para>
/// </summary>
public partial class groupname : XTypedElement, IXMetaData {
    
         public static explicit operator groupname(XElement xe) { return XTypedServices.ToXTypedElement<groupname>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The group-name type describes the name or abbreviation of a part-group element. Formatting attributes in the group-name type are deprecated in Version 2.0 in favor of the new group-name-display and group-abbreviation-display elements.
    /// </para>
    /// </summary>
    public groupname() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string justify {
        get {
            XAttribute x = this.Attribute(XName.Get("justify", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("justify", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("group-name", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<groupname>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The group-symbol type indicates how the symbol for a group is indicated in the score.
/// </para>
/// </summary>
public partial class groupsymbol : XTypedElement, IXMetaData {
    
         public static explicit operator groupsymbol(XElement xe) { return XTypedServices.ToXTypedElement<groupsymbol>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The group-symbol type indicates how the symbol for a group is indicated in the score.
    /// </para>
    /// </summary>
    public groupsymbol() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValueWithValidation(value, "TypedValue", global::groupsymbolvalue.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("group-symbol", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<groupsymbol>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The lyric-font type specifies the default font for a particular name and number of lyric.
/// </para>
/// </summary>
public partial class lyricfont : XTypedElement, IXMetaData {
    
         public static explicit operator lyricfont(XElement xe) { return XTypedServices.ToXTypedElement<lyricfont>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The lyric-font type specifies the default font for a particular name and number of lyric.
    /// </para>
    /// </summary>
    public lyricfont() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string name {
        get {
            XAttribute x = this.Attribute(XName.Get("name", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("lyric-font", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<lyricfont>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The lyric-language type specifies the default language for a particular name and number of lyric.
/// </para>
/// </summary>
public partial class lyriclanguage : XTypedElement, IXMetaData {
    
         public static explicit operator lyriclanguage(XElement xe) { return XTypedServices.ToXTypedElement<lyriclanguage>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The lyric-language type specifies the default language for a particular name and number of lyric.
    /// </para>
    /// </summary>
    public lyriclanguage() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string name {
        get {
            XAttribute x = this.Attribute(XName.Get("name", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public object lang {
        get {
            XAttribute x = this.Attribute(XName.Get("lang", "http://www.w3.org/XML/1998/namespace"));
            return XTypedServices.ParseUnionValue(x, global::www.w3.org.XML.Item1998.@namespace.lang.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "lang", this, XName.Get("lang", "http://www.w3.org/XML/1998/namespace"), global::www.w3.org.XML.Item1998.@namespace.lang.TypeDefinition);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("lyric-language", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<lyriclanguage>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The opus type represents a link to a MusicXML opus document that composes multiple MusicXML scores into a collection.
/// </para>
/// </summary>
public partial class opus : XTypedElement, IXMetaData {
    
         public static explicit operator opus(XElement xe) { return XTypedServices.ToXTypedElement<opus>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The opus type represents a link to a MusicXML opus document that composes multiple MusicXML scores into a collection.
    /// </para>
    /// </summary>
    public opus() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public System.Uri href {
        get {
            XAttribute x = this.Attribute(XName.Get("href", "http://www.w3.org/1999/xlink"));
            return XTypedServices.ParseValue<System.Uri>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("href", "http://www.w3.org/1999/xlink"), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyUri).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", "http://www.w3.org/1999/xlink"));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", "http://www.w3.org/1999/xlink"), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string role {
        get {
            XAttribute x = this.Attribute(XName.Get("role", "http://www.w3.org/1999/xlink"));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("role", "http://www.w3.org/1999/xlink"), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string title {
        get {
            XAttribute x = this.Attribute(XName.Get("title", "http://www.w3.org/1999/xlink"));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("title", "http://www.w3.org/1999/xlink"), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string show {
        get {
            XAttribute x = this.Attribute(XName.Get("show", "http://www.w3.org/1999/xlink"));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("show", "http://www.w3.org/1999/xlink"), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string actuate {
        get {
            XAttribute x = this.Attribute(XName.Get("actuate", "http://www.w3.org/1999/xlink"));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("actuate", "http://www.w3.org/1999/xlink"), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.NmToken).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("opus", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<opus>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The part-group element indicates groupings of parts in the score, usually indicated by braces and brackets. Braces that are used for multi-staff parts should be defined in the attributes element for that part. The part-group start element appears before the first score-part in the group. The part-group stop element appears after the last score-part in the group.
///	
///The number attribute is used to distinguish overlapping and nested part-groups, not the sequence of groups. As with parts, groups can have a name and abbreviation. Values for the child elements are ignored at the stop of a group. 
///	
///A part-group element is not needed for a single multi-staff part. By default, multi-staff parts include a brace symbol and (if appropriate given the bar-style) common barlines. The symbol formatting for a multi-staff part can be more fully specified using the part-symbol element.
/// </para>
/// <para>
/// Regular expression: (groupname?, groupnamedisplay?, groupabbreviation?, groupabbreviationdisplay?, groupsymbol?, groupbarline?, grouptime?, (footnote)?, (level)?)
/// </para>
/// </summary>
public partial class partgroup : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static string numberDefaultValue = "1";
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator partgroup(XElement xe) { return XTypedServices.ToXTypedElement<partgroup>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static partgroup() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The part-group element indicates groupings of parts in the score, usually indicated by braces and brackets. Braces that are used for multi-staff parts should be defined in the attributes element for that part. The part-group start element appears before the first score-part in the group. The part-group stop element appears after the last score-part in the group.
    ///	
    ///The number attribute is used to distinguish overlapping and nested part-groups, not the sequence of groups. As with parts, groups can have a name and abbreviation. Values for the child elements are ignored at the stop of a group. 
    ///	
    ///A part-group element is not needed for a single multi-staff part. By default, multi-staff parts include a brace symbol and (if appropriate given the bar-style) common barlines. The symbol formatting for a multi-staff part can be more fully specified using the part-symbol element.
    /// </para>
    /// <para>
    /// Regular expression: (groupname?, groupnamedisplay?, groupabbreviation?, groupabbreviationdisplay?, groupsymbol?, groupbarline?, grouptime?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public partgroup() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (groupname?, groupnamedisplay?, groupabbreviation?, groupabbreviationdisplay?, groupsymbol?, groupbarline?, grouptime?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public groupname groupname {
        get {
            XElement x = this.GetElement(XName.Get("group-name", ""));
            return ((groupname)(x));
        }
        set {
            this.SetElement(XName.Get("group-name", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Formatting specified in the group-name-display element overrides formatting specified in the group-name element.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (groupname?, groupnamedisplay?, groupabbreviation?, groupabbreviationdisplay?, groupsymbol?, groupbarline?, grouptime?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public namedisplay groupnamedisplay {
        get {
            XElement x = this.GetElement(XName.Get("group-name-display", ""));
            return ((namedisplay)(x));
        }
        set {
            this.SetElement(XName.Get("group-name-display", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (groupname?, groupnamedisplay?, groupabbreviation?, groupabbreviationdisplay?, groupsymbol?, groupbarline?, grouptime?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public groupname groupabbreviation {
        get {
            XElement x = this.GetElement(XName.Get("group-abbreviation", ""));
            return ((groupname)(x));
        }
        set {
            this.SetElement(XName.Get("group-abbreviation", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Formatting specified in the group-abbreviation-display element overrides formatting specified in the group-abbreviation element.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (groupname?, groupnamedisplay?, groupabbreviation?, groupabbreviationdisplay?, groupsymbol?, groupbarline?, grouptime?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public namedisplay groupabbreviationdisplay {
        get {
            XElement x = this.GetElement(XName.Get("group-abbreviation-display", ""));
            return ((namedisplay)(x));
        }
        set {
            this.SetElement(XName.Get("group-abbreviation-display", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (groupname?, groupnamedisplay?, groupabbreviation?, groupabbreviationdisplay?, groupsymbol?, groupbarline?, grouptime?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public groupsymbol groupsymbol {
        get {
            XElement x = this.GetElement(XName.Get("group-symbol", ""));
            return ((groupsymbol)(x));
        }
        set {
            this.SetElement(XName.Get("group-symbol", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (groupname?, groupnamedisplay?, groupabbreviation?, groupabbreviationdisplay?, groupsymbol?, groupbarline?, grouptime?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public groupbarline groupbarline {
        get {
            XElement x = this.GetElement(XName.Get("group-barline", ""));
            return ((groupbarline)(x));
        }
        set {
            this.SetElement(XName.Get("group-barline", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The group-time element indicates that the displayed time signatures should stretch across all parts and staves in the group.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (groupname?, groupnamedisplay?, groupabbreviation?, groupabbreviationdisplay?, groupsymbol?, groupbarline?, grouptime?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public empty grouptime {
        get {
            XElement x = this.GetElement(XName.Get("group-time", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("group-time", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (groupname?, groupnamedisplay?, groupabbreviation?, groupabbreviationdisplay?, groupsymbol?, groupbarline?, grouptime?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public formattedtext footnote {
        get {
            XElement x = this.GetElement(XName.Get("footnote", ""));
            return ((formattedtext)(x));
        }
        set {
            this.SetElement(XName.Get("footnote", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (groupname?, groupnamedisplay?, groupabbreviation?, groupabbreviationdisplay?, groupsymbol?, groupbarline?, grouptime?, (footnote)?, (level)?)
    /// </para>
    /// </summary>
    public level level {
        get {
            XElement x = this.GetElement(XName.Get("level", ""));
            return ((level)(x));
        }
        set {
            this.SetElement(XName.Get("level", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string type {
        get {
            XAttribute x = this.Attribute(XName.Get("type", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("type", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string number {
        get {
            XAttribute x = this.Attribute(XName.Get("number", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype, numberDefaultValue);
        }
        set {
            this.SetAttribute(XName.Get("number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("part-group", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<partgroup>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("group-name", ""), typeof(groupname));
        localElementDictionary.Add(XName.Get("group-name-display", ""), typeof(namedisplay));
        localElementDictionary.Add(XName.Get("group-abbreviation", ""), typeof(groupname));
        localElementDictionary.Add(XName.Get("group-abbreviation-display", ""), typeof(namedisplay));
        localElementDictionary.Add(XName.Get("group-symbol", ""), typeof(groupsymbol));
        localElementDictionary.Add(XName.Get("group-barline", ""), typeof(groupbarline));
        localElementDictionary.Add(XName.Get("group-time", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("footnote", ""), typeof(formattedtext));
        localElementDictionary.Add(XName.Get("level", ""), typeof(level));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The part-list identifies the different musical parts in this movement. Each part has an ID that is used later within the musical data. Since parts may be encoded separately and combined later, identification elements are present at both the score and score-part levels. There must be at least one score-part, combined as desired with part-group elements that indicate braces and brackets. Parts are ordered from top to bottom in a score based on the order in which they appear in the part-list.
/// </para>
/// <para>
/// Regular expression: ((partgroup)*, scorepart, ((partgroup)|(scorepart))*)
/// </para>
/// </summary>
public partial class partlist : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<partgroup> partgroupField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<scorepart> scorepartField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator partlist(XElement xe) { return XTypedServices.ToXTypedElement<partlist>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static partlist() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The part-list identifies the different musical parts in this movement. Each part has an ID that is used later within the musical data. Since parts may be encoded separately and combined later, identification elements are present at both the score and score-part levels. There must be at least one score-part, combined as desired with part-group elements that indicate braces and brackets. Parts are ordered from top to bottom in a score based on the order in which they appear in the part-list.
    /// </para>
    /// <para>
    /// Regular expression: ((partgroup)*, scorepart, ((partgroup)|(scorepart))*)
    /// </para>
    /// </summary>
    public partlist() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: ((partgroup)*, scorepart, ((partgroup)|(scorepart))*)
    /// </para>
    /// </summary>
    public IList<partgroup> partgroup {
        get {
            if ((this.partgroupField == null)) {
                this.partgroupField = new XTypedList<partgroup>(this, LinqToXsdTypeManager.Instance, XName.Get("part-group", ""));
            }
            return this.partgroupField;
        }
        set {
            if ((value == null)) {
                this.partgroupField = null;
            }
            else {
                if ((this.partgroupField == null)) {
                    this.partgroupField = XTypedList<partgroup>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("part-group", ""));
                }
                else {
                    XTypedServices.SetList<partgroup>(this.partgroupField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Each MusicXML part corresponds to a track in a Standard MIDI Format 1 file. The score-instrument elements are used when there are multiple instruments per track. The midi-device element is used to make a MIDI device or port assignment for the given track. Initial midi-instrument assignments may be made here as well.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: ((partgroup)*, scorepart, ((partgroup)|(scorepart))*)
    /// </para>
    /// </summary>
    public IList<scorepart> scorepart {
        get {
            if ((this.scorepartField == null)) {
                this.scorepartField = new XTypedList<scorepart>(this, LinqToXsdTypeManager.Instance, XName.Get("score-part", ""));
            }
            return this.scorepartField;
        }
        set {
            if ((value == null)) {
                this.scorepartField = null;
            }
            else {
                if ((this.scorepartField == null)) {
                    this.scorepartField = XTypedList<scorepart>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("score-part", ""));
                }
                else {
                    XTypedServices.SetList<scorepart>(this.scorepartField, value);
                }
            }
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("part-list", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<partlist>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("part-group", ""), typeof(partgroup));
        localElementDictionary.Add(XName.Get("score-part", ""), typeof(scorepart));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The part-name type describes the name or abbreviation of a score-part element. Formatting attributes for the part-name element are deprecated in Version 2.0 in favor of the new part-name-display and part-abbreviation-display elements.
/// </para>
/// </summary>
public partial class partname : XTypedElement, IXMetaData {
    
         public static explicit operator partname(XElement xe) { return XTypedServices.ToXTypedElement<partname>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    /// <summary>
    /// <para>
    /// The part-name type describes the name or abbreviation of a score-part element. Formatting attributes for the part-name element are deprecated in Version 2.0 in favor of the new part-name-display and part-abbreviation-display elements.
    /// </para>
    /// </summary>
    public partname() {
    }
    
    public string TypedValue {
        get {
            XElement x = this.Untyped;
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetValue(value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaultx {
        get {
            XAttribute x = this.Attribute(XName.Get("default-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> defaulty {
        get {
            XAttribute x = this.Attribute(XName.Get("default-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("default-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativex {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-x", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-x", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public System.Nullable<decimal> relativey {
        get {
            XAttribute x = this.Attribute(XName.Get("relative-y", ""));
            if ((x == null)) {
                return null;
            }
            return XTypedServices.ParseValue<decimal>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("relative-y", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Decimal).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontfamily {
        get {
            XAttribute x = this.Attribute(XName.Get("font-family", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-family", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontstyle {
        get {
            XAttribute x = this.Attribute(XName.Get("font-style", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-style", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public object fontsize {
        get {
            XAttribute x = this.Attribute(XName.Get("font-size", ""));
            return XTypedServices.ParseUnionValue(x, global::fontsize.TypeDefinition);
        }
        set {
            this.SetUnionAttribute(value, "fontsize", this, XName.Get("font-size", ""), global::fontsize.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string fontweight {
        get {
            XAttribute x = this.Attribute(XName.Get("font-weight", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("font-weight", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string color {
        get {
            XAttribute x = this.Attribute(XName.Get("color", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("color", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string printobject {
        get {
            XAttribute x = this.Attribute(XName.Get("print-object", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("print-object", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// </summary>
    public string justify {
        get {
            XAttribute x = this.Attribute(XName.Get("justify", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("justify", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Token).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("part-name", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<partname>(this);
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The score-instrument type represents a single instrument within a score-part. As with the score-part type, each score-instrument has a required ID attribute, a name, and an optional abbreviation.
///	
///A score-instrument type is also required if the score specifies MIDI 1.0 channels, banks, or programs. An initial midi-instrument assignment can also be made here. MusicXML software should be able to automatically assign reasonable channels and instruments without these elements in simple cases, such as where part names match General MIDI instrument names.
/// </para>
/// <para>
/// Regular expression: (instrumentname, instrumentabbreviation?, instrumentsound?, (solo | ensemble)?, virtualinstrument?)
/// </para>
/// </summary>
public partial class scoreinstrument : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator scoreinstrument(XElement xe) { return XTypedServices.ToXTypedElement<scoreinstrument>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static scoreinstrument() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// The score-instrument type represents a single instrument within a score-part. As with the score-part type, each score-instrument has a required ID attribute, a name, and an optional abbreviation.
    ///	
    ///A score-instrument type is also required if the score specifies MIDI 1.0 channels, banks, or programs. An initial midi-instrument assignment can also be made here. MusicXML software should be able to automatically assign reasonable channels and instruments without these elements in simple cases, such as where part names match General MIDI instrument names.
    /// </para>
    /// <para>
    /// Regular expression: (instrumentname, instrumentabbreviation?, instrumentsound?, (solo | ensemble)?, virtualinstrument?)
    /// </para>
    /// </summary>
    public scoreinstrument() {
    }
    
    /// <summary>
    /// <para>
    /// The instrument-name element is typically used within a software application, rather than appearing on the printed page of a score.
    /// </para>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (instrumentname, instrumentabbreviation?, instrumentsound?, (solo | ensemble)?, virtualinstrument?)
    /// </para>
    /// </summary>
    public string instrumentname {
        get {
            XElement x = this.GetElement(XName.Get("instrument-name", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("instrument-name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// The optional instrument-abbreviation element is typically used within a software application, rather than appearing on the printed page of a score.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (instrumentname, instrumentabbreviation?, instrumentsound?, (solo | ensemble)?, virtualinstrument?)
    /// </para>
    /// </summary>
    public string instrumentabbreviation {
        get {
            XElement x = this.GetElement(XName.Get("instrument-abbreviation", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("instrument-abbreviation", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// The instrument-sound element describes the default timbre of the score-instrument. This description is independent of a particular virtual or MIDI instrument specification and allows playback to be shared more easily between applications and libraries.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (instrumentname, instrumentabbreviation?, instrumentsound?, (solo | ensemble)?, virtualinstrument?)
    /// </para>
    /// </summary>
    public string instrumentsound {
        get {
            XElement x = this.GetElement(XName.Get("instrument-sound", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("instrument-sound", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// The solo element was added in Version 2.0. It is present if performance is intended by a solo instrument.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (instrumentname, instrumentabbreviation?, instrumentsound?, (solo | ensemble)?, virtualinstrument?)
    /// </para>
    /// </summary>
    public empty solo {
        get {
            XElement x = this.GetElement(XName.Get("solo", ""));
            return ((empty)(x));
        }
        set {
            this.SetElement(XName.Get("solo", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The ensemble element was added in Version 2.0. It is present if performance is intended by an ensemble such as an orchestral section. The text of the ensemble element contains the size of the section, or is empty if the ensemble size is not specified.
    /// </para>
    /// <para>
    /// Occurrence: required, choice
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (instrumentname, instrumentabbreviation?, instrumentsound?, (solo | ensemble)?, virtualinstrument?)
    /// </para>
    /// </summary>
    public object ensemble {
        get {
            XElement x = this.GetElement(XName.Get("ensemble", ""));
            return XTypedServices.ParseUnionValue(x, global::positiveintegerorempty.TypeDefinition);
        }
        set {
            this.SetElementWithValidation(XName.Get("ensemble", ""), value, "ensemble", global::positiveintegerorempty.TypeDefinition);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (instrumentname, instrumentabbreviation?, instrumentsound?, (solo | ensemble)?, virtualinstrument?)
    /// </para>
    /// </summary>
    public virtualinstrument virtualinstrument {
        get {
            XElement x = this.GetElement(XName.Get("virtual-instrument", ""));
            return ((virtualinstrument)(x));
        }
        set {
            this.SetElement(XName.Get("virtual-instrument", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string id {
        get {
            XAttribute x = this.Attribute(XName.Get("id", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("id", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("score-instrument", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<scoreinstrument>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("instrument-name", ""), typeof(string));
        localElementDictionary.Add(XName.Get("instrument-abbreviation", ""), typeof(string));
        localElementDictionary.Add(XName.Get("instrument-sound", ""), typeof(string));
        localElementDictionary.Add(XName.Get("solo", ""), typeof(empty));
        localElementDictionary.Add(XName.Get("ensemble", ""), typeof(object));
        localElementDictionary.Add(XName.Get("virtual-instrument", ""), typeof(virtualinstrument));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// Each MusicXML part corresponds to a track in a Standard MIDI Format 1 file. The score-instrument elements are used when there are multiple instruments per track. The midi-device element is used to make a MIDI device or port assignment for the given track or specific MIDI instruments. Initial midi-instrument assignments may be made here as well.
/// </para>
/// <para>
/// Regular expression: (identification?, partname, partnamedisplay?, partabbreviation?, partabbreviationdisplay?, group*, scoreinstrument*, (mididevice?, midiinstrument?)*)
/// </para>
/// </summary>
public partial class scorepart : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XSimpleList<string> groupField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<scoreinstrument> scoreinstrumentField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<mididevice> midideviceField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedList<midiinstrument> midiinstrumentField;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
         public static explicit operator scorepart(XElement xe) { return XTypedServices.ToXTypedElement<scorepart>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static scorepart() {
        BuildElementDictionary();
    }
    
    /// <summary>
    /// <para>
    /// Each MusicXML part corresponds to a track in a Standard MIDI Format 1 file. The score-instrument elements are used when there are multiple instruments per track. The midi-device element is used to make a MIDI device or port assignment for the given track or specific MIDI instruments. Initial midi-instrument assignments may be made here as well.
    /// </para>
    /// <para>
    /// Regular expression: (identification?, partname, partnamedisplay?, partabbreviation?, partabbreviationdisplay?, group*, scoreinstrument*, (mididevice?, midiinstrument?)*)
    /// </para>
    /// </summary>
    public scorepart() {
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (identification?, partname, partnamedisplay?, partabbreviation?, partabbreviationdisplay?, group*, scoreinstrument*, (mididevice?, midiinstrument?)*)
    /// </para>
    /// </summary>
    public identification identification {
        get {
            XElement x = this.GetElement(XName.Get("identification", ""));
            return ((identification)(x));
        }
        set {
            this.SetElement(XName.Get("identification", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// <para>
    /// Regular expression: (identification?, partname, partnamedisplay?, partabbreviation?, partabbreviationdisplay?, group*, scoreinstrument*, (mididevice?, midiinstrument?)*)
    /// </para>
    /// </summary>
    public partname partname {
        get {
            XElement x = this.GetElement(XName.Get("part-name", ""));
            return ((partname)(x));
        }
        set {
            this.SetElement(XName.Get("part-name", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (identification?, partname, partnamedisplay?, partabbreviation?, partabbreviationdisplay?, group*, scoreinstrument*, (mididevice?, midiinstrument?)*)
    /// </para>
    /// </summary>
    public namedisplay partnamedisplay {
        get {
            XElement x = this.GetElement(XName.Get("part-name-display", ""));
            return ((namedisplay)(x));
        }
        set {
            this.SetElement(XName.Get("part-name-display", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (identification?, partname, partnamedisplay?, partabbreviation?, partabbreviationdisplay?, group*, scoreinstrument*, (mididevice?, midiinstrument?)*)
    /// </para>
    /// </summary>
    public partname partabbreviation {
        get {
            XElement x = this.GetElement(XName.Get("part-abbreviation", ""));
            return ((partname)(x));
        }
        set {
            this.SetElement(XName.Get("part-abbreviation", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (identification?, partname, partnamedisplay?, partabbreviation?, partabbreviationdisplay?, group*, scoreinstrument*, (mididevice?, midiinstrument?)*)
    /// </para>
    /// </summary>
    public namedisplay partabbreviationdisplay {
        get {
            XElement x = this.GetElement(XName.Get("part-abbreviation-display", ""));
            return ((namedisplay)(x));
        }
        set {
            this.SetElement(XName.Get("part-abbreviation-display", ""), value);
        }
    }
    
    /// <summary>
    /// <para>
    /// The group element allows the use of different versions of the part for different purposes. Typical values include score, parts, sound, and data. Ordering information that is directly encoded in MuseData can be derived from the ordering within a MusicXML score or opus.
    /// </para>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (identification?, partname, partnamedisplay?, partabbreviation?, partabbreviationdisplay?, group*, scoreinstrument*, (mididevice?, midiinstrument?)*)
    /// </para>
    /// </summary>
    public IList<string> group {
        get {
            if ((this.groupField == null)) {
                this.groupField = new XSimpleList<string>(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, XName.Get("group", ""));
            }
            return this.groupField;
        }
        set {
            if ((value == null)) {
                this.groupField = null;
            }
            else {
                if ((this.groupField == null)) {
                    this.groupField = XSimpleList<string>.Initialize(this, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype, value, XName.Get("group", ""));
                }
                else {
                    XTypedServices.SetList<System.String>(this.groupField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional, repeating
    /// </para>
    /// <para>
    /// Regular expression: (identification?, partname, partnamedisplay?, partabbreviation?, partabbreviationdisplay?, group*, scoreinstrument*, (mididevice?, midiinstrument?)*)
    /// </para>
    /// </summary>
    public IList<scoreinstrument> scoreinstrument {
        get {
            if ((this.scoreinstrumentField == null)) {
                this.scoreinstrumentField = new XTypedList<scoreinstrument>(this, LinqToXsdTypeManager.Instance, XName.Get("score-instrument", ""));
            }
            return this.scoreinstrumentField;
        }
        set {
            if ((value == null)) {
                this.scoreinstrumentField = null;
            }
            else {
                if ((this.scoreinstrumentField == null)) {
                    this.scoreinstrumentField = XTypedList<scoreinstrument>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("score-instrument", ""));
                }
                else {
                    XTypedServices.SetList<scoreinstrument>(this.scoreinstrumentField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (identification?, partname, partnamedisplay?, partabbreviation?, partabbreviationdisplay?, group*, scoreinstrument*, (mididevice?, midiinstrument?)*)
    /// </para>
    /// </summary>
    public IList<mididevice> mididevice {
        get {
            if ((this.midideviceField == null)) {
                this.midideviceField = new XTypedList<mididevice>(this, LinqToXsdTypeManager.Instance, XName.Get("midi-device", ""));
            }
            return this.midideviceField;
        }
        set {
            if ((value == null)) {
                this.midideviceField = null;
            }
            else {
                if ((this.midideviceField == null)) {
                    this.midideviceField = XTypedList<mididevice>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("midi-device", ""));
                }
                else {
                    XTypedServices.SetList<mididevice>(this.midideviceField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Setter: Appends
    /// </para>
    /// <para>
    /// Regular expression: (identification?, partname, partnamedisplay?, partabbreviation?, partabbreviationdisplay?, group*, scoreinstrument*, (mididevice?, midiinstrument?)*)
    /// </para>
    /// </summary>
    public IList<midiinstrument> midiinstrument {
        get {
            if ((this.midiinstrumentField == null)) {
                this.midiinstrumentField = new XTypedList<midiinstrument>(this, LinqToXsdTypeManager.Instance, XName.Get("midi-instrument", ""));
            }
            return this.midiinstrumentField;
        }
        set {
            if ((value == null)) {
                this.midiinstrumentField = null;
            }
            else {
                if ((this.midiinstrumentField == null)) {
                    this.midiinstrumentField = XTypedList<midiinstrument>.Initialize(this, LinqToXsdTypeManager.Instance, value, XName.Get("midi-instrument", ""));
                }
                else {
                    XTypedServices.SetList<midiinstrument>(this.midiinstrumentField, value);
                }
            }
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: required
    /// </para>
    /// </summary>
    public string id {
        get {
            XAttribute x = this.Attribute(XName.Get("id", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
        }
        set {
            this.SetAttribute(XName.Get("id", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Id).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("score-part", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<scorepart>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("identification", ""), typeof(identification));
        localElementDictionary.Add(XName.Get("part-name", ""), typeof(partname));
        localElementDictionary.Add(XName.Get("part-name-display", ""), typeof(namedisplay));
        localElementDictionary.Add(XName.Get("part-abbreviation", ""), typeof(partname));
        localElementDictionary.Add(XName.Get("part-abbreviation-display", ""), typeof(namedisplay));
        localElementDictionary.Add(XName.Get("group", ""), typeof(string));
        localElementDictionary.Add(XName.Get("score-instrument", ""), typeof(scoreinstrument));
        localElementDictionary.Add(XName.Get("midi-device", ""), typeof(mididevice));
        localElementDictionary.Add(XName.Get("midi-instrument", ""), typeof(midiinstrument));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return ContentModelEntity.Default;
    }
}

/// <summary>
/// <para>
/// The virtual-instrument element defines a specific virtual instrument used for an instrument sound.
/// </para>
/// <para>
/// Regular expression: (virtuallibrary?, virtualname?)
/// </para>
/// </summary>
public partial class virtualinstrument : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator virtualinstrument(XElement xe) { return XTypedServices.ToXTypedElement<virtualinstrument>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static virtualinstrument() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("virtual-library", "")), new NamedContentModelEntity(XName.Get("virtual-name", "")));
    }
    
    /// <summary>
    /// <para>
    /// The virtual-instrument element defines a specific virtual instrument used for an instrument sound.
    /// </para>
    /// <para>
    /// Regular expression: (virtuallibrary?, virtualname?)
    /// </para>
    /// </summary>
    public virtualinstrument() {
    }
    
    /// <summary>
    /// <para>
    /// The virtual-library element indicates the virtual instrument library name.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (virtuallibrary?, virtualname?)
    /// </para>
    /// </summary>
    public string virtuallibrary {
        get {
            XElement x = this.GetElement(XName.Get("virtual-library", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("virtual-library", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// The virtual-name element indicates the library-specific name for the virtual instrument.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (virtuallibrary?, virtualname?)
    /// </para>
    /// </summary>
    public string virtualname {
        get {
            XElement x = this.GetElement(XName.Get("virtual-name", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("virtual-name", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("virtual-instrument", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<virtualinstrument>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("virtual-library", ""), typeof(string));
        localElementDictionary.Add(XName.Get("virtual-name", ""), typeof(string));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

/// <summary>
/// <para>
/// Works are optionally identified by number and title. The work type also may indicate a link to the opus document that composes multiple scores into a collection.
/// </para>
/// <para>
/// Regular expression: (worknumber?, worktitle?, opus?)
/// </para>
/// </summary>
public partial class work : XTypedElement, IXMetaData {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static Dictionary<XName, System.Type> localElementDictionary = new Dictionary<XName, System.Type>();
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private static ContentModelEntity contentModel;
    
         public static explicit operator work(XElement xe) { return XTypedServices.ToXTypedElement<work>(xe,LinqToXsdTypeManager.Instance as ILinqToXsdTypeManager); }
    
    static work() {
        BuildElementDictionary();
        contentModel = new SequenceContentModelEntity(new NamedContentModelEntity(XName.Get("work-number", "")), new NamedContentModelEntity(XName.Get("work-title", "")), new NamedContentModelEntity(XName.Get("opus", "")));
    }
    
    /// <summary>
    /// <para>
    /// Works are optionally identified by number and title. The work type also may indicate a link to the opus document that composes multiple scores into a collection.
    /// </para>
    /// <para>
    /// Regular expression: (worknumber?, worktitle?, opus?)
    /// </para>
    /// </summary>
    public work() {
    }
    
    /// <summary>
    /// <para>
    /// The work-number element specifies the number of a work, such as its opus number.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (worknumber?, worktitle?, opus?)
    /// </para>
    /// </summary>
    public string worknumber {
        get {
            XElement x = this.GetElement(XName.Get("work-number", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("work-number", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// The work-title element specifies the title of a work, not including its opus or other work number.
    /// </para>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (worknumber?, worktitle?, opus?)
    /// </para>
    /// </summary>
    public string worktitle {
        get {
            XElement x = this.GetElement(XName.Get("work-title", ""));
            return XTypedServices.ParseValue<string>(x, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
        set {
            this.SetElement(XName.Get("work-title", ""), value, XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String).Datatype);
        }
    }
    
    /// <summary>
    /// <para>
    /// Occurrence: optional
    /// </para>
    /// <para>
    /// Regular expression: (worknumber?, worktitle?, opus?)
    /// </para>
    /// </summary>
    public opus opus {
        get {
            XElement x = this.GetElement(XName.Get("opus", ""));
            return ((opus)(x));
        }
        set {
            this.SetElement(XName.Get("opus", ""), value);
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    Dictionary<XName, System.Type> IXMetaData.LocalElementsDictionary {
        get {
            return localElementDictionary;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    XName IXMetaData.SchemaName {
        get {
            return XName.Get("work", "");
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    SchemaOrigin IXMetaData.TypeOrigin {
        get {
            return SchemaOrigin.Fragment;
        }
    }
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    ILinqToXsdTypeManager IXMetaData.TypeManager {
        get {
            return LinqToXsdTypeManager.Instance;
        }
    }
    
    public override XTypedElement Clone() {
        return XTypedServices.CloneXTypedElement<work>(this);
    }
    
    private static void BuildElementDictionary() {
        localElementDictionary.Add(XName.Get("work-number", ""), typeof(string));
        localElementDictionary.Add(XName.Get("work-title", ""), typeof(string));
        localElementDictionary.Add(XName.Get("opus", ""), typeof(opus));
    }
    
    ContentModelEntity IXMetaData.GetContentModel() {
        return contentModel;
    }
}

public class LinqToXsdTypeManager : ILinqToXsdTypeManager {
    
    static Dictionary<XName, System.Type> typeDictionary = new Dictionary<XName, System.Type>();
    
    static Dictionary<XName, System.Type> elementDictionary = new Dictionary<XName, System.Type>();
    
    private static XmlSchemaSet schemaSet;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    static LinqToXsdTypeManager typeManagerSingleton = new LinqToXsdTypeManager();
    
    static LinqToXsdTypeManager() {
        BuildTypeDictionary();
        BuildElementDictionary();
    }
    
    XmlSchemaSet ILinqToXsdTypeManager.Schemas {
        get {
            if ((schemaSet == null)) {
                XmlSchemaSet tempSet = new XmlSchemaSet();
                System.Threading.Interlocked.CompareExchange(ref schemaSet, tempSet, null);
            }
            return schemaSet;
        }
        set {
            schemaSet = value;
        }
    }
    
    Dictionary<XName, System.Type> ILinqToXsdTypeManager.GlobalTypeDictionary {
        get {
            return typeDictionary;
        }
    }
    
    Dictionary<XName, System.Type> ILinqToXsdTypeManager.GlobalElementDictionary {
        get {
            return elementDictionary;
        }
    }
    
    Dictionary<System.Type, System.Type> ILinqToXsdTypeManager.RootContentTypeMapping {
        get {
            return XTypedServices.EmptyTypeMappingDictionary;
        }
    }
    
    public static LinqToXsdTypeManager Instance {
        get {
            return typeManagerSingleton;
        }
    }
    
    private static void BuildTypeDictionary() {
        typeDictionary.Add(XName.Get("accidental-text", ""), typeof(global::accidentaltext));
        typeDictionary.Add(XName.Get("dynamics", ""), typeof(global::dynamics));
        typeDictionary.Add(XName.Get("empty", ""), typeof(global::empty));
        typeDictionary.Add(XName.Get("empty-placement", ""), typeof(global::emptyplacement));
        typeDictionary.Add(XName.Get("empty-print-style", ""), typeof(global::emptyprintstyle));
        typeDictionary.Add(XName.Get("empty-print-style-align", ""), typeof(global::emptyprintstylealign));
        typeDictionary.Add(XName.Get("empty-print-object-style-align", ""), typeof(global::emptyprintobjectstylealign));
        typeDictionary.Add(XName.Get("empty-trill-sound", ""), typeof(global::emptytrillsound));
        typeDictionary.Add(XName.Get("horizontal-turn", ""), typeof(global::horizontalturn));
        typeDictionary.Add(XName.Get("fermata", ""), typeof(global::fermata));
        typeDictionary.Add(XName.Get("fingering", ""), typeof(global::fingering));
        typeDictionary.Add(XName.Get("formatted-text", ""), typeof(global::formattedtext));
        typeDictionary.Add(XName.Get("fret", ""), typeof(global::fret));
        typeDictionary.Add(XName.Get("level", ""), typeof(global::level));
        typeDictionary.Add(XName.Get("midi-device", ""), typeof(global::mididevice));
        typeDictionary.Add(XName.Get("midi-instrument", ""), typeof(global::midiinstrument));
        typeDictionary.Add(XName.Get("name-display", ""), typeof(global::namedisplay));
        typeDictionary.Add(XName.Get("other-play", ""), typeof(global::otherplay));
        typeDictionary.Add(XName.Get("play", ""), typeof(global::play));
        typeDictionary.Add(XName.Get("string", ""), typeof(global::@string));
        typeDictionary.Add(XName.Get("typed-text", ""), typeof(global::typedtext));
        typeDictionary.Add(XName.Get("wavy-line", ""), typeof(global::wavyline));
        typeDictionary.Add(XName.Get("attributes", ""), typeof(global::attributes));
        typeDictionary.Add(XName.Get("beat-repeat", ""), typeof(global::beatrepeat));
        typeDictionary.Add(XName.Get("cancel", ""), typeof(global::cancel));
        typeDictionary.Add(XName.Get("clef", ""), typeof(global::clef));
        typeDictionary.Add(XName.Get("interchangeable", ""), typeof(global::interchangeable));
        typeDictionary.Add(XName.Get("key", ""), typeof(global::key));
        typeDictionary.Add(XName.Get("key-octave", ""), typeof(global::keyoctave));
        typeDictionary.Add(XName.Get("measure-repeat", ""), typeof(global::measurerepeat));
        typeDictionary.Add(XName.Get("measure-style", ""), typeof(global::measurestyle));
        typeDictionary.Add(XName.Get("multiple-rest", ""), typeof(global::multiplerest));
        typeDictionary.Add(XName.Get("part-symbol", ""), typeof(global::partsymbol));
        typeDictionary.Add(XName.Get("slash", ""), typeof(global::slash));
        typeDictionary.Add(XName.Get("staff-details", ""), typeof(global::staffdetails));
        typeDictionary.Add(XName.Get("staff-tuning", ""), typeof(global::stafftuning));
        typeDictionary.Add(XName.Get("time", ""), typeof(global::time));
        typeDictionary.Add(XName.Get("transpose", ""), typeof(global::transpose));
        typeDictionary.Add(XName.Get("bar-style-color", ""), typeof(global::barstylecolor));
        typeDictionary.Add(XName.Get("barline", ""), typeof(global::barline));
        typeDictionary.Add(XName.Get("ending", ""), typeof(global::ending));
        typeDictionary.Add(XName.Get("repeat", ""), typeof(global::repeat));
        typeDictionary.Add(XName.Get("accord", ""), typeof(global::accord));
        typeDictionary.Add(XName.Get("accordion-registration", ""), typeof(global::accordionregistration));
        typeDictionary.Add(XName.Get("barre", ""), typeof(global::barre));
        typeDictionary.Add(XName.Get("bass", ""), typeof(global::bass));
        typeDictionary.Add(XName.Get("bass-alter", ""), typeof(global::bassalter));
        typeDictionary.Add(XName.Get("bass-step", ""), typeof(global::bassstep));
        typeDictionary.Add(XName.Get("beater", ""), typeof(global::beater));
        typeDictionary.Add(XName.Get("bracket", ""), typeof(global::bracket));
        typeDictionary.Add(XName.Get("dashes", ""), typeof(global::dashes));
        typeDictionary.Add(XName.Get("degree", ""), typeof(global::degree));
        typeDictionary.Add(XName.Get("degree-alter", ""), typeof(global::degreealter));
        typeDictionary.Add(XName.Get("degree-type", ""), typeof(global::degreetype));
        typeDictionary.Add(XName.Get("degree-value", ""), typeof(global::degreevalue));
        typeDictionary.Add(XName.Get("direction", ""), typeof(global::direction));
        typeDictionary.Add(XName.Get("direction-type", ""), typeof(global::directiontype));
        typeDictionary.Add(XName.Get("feature", ""), typeof(global::feature));
        typeDictionary.Add(XName.Get("first-fret", ""), typeof(global::firstfret));
        typeDictionary.Add(XName.Get("frame", ""), typeof(global::frame));
        typeDictionary.Add(XName.Get("frame-note", ""), typeof(global::framenote));
        typeDictionary.Add(XName.Get("grouping", ""), typeof(global::grouping));
        typeDictionary.Add(XName.Get("harmony", ""), typeof(global::harmony));
        typeDictionary.Add(XName.Get("harp-pedals", ""), typeof(global::harppedals));
        typeDictionary.Add(XName.Get("image", ""), typeof(global::image));
        typeDictionary.Add(XName.Get("inversion", ""), typeof(global::inversion));
        typeDictionary.Add(XName.Get("kind", ""), typeof(global::kind));
        typeDictionary.Add(XName.Get("measure-numbering", ""), typeof(global::measurenumbering));
        typeDictionary.Add(XName.Get("metronome", ""), typeof(global::metronome));
        typeDictionary.Add(XName.Get("metronome-beam", ""), typeof(global::metronomebeam));
        typeDictionary.Add(XName.Get("metronome-note", ""), typeof(global::metronomenote));
        typeDictionary.Add(XName.Get("metronome-tuplet", ""), typeof(global::metronometuplet));
        typeDictionary.Add(XName.Get("octave-shift", ""), typeof(global::octaveshift));
        typeDictionary.Add(XName.Get("offset", ""), typeof(global::offset));
        typeDictionary.Add(XName.Get("other-direction", ""), typeof(global::otherdirection));
        typeDictionary.Add(XName.Get("pedal", ""), typeof(global::pedal));
        typeDictionary.Add(XName.Get("pedal-tuning", ""), typeof(global::pedaltuning));
        typeDictionary.Add(XName.Get("per-minute", ""), typeof(global::perminute));
        typeDictionary.Add(XName.Get("percussion", ""), typeof(global::percussion));
        typeDictionary.Add(XName.Get("principal-voice", ""), typeof(global::principalvoice));
        typeDictionary.Add(XName.Get("print", ""), typeof(global::print));
        typeDictionary.Add(XName.Get("root", ""), typeof(global::root));
        typeDictionary.Add(XName.Get("root-alter", ""), typeof(global::rootalter));
        typeDictionary.Add(XName.Get("root-step", ""), typeof(global::rootstep));
        typeDictionary.Add(XName.Get("scordatura", ""), typeof(global::scordatura));
        typeDictionary.Add(XName.Get("sound", ""), typeof(global::sound));
        typeDictionary.Add(XName.Get("stick", ""), typeof(global::stick));
        typeDictionary.Add(XName.Get("string-mute", ""), typeof(global::stringmute));
        typeDictionary.Add(XName.Get("wedge", ""), typeof(global::wedge));
        typeDictionary.Add(XName.Get("encoding", ""), typeof(global::encoding));
        typeDictionary.Add(XName.Get("identification", ""), typeof(global::identification));
        typeDictionary.Add(XName.Get("miscellaneous", ""), typeof(global::miscellaneous));
        typeDictionary.Add(XName.Get("miscellaneous-field", ""), typeof(global::miscellaneousfield));
        typeDictionary.Add(XName.Get("supports", ""), typeof(global::supports));
        typeDictionary.Add(XName.Get("appearance", ""), typeof(global::appearance));
        typeDictionary.Add(XName.Get("distance", ""), typeof(global::distance));
        typeDictionary.Add(XName.Get("line-width", ""), typeof(global::linewidth));
        typeDictionary.Add(XName.Get("measure-layout", ""), typeof(global::measurelayout));
        typeDictionary.Add(XName.Get("note-size", ""), typeof(global::notesize));
        typeDictionary.Add(XName.Get("other-appearance", ""), typeof(global::otherappearance));
        typeDictionary.Add(XName.Get("page-layout", ""), typeof(global::pagelayout));
        typeDictionary.Add(XName.Get("page-margins", ""), typeof(global::pagemargins));
        typeDictionary.Add(XName.Get("scaling", ""), typeof(global::scaling));
        typeDictionary.Add(XName.Get("staff-layout", ""), typeof(global::stafflayout));
        typeDictionary.Add(XName.Get("system-dividers", ""), typeof(global::systemdividers));
        typeDictionary.Add(XName.Get("system-layout", ""), typeof(global::systemlayout));
        typeDictionary.Add(XName.Get("system-margins", ""), typeof(global::systemmargins));
        typeDictionary.Add(XName.Get("bookmark", ""), typeof(global::bookmark));
        typeDictionary.Add(XName.Get("link", ""), typeof(global::link));
        typeDictionary.Add(XName.Get("accidental", ""), typeof(global::accidental));
        typeDictionary.Add(XName.Get("accidental-mark", ""), typeof(global::accidentalmark));
        typeDictionary.Add(XName.Get("arpeggiate", ""), typeof(global::arpeggiate));
        typeDictionary.Add(XName.Get("articulations", ""), typeof(global::articulations));
        typeDictionary.Add(XName.Get("arrow", ""), typeof(global::arrow));
        typeDictionary.Add(XName.Get("backup", ""), typeof(global::backup));
        typeDictionary.Add(XName.Get("beam", ""), typeof(global::beam));
        typeDictionary.Add(XName.Get("bend", ""), typeof(global::bend));
        typeDictionary.Add(XName.Get("breath-mark", ""), typeof(global::breathmark));
        typeDictionary.Add(XName.Get("empty-line", ""), typeof(global::emptyline));
        typeDictionary.Add(XName.Get("extend", ""), typeof(global::extend));
        typeDictionary.Add(XName.Get("figure", ""), typeof(global::figure));
        typeDictionary.Add(XName.Get("figured-bass", ""), typeof(global::figuredbass));
        typeDictionary.Add(XName.Get("forward", ""), typeof(global::forward));
        typeDictionary.Add(XName.Get("glissando", ""), typeof(global::glissando));
        typeDictionary.Add(XName.Get("grace", ""), typeof(global::grace));
        typeDictionary.Add(XName.Get("hammer-on-pull-off", ""), typeof(global::hammeronpulloff));
        typeDictionary.Add(XName.Get("handbell", ""), typeof(global::handbell));
        typeDictionary.Add(XName.Get("harmonic", ""), typeof(global::harmonic));
        typeDictionary.Add(XName.Get("heel-toe", ""), typeof(global::heeltoe));
        typeDictionary.Add(XName.Get("hole", ""), typeof(global::hole));
        typeDictionary.Add(XName.Get("hole-closed", ""), typeof(global::holeclosed));
        typeDictionary.Add(XName.Get("instrument", ""), typeof(global::instrument));
        typeDictionary.Add(XName.Get("lyric", ""), typeof(global::lyric));
        typeDictionary.Add(XName.Get("mordent", ""), typeof(global::mordent));
        typeDictionary.Add(XName.Get("non-arpeggiate", ""), typeof(global::nonarpeggiate));
        typeDictionary.Add(XName.Get("notations", ""), typeof(global::notations));
        typeDictionary.Add(XName.Get("note", ""), typeof(global::note));
        typeDictionary.Add(XName.Get("note-type", ""), typeof(global::notetype));
        typeDictionary.Add(XName.Get("notehead", ""), typeof(global::notehead));
        typeDictionary.Add(XName.Get("notehead-text", ""), typeof(global::noteheadtext));
        typeDictionary.Add(XName.Get("ornaments", ""), typeof(global::ornaments));
        typeDictionary.Add(XName.Get("other-notation", ""), typeof(global::othernotation));
        typeDictionary.Add(XName.Get("pitch", ""), typeof(global::pitch));
        typeDictionary.Add(XName.Get("placement-text", ""), typeof(global::placementtext));
        typeDictionary.Add(XName.Get("rest", ""), typeof(global::rest));
        typeDictionary.Add(XName.Get("slide", ""), typeof(global::slide));
        typeDictionary.Add(XName.Get("slur", ""), typeof(global::slur));
        typeDictionary.Add(XName.Get("stem", ""), typeof(global::stem));
        typeDictionary.Add(XName.Get("strong-accent", ""), typeof(global::strongaccent));
        typeDictionary.Add(XName.Get("style-text", ""), typeof(global::styletext));
        typeDictionary.Add(XName.Get("technical", ""), typeof(global::technical));
        typeDictionary.Add(XName.Get("text-element-data", ""), typeof(global::textelementdata));
        typeDictionary.Add(XName.Get("text-font-color", ""), typeof(global::textfontcolor));
        typeDictionary.Add(XName.Get("tie", ""), typeof(global::tie));
        typeDictionary.Add(XName.Get("tied", ""), typeof(global::tied));
        typeDictionary.Add(XName.Get("time-modification", ""), typeof(global::timemodification));
        typeDictionary.Add(XName.Get("tremolo", ""), typeof(global::tremolo));
        typeDictionary.Add(XName.Get("tuplet", ""), typeof(global::tuplet));
        typeDictionary.Add(XName.Get("tuplet-dot", ""), typeof(global::tupletdot));
        typeDictionary.Add(XName.Get("tuplet-number", ""), typeof(global::tupletnumber));
        typeDictionary.Add(XName.Get("tuplet-portion", ""), typeof(global::tupletportion));
        typeDictionary.Add(XName.Get("tuplet-type", ""), typeof(global::tuplettype));
        typeDictionary.Add(XName.Get("unpitched", ""), typeof(global::unpitched));
        typeDictionary.Add(XName.Get("credit", ""), typeof(global::credit));
        typeDictionary.Add(XName.Get("defaults", ""), typeof(global::defaults));
        typeDictionary.Add(XName.Get("empty-font", ""), typeof(global::emptyfont));
        typeDictionary.Add(XName.Get("group-barline", ""), typeof(global::groupbarline));
        typeDictionary.Add(XName.Get("group-name", ""), typeof(global::groupname));
        typeDictionary.Add(XName.Get("group-symbol", ""), typeof(global::groupsymbol));
        typeDictionary.Add(XName.Get("lyric-font", ""), typeof(global::lyricfont));
        typeDictionary.Add(XName.Get("lyric-language", ""), typeof(global::lyriclanguage));
        typeDictionary.Add(XName.Get("opus", ""), typeof(global::opus));
        typeDictionary.Add(XName.Get("part-group", ""), typeof(global::partgroup));
        typeDictionary.Add(XName.Get("part-list", ""), typeof(global::partlist));
        typeDictionary.Add(XName.Get("part-name", ""), typeof(global::partname));
        typeDictionary.Add(XName.Get("score-instrument", ""), typeof(global::scoreinstrument));
        typeDictionary.Add(XName.Get("score-part", ""), typeof(global::scorepart));
        typeDictionary.Add(XName.Get("virtual-instrument", ""), typeof(global::virtualinstrument));
        typeDictionary.Add(XName.Get("work", ""), typeof(global::work));
    }
    
    private static void BuildElementDictionary() {
        elementDictionary.Add(XName.Get("score-partwise", ""), typeof(global::scorepartwise));
        elementDictionary.Add(XName.Get("score-timewise", ""), typeof(global::scoretimewise));
    }
    
    protected internal static void AddSchemas(XmlSchemaSet schemas) {
        schemas.Add(schemaSet);
    }
    
    public static System.Type GetRootType() {
        return elementDictionary[XName.Get("score-partwise", "")];
    }
}

public partial class XRootNamespace {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XDocument doc;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedElement rootObject;
    

    public scorepartwise scorepartwise {  get {return rootObject as scorepartwise; } }

    public scoretimewise scoretimewise {  get {return rootObject as scoretimewise; } }
    
    private XRootNamespace() {
    }
    
    public XRootNamespace(scorepartwise root) {
        this.doc = new XDocument(root.Untyped);
        this.rootObject = root;
    }
    
    public XRootNamespace(scoretimewise root) {
        this.doc = new XDocument(root.Untyped);
        this.rootObject = root;
    }
    
    public XDocument XDocument {
        get {
            return doc;
        }
    }
    
    public static XRootNamespace Load(string xmlFile) {
        XRootNamespace root = new XRootNamespace();
        root.doc = XDocument.Load(xmlFile);
        XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
        if ((typedRoot == null)) {
            throw new LinqToXsdException("Invalid root element in xml document.");
        }
        root.rootObject = typedRoot;
        return root;
    }
    
    public static XRootNamespace Load(string xmlFile, LoadOptions options) {
        XRootNamespace root = new XRootNamespace();
        root.doc = XDocument.Load(xmlFile, options);
        XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
        if ((typedRoot == null)) {
            throw new LinqToXsdException("Invalid root element in xml document.");
        }
        root.rootObject = typedRoot;
        return root;
    }
    
    public static XRootNamespace Load(TextReader textReader) {
        XRootNamespace root = new XRootNamespace();
        root.doc = XDocument.Load(textReader);
        XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
        if ((typedRoot == null)) {
            throw new LinqToXsdException("Invalid root element in xml document.");
        }
        root.rootObject = typedRoot;
        return root;
    }
    
    public static XRootNamespace Load(TextReader textReader, LoadOptions options) {
        XRootNamespace root = new XRootNamespace();
        root.doc = XDocument.Load(textReader, options);
        XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
        if ((typedRoot == null)) {
            throw new LinqToXsdException("Invalid root element in xml document.");
        }
        root.rootObject = typedRoot;
        return root;
    }
    
    public static XRootNamespace Load(XmlReader xmlReader) {
        XRootNamespace root = new XRootNamespace();
        root.doc = XDocument.Load(xmlReader);
        XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
        if ((typedRoot == null)) {
            throw new LinqToXsdException("Invalid root element in xml document.");
        }
        root.rootObject = typedRoot;
        return root;
    }
    
    public static XRootNamespace Parse(string text) {
        XRootNamespace root = new XRootNamespace();
        root.doc = XDocument.Parse(text);
        XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
        if ((typedRoot == null)) {
            throw new LinqToXsdException("Invalid root element in xml document.");
        }
        root.rootObject = typedRoot;
        return root;
    }
    
    public static XRootNamespace Parse(string text, LoadOptions options) {
        XRootNamespace root = new XRootNamespace();
        root.doc = XDocument.Parse(text, options);
        XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
        if ((typedRoot == null)) {
            throw new LinqToXsdException("Invalid root element in xml document.");
        }
        root.rootObject = typedRoot;
        return root;
    }
    
    public virtual void Save(string fileName) {
        doc.Save(fileName);
    }
    
    public virtual void Save(TextWriter textWriter) {
        doc.Save(textWriter);
    }
    
    public virtual void Save(XmlWriter writer) {
        doc.Save(writer);
    }
    
    public virtual void Save(TextWriter textWriter, SaveOptions options) {
        doc.Save(textWriter, options);
    }
    
    public virtual void Save(string fileName, SaveOptions options) {
        doc.Save(fileName, options);
    }
}

public partial class XRoot {
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XDocument doc;
    
    [DebuggerBrowsable(DebuggerBrowsableState.Never)]
    private XTypedElement rootObject;
    

    public scorepartwise scorepartwise {  get {return rootObject as scorepartwise; } }

    public scoretimewise scoretimewise {  get {return rootObject as scoretimewise; } }
    
    private XRoot() {
    }
    
    public XRoot(scorepartwise root) {
        this.doc = new XDocument(root.Untyped);
        this.rootObject = root;
    }
    
    public XRoot(scoretimewise root) {
        this.doc = new XDocument(root.Untyped);
        this.rootObject = root;
    }
    
    public XDocument XDocument {
        get {
            return doc;
        }
    }
    
    public static XRoot Load(string xmlFile) {
        XRoot root = new XRoot();
        root.doc = XDocument.Load(xmlFile);
        XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
        if ((typedRoot == null)) {
            throw new LinqToXsdException("Invalid root element in xml document.");
        }
        root.rootObject = typedRoot;
        return root;
    }
    
    public static XRoot Load(string xmlFile, LoadOptions options) {
        XRoot root = new XRoot();
        root.doc = XDocument.Load(xmlFile, options);
        XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
        if ((typedRoot == null)) {
            throw new LinqToXsdException("Invalid root element in xml document.");
        }
        root.rootObject = typedRoot;
        return root;
    }
    
    public static XRoot Load(TextReader textReader) {
        XRoot root = new XRoot();
        root.doc = XDocument.Load(textReader);
        XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
        if ((typedRoot == null)) {
            throw new LinqToXsdException("Invalid root element in xml document.");
        }
        root.rootObject = typedRoot;
        return root;
    }
    
    public static XRoot Load(TextReader textReader, LoadOptions options) {
        XRoot root = new XRoot();
        root.doc = XDocument.Load(textReader, options);
        XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
        if ((typedRoot == null)) {
            throw new LinqToXsdException("Invalid root element in xml document.");
        }
        root.rootObject = typedRoot;
        return root;
    }
    
    public static XRoot Load(XmlReader xmlReader) {
        XRoot root = new XRoot();
        root.doc = XDocument.Load(xmlReader);
        XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
        if ((typedRoot == null)) {
            throw new LinqToXsdException("Invalid root element in xml document.");
        }
        root.rootObject = typedRoot;
        return root;
    }
    
    public static XRoot Parse(string text) {
        XRoot root = new XRoot();
        root.doc = XDocument.Parse(text);
        XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
        if ((typedRoot == null)) {
            throw new LinqToXsdException("Invalid root element in xml document.");
        }
        root.rootObject = typedRoot;
        return root;
    }
    
    public static XRoot Parse(string text, LoadOptions options) {
        XRoot root = new XRoot();
        root.doc = XDocument.Parse(text, options);
        XTypedElement typedRoot = XTypedServices.ToXTypedElement(root.doc.Root, LinqToXsdTypeManager.Instance);
        if ((typedRoot == null)) {
            throw new LinqToXsdException("Invalid root element in xml document.");
        }
        root.rootObject = typedRoot;
        return root;
    }
    
    public virtual void Save(string fileName) {
        doc.Save(fileName);
    }
    
    public virtual void Save(TextWriter textWriter) {
        doc.Save(textWriter);
    }
    
    public virtual void Save(XmlWriter writer) {
        doc.Save(writer);
    }
    
    public virtual void Save(TextWriter textWriter, SaveOptions options) {
        doc.Save(textWriter, options);
    }
    
    public virtual void Save(string fileName, SaveOptions options) {
        doc.Save(fileName, options);
    }
}
namespace www.w3.org.XML.Item1998.@namespace {
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.IO;
    using System.Diagnostics;
    using System.Xml;
    using System.Xml.Schema;
    using System.Xml.Linq;
    using Xml.Schema.Linq;
    
    
    public sealed class lang {
        
        [DebuggerBrowsable(DebuggerBrowsableState.Never)]
        public static Xml.Schema.Linq.SimpleTypeValidator TypeDefinition = new Xml.Schema.Linq.UnionSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.AnyAtomicType), null, new Xml.Schema.Linq.SimpleTypeValidator[] {
                    new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.Language), null),
                    new Xml.Schema.Linq.AtomicSimpleTypeValidator(XmlSchemaType.GetBuiltInSimpleType(XmlTypeCode.String), new Xml.Schema.Linq.RestrictionFacets(((Xml.Schema.Linq.RestrictionFlags)(16)), new object[] {
                                    ""}, 0, 0, null, null, 0, null, null, 0, null, 0, XmlSchemaWhiteSpace.Preserve))});
        
        private lang() {
        }
    }
}
